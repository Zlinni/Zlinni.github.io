<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鱼与前端🐟</title>
  
  <subtitle>摸鱼和工作不可得兼~</subtitle>
  <link href="https://zlinni.github.io/atom.xml" rel="self"/>
  
  <link href="https://zlinni.github.io/"/>
  <updated>2025-02-28T06:40:25.243Z</updated>
  <id>https://zlinni.github.io/</id>
  
  <author>
    <name>Zlinni</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vee-validate 表单状态管理</title>
    <link href="https://zlinni.github.io/posts/20240531115155/"/>
    <id>https://zlinni.github.io/posts/20240531115155/</id>
    <published>2024-05-31T03:51:55.000Z</published>
    <updated>2025-02-28T06:40:25.243Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note primary flat"><p>本文系统介绍了使用 vee-validate 结合 zod 进行表单状态管理的解决方案，通过对比传统声明式表单验证的局限性（需手动声明响应式变量/校验规则），重点展示了该方案通过高阶组件与组合式 API 实现表单初始化的灵活性、利用 zod 强大的类型校验体系（支持复杂场景如文件名唯一性校验）、提供两种错误反馈机制（提交时全局校验与实时字段级校验），以及多步骤表单的字段值保留策略，最终实现更简洁高效的表单开发范式。</p></div><h1 id="vee-validate-表单状态管理"><a href="#vee-validate-表单状态管理" class="headerlink" title="vee-validate 表单状态管理"></a>vee-validate 表单状态管理</h1><h2 id="为什么要使用-vee-validate？"><a href="#为什么要使用-vee-validate？" class="headerlink" title="为什么要使用 vee-validate？"></a>为什么要使用 vee-validate？</h2><p>我们先来看看常规情况下的表单，参考 NaiveUI,使用的是声明式规则和 kv 绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;n-form ref=&quot;formRef&quot; :model=&quot;model&quot; :rules=&quot;rules&quot;&gt;</span><br><span class="line">    &lt;n-form-item path=&quot;age&quot; label=&quot;年龄&quot;&gt;</span><br><span class="line">      &lt;n-input v-model:value=&quot;model.age&quot; @keydown.enter.prevent /&gt;</span><br><span class="line">    &lt;/n-form-item&gt;</span><br><span class="line">  &lt;/n-form&gt;</span><br><span class="line">&lt;!-- 声明式规则 --&gt;</span><br><span class="line">const rules: FormRules = &#123; age: [ &#123; required: true, validator(rule:</span><br><span class="line">FormItemRule, value: string) &#123; if (!value) &#123; return new Error(&#x27;需要年龄&#x27;) &#125; else</span><br><span class="line">if (!/^\d*$/.test(value)) &#123; return new Error(&#x27;年龄应该为整数&#x27;) &#125; else if</span><br><span class="line">(Number(value) &lt; 18) &#123; return new Error(&#x27;年龄应该超过十八岁&#x27;) &#125; return true &#125;,</span><br><span class="line">trigger: [&#x27;input&#x27;, &#x27;blur&#x27;] &#125; ], &#125;</span><br></pre></td></tr></table></figure><p>声明式规则的好处是易拓展，可以随时在对应的组件上修改，但是坏处是写起来非常不方便:</p><ul><li>首先得声明响应式变量作为表单值 v-model 的绑定，有些时候还要声明未定义变量</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formData = ref(&#123; <span class="attr">name</span>: <span class="string">&quot;&quot;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> formData = ref(&#123; <span class="attr">description</span>: <span class="literal">undefined</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li>其次，对于校验，即使是判断是否最小，也得手写一部分规则</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">validator</span>(<span class="params">rule: FormItemRule, value: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;需要年龄&#x27;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>那有没有什么轻度抽象，能解决上述问题的存在呢？</p><p>答案是有的，那就是 vee-validate + zod 的双重方案，不依赖组件原生的实现</p><h2 id="vee-validate-zod"><a href="#vee-validate-zod" class="headerlink" title="vee-validate + zod"></a>vee-validate + zod</h2><ul><li><p>vee-validate 是 base on typescript 的，提供了高阶组件和组合式 API，它可以和任何的组件库集成</p></li><li><p>zod 则是一个校验器，提供了丰富且灵活校验方式，适用于表单验证等场景</p></li></ul><h3 id="多种方式初始化表单和提供响应式值"><a href="#多种方式初始化表单和提供响应式值" class="headerlink" title="多种方式初始化表单和提供响应式值"></a>多种方式初始化表单和提供响应式值</h3><ul><li>vee-validate 有多种方式初始化表单和提供响应式值，不再需要声明未定义情况</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; values, defineField &#125; = useForm(&#123;</span><br><span class="line">  <span class="attr">validationSchema</span>: toTypedSchema(</span><br><span class="line">    z.object(&#123;</span><br><span class="line">      <span class="attr">name</span>: z.string().min(<span class="number">1</span>).desribe(<span class="string">&quot;名称&quot;</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [name] = defineField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or in subcomponent</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">value</span>: name &#125; = useField&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="zod-自带校验规则"><a href="#zod-自带校验规则" class="headerlink" title="zod 自带校验规则"></a>zod 自带校验规则</h3><ul><li>zod 自带校验规则，以及提供更强大的规则定义</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = z.object(&#123;</span><br><span class="line">  <span class="attr">name</span>: z.string().min(<span class="number">1</span>).desribe(<span class="string">&quot;名称&quot;</span>),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="zod-有更强大的规则"><a href="#zod-有更强大的规则" class="headerlink" title="zod 有更强大的规则"></a>zod 有更强大的规则</h3><ul><li>zod 有更强大的规则,比如对所有文件名称进行校验</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = z.object(&#123;</span><br><span class="line">    <span class="attr">fieldInfos</span>:z.array(&#123;</span><br><span class="line">        <span class="attr">file</span>:z.instanceof(File),</span><br><span class="line">        <span class="attr">name</span>:z.string()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).superRefine(<span class="function">(<span class="params">&#123;fieldInfos&#125;,context</span>)=&gt;</span>(&#123;</span><br><span class="line">    <span class="keyword">const</span> fileNames = fieldInfos.map(<span class="function"><span class="params">i</span>=&gt;</span>i.name);</span><br><span class="line">    fieldInfos.forEach(<span class="function">(<span class="params">fieldInfo,index</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> hasExist = fileNames.include(fieldInfo.name);</span><br><span class="line">        <span class="keyword">if</span>(hasExist)&#123;</span><br><span class="line">            context.addIssue(&#123;</span><br><span class="line">                <span class="attr">code</span>:z.ZodIssueCode.custom,</span><br><span class="line">                <span class="attr">message</span>: <span class="string">&#x27;文件名已存在&#x27;</span>,</span><br><span class="line">                <span class="attr">path</span>: [<span class="string">&#x27;fileInfos&#x27;</span>, index, <span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><h3 id="错误的-UI-响应"><a href="#错误的-UI-响应" class="headerlink" title="错误的 UI 响应"></a>错误的 UI 响应</h3><ul><li>对于错误的 UI 响应，有两种方式</li></ul><ol><li>提交时报错，利用 handleSubmit 的第二个参数注入错误回调处理</li></ol><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleSubmit提交中会自动触发一次校验，若失败会执行失败回调，反之才会执行内部提交</span></span><br><span class="line"><span class="keyword">const</span> submit = handleSubmit(<span class="function">(<span class="params">values</span>)=&gt;</span>&#123;</span><br><span class="line">    yourApi.post(&#123;...values&#125;)</span><br><span class="line">    <span class="comment">// 重置表单，or 销毁组件</span></span><br><span class="line">&#125;,<span class="function">(<span class="params">&#123;errors&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(errors)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;form <span class="meta">@submit</span>=&#123;submit&#125;&gt;</span><br></pre></td></tr></table></figure><ol><li>提交前报错，借助 defineField 的第二个 props，或者借助 useField 的 error</li></ol><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐使用 因为要显示错误信息一般是表单控件，我们有更好的解决办法</span></span><br><span class="line"><span class="keyword">const</span> [name, nameProps] = defineField(<span class="string">&quot;name&quot;</span>, <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">validationStatus</span>: state.errors[<span class="number">0</span>] ? (<span class="string">&quot;error&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>) : <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">feedback</span>: state.errors[<span class="number">0</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表单组件抽象 更方便的解决办法</span></span><br><span class="line"><span class="keyword">const</span> &#123; value, errorMessage &#125; = useField(<span class="function">() =&gt;</span> props.name);</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">NFormItem</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">:label</span>=<span class="string">&quot;props.label&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">:showLabel</span>=<span class="string">&quot;!!props.label&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">:required</span>=<span class="string">&quot;props.required&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">:validationStatus</span>=<span class="string">&quot;errorMessage ? &#x27;error&#x27; : &#x27;success&#x27;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">:feedback</span>=<span class="string">&quot;errorMessage&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">:showFeedback</span>=<span class="string">&quot;!!errorMessage&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">&gt;</span></span></span><br><span class="line"><span class="xml">        // 下面绑定value</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">NFormItem</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="多步骤表单"><a href="#多步骤表单" class="headerlink" title="多步骤表单"></a>多步骤表单</h3><p>如果组件是多步骤表单，可能涉及到多个状态的组件切换，这个时候需要设置 keepValuesOnUnmount 控制单个字段卸载时的保留</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="comment">// 多步骤表单配置</span></span><br><span class="line"><span class="keyword">const</span> &#123; handleSubmit &#125; = useForm(&#123;</span><br><span class="line">  <span class="attr">keepValuesOnUnmount</span>: <span class="literal">true</span>, <span class="comment">// 保留已填写但当前不可见的字段值</span></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Step1</span> <span class="attr">v-if</span>=<span class="string">&quot;step === 1&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 输入姓名 --&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Step2</span> <span class="attr">v-if</span>=<span class="string">&quot;step === 2&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 输入地址 --&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!-- 切换步骤时，前一步的值会被保留 --&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="工程化系列" scheme="https://zlinni.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vee-validate" scheme="https://zlinni.github.io/tags/vee-validate/"/>
    
    <category term="zod" scheme="https://zlinni.github.io/tags/zod/"/>
    
  </entry>
  
  <entry>
    <title>基于CASL的前端权限管理方案</title>
    <link href="https://zlinni.github.io/posts/44742292888/"/>
    <id>https://zlinni.github.io/posts/44742292888/</id>
    <published>2024-01-05T03:51:55.000Z</published>
    <updated>2025-02-27T07:30:51.170Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note primary flat"><p>这篇文章系统介绍了基于 CASL 的前端权限管理方案，重点阐述了其通过”能力-规则-操作-主体”模型实现细粒度权限控制的机制。方案支持字段级权限校验和动态条件判断，提供 Vue 框架下的路由守卫集成、组件级权限指令、类型安全增强等实践方案，特别适合中大型项目实现灵活可维护的权限体系，通过前后端统一的权限规则格式，有效保障了系统安全性和开发效率。</p></div><h1 id="基于CASL的前端权限管理方案"><a href="#基于CASL的前端权限管理方案" class="headerlink" title="基于CASL的前端权限管理方案"></a>基于CASL的前端权限管理方案</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是-CASL"><a href="#什么是-CASL" class="headerlink" title="什么是 CASL"></a>什么是 CASL</h3><p>CASL 是一套专为 JavaScript 和 TypeScript 开发者设计的工具，用于简化和管理前端应用程序中的访问控制。通过 CASL，您可以轻松地定义和检查用户对应用程序中各种资源的权限，从而确保您的应用在安全性和用户体验方面达到最佳状态。</p><h3 id="为什么选择-CASL"><a href="#为什么选择-CASL" class="headerlink" title="为什么选择 CASL"></a>为什么选择 CASL</h3><ul><li>灵活性： CASL 提供了灵活的规则定义机制，使您能够根据业务需求轻松创建细粒度的权限规则。</li><li>易用性： CASL 的 API 设计简洁直观，使得权限管理在代码中变得容易理解和维护。</li><li>框架无关性： CASL 不依赖于特定的前端框架，因此您可以在任何框架（如 React、Angular、Vue 等）中使用。</li></ul><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><h3 id="安装-CASL"><a href="#安装-CASL" class="headerlink" title="安装 CASL"></a>安装 CASL</h3><p>使用 pnpm 安装：<br>pnpm add @casl/vue @casl/ability</p><h3 id="创建-CASL-Ability"><a href="#创建-CASL-Ability" class="headerlink" title="创建 CASL Ability"></a>创建 CASL Ability</h3><p>CASL Ability 是定义权限规则的核心。您可以在应用程序的适当位置创建 CASL Ability，并配置它以反映您的权限结构。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：创建 CASL Ability</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineAbility &#125; <span class="keyword">from</span> <span class="string">&quot;@casl/ability&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ability = defineAbility(<span class="function">(<span class="params">can</span>) =&gt;</span> &#123;</span><br><span class="line">  can(<span class="string">&quot;read&quot;</span>, <span class="string">&quot;Project&quot;</span>);</span><br><span class="line">  can(<span class="string">&quot;create&quot;</span>, <span class="string">&quot;Project&quot;</span>);</span><br><span class="line">  can(<span class="string">&quot;update&quot;</span>, <span class="string">&quot;Project&quot;</span>);</span><br><span class="line">  can(<span class="string">&quot;delete&quot;</span>, <span class="string">&quot;Project&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ability;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个简单的 CASL Ability，表示用户可以对项目进行读取、创建、更新和删除操作。</p><h3 id="集成-CASL-Ability-到应用程序"><a href="#集成-CASL-Ability-到应用程序" class="headerlink" title="集成 CASL Ability 到应用程序"></a>集成 CASL Ability 到应用程序</h3><p>集成 CASL Ability 到应用程序，以便在整个应用程序中共享和使用它。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; abilitiesPlugin &#125; <span class="keyword">from</span> <span class="string">&quot;@casl/vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ability <span class="keyword">from</span> <span class="string">&quot;./services/ability&quot;</span>;</span><br><span class="line"></span><br><span class="line">createApp()</span><br><span class="line">  .use(abilitiesPlugin, ability, &#123;</span><br><span class="line">    <span class="attr">useGlobalProperties</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Abilities（能力）的定义"><a href="#Abilities（能力）的定义" class="headerlink" title="Abilities（能力）的定义"></a>Abilities（能力）的定义</h3><p>在 CASL 中，”能力” 是指用户在应用程序中执行操作的权限。能力由一组规则（rules）组成，每个规则定义了用户对特定主体（subject）执行特定操作（action）的条件。能力的定义通常在应用程序初始化时完成。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：定义能力</span></span><br><span class="line"><span class="keyword">const</span> ability = defineAbility(<span class="function">(<span class="params">can</span>) =&gt;</span> &#123;</span><br><span class="line">  can(<span class="string">&quot;read&quot;</span>, <span class="string">&quot;Project&quot;</span>);</span><br><span class="line">  can(<span class="string">&quot;update&quot;</span>, <span class="string">&quot;Project&quot;</span>, [<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述示例中，定义了一个简单的能力，允许用户读取（read）和更新（update）名为 “Project” 的主体，其中更新操作仅允许修改 “name” 字段。</p><h3 id="Actions（操作）和-Subjects（主体）的概念"><a href="#Actions（操作）和-Subjects（主体）的概念" class="headerlink" title="Actions（操作）和 Subjects（主体）的概念"></a>Actions（操作）和 Subjects（主体）的概念</h3><ul><li>Actions（操作）： 操作表示可以在主体上执行的具体行为。常见的操作包括 “create”、”read”、”update” 和 “delete”。能力的规则将指定用户是否可以执行这些操作。</li><li>Subjects（主体）： 主体是用户执行操作的实体或资源。例如，”Project” 可能是一个主体，用户可以对其执行读取、更新等操作。</li></ul><h3 id="Rules（规则）的创建和使用"><a href="#Rules（规则）的创建和使用" class="headerlink" title="Rules（规则）的创建和使用"></a>Rules（规则）的创建和使用</h3><p>规则定义了用户对主体执行操作的条件。每个规则包含一个动作（action）、一个主体（subject）以及可选的字段（fields）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：定义规则</span></span><br><span class="line">can(<span class="string">&quot;update&quot;</span>, <span class="string">&quot;Project&quot;</span>, [<span class="string">&quot;name&quot;</span>]);</span><br></pre></td></tr></table></figure><p>上述示例中，规则表示用户可以对 “Project” 主体执行更新操作，但仅限于修改 “name” 字段。</p><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><h3 id="在组件中使用-Abilities"><a href="#在组件中使用-Abilities" class="headerlink" title="在组件中使用 Abilities"></a>在组件中使用 Abilities</h3><p>在组件中，我们可以使用 CASL 提供的 useAbility hook 来获取当前用户的 Abilities，并据此控制组件的渲染或行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div v-if=&quot;can(&#x27;create&#x27;, &#x27;Post&#x27;)&quot;&gt;</span><br><span class="line">      &lt;a @click=&quot;createPost&quot;&gt;Add Post&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useAbility &#125; from &quot;@casl/vue&quot;;</span><br><span class="line">const &#123; can &#125; = useAbility();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="在路由守卫中使用-Abilities"><a href="#在路由守卫中使用-Abilities" class="headerlink" title="在路由守卫中使用 Abilities"></a>在路由守卫中使用 Abilities</h3><p>对于基于路由的应用程序，我们可以使用 CASL Abilities 控制路由守卫，确保用户只能访问其具有权限的页面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 示例：在路由守卫中使用 Abilities import &#123; createRouter, createWebHistory &#125;</span><br><span class="line">from &#x27;vue-router&#x27;; const router = createRouter(&#123; history: createWebHistory(),</span><br><span class="line">routes: [ &#123; path: &#x27;/project/:id&#x27;, component: ProjectDetail, meta: &#123; // 使用 meta</span><br><span class="line">字段定义需要的权限 ability: &#x27;read&#x27;, subject: &#x27;Project&#x27;, &#125;, &#125;, ], &#125;); export</span><br><span class="line">default router;</span><br></pre></td></tr></table></figure><p>在 permit.ts 中定义路由守卫</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useAbility &#125; <span class="keyword">from</span> <span class="string">&quot;@casl/vue&quot;</span>;</span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ability = useAbility();</span><br><span class="line">  <span class="keyword">const</span> requiredAbility = to.meta.ability;</span><br><span class="line">  <span class="keyword">const</span> requiredSubject = to.meta.subject;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (requiredAbility &amp;&amp; requiredSubject) &#123;</span><br><span class="line">    <span class="comment">// 检查用户是否具有所需的权限</span></span><br><span class="line">    <span class="keyword">if</span> (ability.can(requiredAbility, requiredSubject)) &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 用户没有权限，重定向到其他页面或显示错误提示</span></span><br><span class="line">      next(<span class="string">&quot;/access-denied&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有定义权限要求，直接通过</span></span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="在应用程序中定义权限规则"><a href="#在应用程序中定义权限规则" class="headerlink" title="在应用程序中定义权限规则"></a>在应用程序中定义权限规则</h2><h3 id="角色和权限的概念"><a href="#角色和权限的概念" class="headerlink" title="角色和权限的概念"></a>角色和权限的概念</h3><p>在权限管理中，通常使用角色和权限的概念来组织和分配用户的权限。</p><ul><li>角色： 角色是一组权限的集合，通常代表用户在系统中的身份或职能。例如，”管理员”、”编辑者”、”普通用户” 等都可以是角色。</li><li>权限： 权限是用户能够执行的具体操作。例如，”创建项目”、”编辑文档” 等都可以是权限。</li></ul><h3 id="规划权限规则"><a href="#规划权限规则" class="headerlink" title="规划权限规则"></a>规划权限规则</h3><p>在使用 CASL 时，规划权限规则是设计健壮且易于维护的权限管理系统的关键一步。我们可以按照角色和权限的层次结构定义规则。<br>这里 manage 和 all 是 casl 中的特殊关键字，表示可以操控全部的 actions 和全部的 subjects</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：规划权限规则</span></span><br><span class="line"><span class="keyword">const</span> ability = defineAbility(<span class="function">(<span class="params">can</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (user.isAdmin) &#123;</span><br><span class="line">    <span class="comment">// 管理员拥有所有权限</span></span><br><span class="line">    can(<span class="string">&quot;manage&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (user.isEditor) &#123;</span><br><span class="line">    <span class="comment">// 编辑者有编辑和创建权限</span></span><br><span class="line">    can([<span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>], [<span class="string">&quot;Project&quot;</span>, <span class="string">&quot;Document&quot;</span>]);</span><br><span class="line">    <span class="comment">// 仅编辑者可以删除项目</span></span><br><span class="line">    can(<span class="string">&quot;delete&quot;</span>, <span class="string">&quot;Project&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 普通用户只有读取权限</span></span><br><span class="line">    can(<span class="string">&quot;read&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="将权限规则映射到-Abilities"><a href="#将权限规则映射到-Abilities" class="headerlink" title="将权限规则映射到 Abilities"></a>将权限规则映射到 Abilities</h3><p>一旦我们规划了权限规则，就可以将其映射到 CASL 的 Abilities 中。这通常在用户登录时进行，以确保用户在整个会话中具有正确的权限。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：将权限规则映射到 Abilities</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapRulesToAbilities</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> defineAbility(<span class="function">(<span class="params">can</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user.isAdmin) &#123;</span><br><span class="line">      can(<span class="string">&quot;manage&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (user.isEditor) &#123;</span><br><span class="line">      can([<span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>], [<span class="string">&quot;Project&quot;</span>, <span class="string">&quot;Document&quot;</span>]);</span><br><span class="line">      can(<span class="string">&quot;delete&quot;</span>, <span class="string">&quot;Project&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      can(<span class="string">&quot;read&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在用户登录后调用</span></span><br><span class="line"><span class="keyword">const</span> user = loginUser(); <span class="comment">// 假设有登录函数</span></span><br><span class="line"><span class="keyword">const</span> userAbilities = mapRulesToAbilities(user);</span><br></pre></td></tr></table></figure><h3 id="权限规则的更新"><a href="#权限规则的更新" class="headerlink" title="权限规则的更新"></a>权限规则的更新</h3><p>除了覆盖规则，我们会遇到动态规则的场景，在这个场景下就需要进行规则的更新；</p><ol><li>如果是采用了 new AbilityBuilder 的 ability，可以这样进行更新</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ability = <span class="keyword">new</span> AbilityBuilder();</span><br><span class="line">ability.rules = rules;</span><br></pre></td></tr></table></figure><ol><li>其他</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ability.update(rules);</span><br></pre></td></tr></table></figure><h3 id="权限规则与后端的集成"><a href="#权限规则与后端的集成" class="headerlink" title="权限规则与后端的集成"></a>权限规则与后端的集成</h3><p>casl 是参考自 mongodb 的一个权限管理库，因此他的权限模型也和 mongo 对象类型类似；我们更期望后端能够传递如下类型的数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">rules</span>: [&#123;</span><br><span class="line">      <span class="attr">action</span>: <span class="string">&#x27;read&#x27;</span>,</span><br><span class="line">      <span class="attr">subject</span>: <span class="string">&#x27;Article&#x27;</span>,</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">      <span class="attr">action</span>: <span class="string">&#x27;update&#x27;</span>,</span><br><span class="line">      <span class="attr">subject</span>: <span class="string">&#x27;Article&#x27;</span>,</span><br><span class="line">      <span class="attr">conditions</span>: &#123;</span><br><span class="line">          <span class="attr">published</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例和实践"><a href="#示例和实践" class="headerlink" title="示例和实践"></a>示例和实践</h2><p>文档中有描述很多实践操作，比如增强视图类型，组合 api，组合 actions(别名)，can 组件等；这里搬运一点经常使用到的功能；</p><h3 id="增强视图类型"><a href="#增强视图类型" class="headerlink" title="增强视图类型"></a>增强视图类型</h3><p>TypeScript 没有其他方法可以在不进行增强的情况下了解全局属性的类型。为此，我们添加 src/shims-ability.d.ts 文件，其中包含以下内容：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AppAbility &#125; <span class="keyword">from</span> <span class="string">&quot;./AppAbility&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">module</span> <span class="string">&quot;vue&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> ComponentCustomProperties &#123;</span><br><span class="line">    <span class="attr">$ability</span>: AppAbility;</span><br><span class="line">    $can(<span class="built_in">this</span>: <span class="built_in">this</span>, ...args: Parameters&lt;<span class="built_in">this</span>[<span class="string">&quot;$ability&quot;</span>][<span class="string">&quot;can&quot;</span>]&gt;): <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合-Api"><a href="#组合-Api" class="headerlink" title="组合 Api"></a>组合 Api</h3><p>我们可以创建一个单独的 useAppAbility 钩子，这样我们就不需要导入 useAbility 和 AppAbility 在每个组件中，我们想要检查权限，但只需导入一个钩子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useAbility &#125; <span class="keyword">from</span> <span class="string">&quot;@casl/vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppAbility &#125; <span class="keyword">from</span> <span class="string">&quot;../AppAbility&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useAppAbility = <span class="function">() =&gt;</span> useAbility&lt;AppAbility&gt;();</span><br></pre></td></tr></table></figure><h3 id="ability-类型定义"><a href="#ability-类型定义" class="headerlink" title="ability 类型定义"></a>ability 类型定义</h3><ul><li>创建 Actions 类型</li><li>创建 Subjects 类型</li><li>创建由 MatchConditions 拓展的 Conditions 类型，包含了可能存在的操作</li><li>组合类型 CreateAbliity</li><li>构造 ability，<ul><li>可提供 fieldMatcher 用于字段为数组时候的判断；</li><li>可提供 conditionsMatcher 针对 condition 项进行配置</li></ul></li><li>导出 CreateAbliityRules 规则（这部分规则其实可以是后端提供相同类型）</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="keyword">type</span> SubjectRawRule,</span><br><span class="line">  AbilityBuilder,</span><br><span class="line">  createMongoAbility,</span><br><span class="line">  <span class="keyword">type</span> MongoAbility,</span><br><span class="line">  <span class="keyword">type</span> MongoQuery,</span><br><span class="line">  <span class="keyword">type</span> InferSubjects,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;@casl/ability&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Actions = <span class="string">&quot;create&quot;</span> | <span class="string">&quot;read&quot;</span> | <span class="string">&quot;update&quot;</span> | <span class="string">&quot;delete&quot;</span> | <span class="string">&quot;download&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConditionsExtra = &#123;</span><br><span class="line">  published?: <span class="built_in">boolean</span>;</span><br><span class="line">  drop?: <span class="built_in">boolean</span>;</span><br><span class="line">  recover?: <span class="built_in">boolean</span>;</span><br><span class="line">  newVersion?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Folder</span> </span>&#123;</span><br><span class="line">  drop?: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  recover?: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  published?: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  newVersion?: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> </span>&#123;</span><br><span class="line">  drop?: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  recover?: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  published?: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">  newVersion?: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Subjects =</span><br><span class="line">  | <span class="string">&quot;Global&quot;</span></span><br><span class="line">  | <span class="string">&quot;Project&quot;</span></span><br><span class="line">  | InferSubjects&lt;<span class="keyword">typeof</span> Folder | <span class="keyword">typeof</span> File&gt;</span><br><span class="line">  | <span class="string">&quot;Folder&quot;</span></span><br><span class="line">  | <span class="string">&quot;File&quot;</span></span><br><span class="line">  | <span class="string">&quot;all&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> CreateAbliity = MongoAbility&lt;[Actions, Subjects], MongoQuery&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createAbliity = <span class="keyword">new</span> AbilityBuilder&lt;CreateAbliity&gt;(</span><br><span class="line">  createMongoAbility</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 定义user的权限，后期可根据userId改造等</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createForUser = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ability = <span class="keyword">new</span> AbilityBuilder(</span><br><span class="line">    createMongoAbility&lt;[Actions, Subjects], MongoQuery&gt;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> ability.build(&#123;</span><br><span class="line">    <span class="comment">// detectSubjectType: subject =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   return subject.__caslSubjectType__ as ExtractSubjectType&lt;Subjects&gt;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="attr">fieldMatcher</span>: <span class="function">(<span class="params">fields</span>) =&gt;</span> <span class="function">(<span class="params">field</span>) =&gt;</span> fields.includes(field),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createUserAbility = createForUser();</span><br><span class="line"><span class="comment">// 临时</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> CreateAbliityRules = SubjectRawRule&lt;</span><br><span class="line">  Actions,</span><br><span class="line">  <span class="string">&quot;Global&quot;</span> | <span class="string">&quot;Project&quot;</span> | <span class="string">&quot;Folder&quot;</span> | <span class="string">&quot;File&quot;</span>,</span><br><span class="line">  ConditionsExtra</span><br><span class="line">&gt;;</span><br></pre></td></tr></table></figure><h3 id="Subject-helper"><a href="#Subject-helper" class="headerlink" title="Subject helper"></a>Subject helper</h3><p>用于判断对应的 condition 条件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; subject &#125; <span class="keyword">from</span> <span class="string">&quot;@casl/ability&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (cannot(<span class="string">&quot;create&quot;</span>, subject(<span class="string">&quot;File&quot;</span>, &#123; <span class="attr">published</span>: <span class="literal">true</span>, <span class="attr">newVersion</span>: <span class="literal">false</span> &#125;))) &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Can-组件"><a href="#Can-组件" class="headerlink" title="Can 组件"></a>Can 组件</h3><p>将 can 组件作为全局组件注册</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Can &#125; <span class="keyword">from</span> <span class="string">&quot;@casl/vue&quot;</span>;</span><br><span class="line">app.component(Can.name, Can);</span><br><span class="line">导出Can组件类型;</span><br><span class="line"><span class="keyword">import</span> &#123; Can &#125; <span class="keyword">from</span> <span class="string">&quot;@casl/vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="built_in">module</span> <span class="string">&quot;vue&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> GlobalComponents &#123;</span><br><span class="line">    <span class="attr">Can</span>: <span class="keyword">typeof</span> Can;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Can 组件由于不支持 object 类型，所以使用 subject helper 的时候需要注意改为 function，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;Can</span><br><span class="line">  I=&quot;update&quot;</span><br><span class="line">  :a=&quot;() =&gt; subject(&#x27;File&#x27;, &#123; recover: true &#125;)&quot;</span><br><span class="line">  passThrough</span><br><span class="line">  v-slot=&quot;&#123; allowed &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">      &lt;NxButton</span><br><span class="line">        v-if=&quot;props.showButtons?.includes(&#x27;move&#x27;)&quot;</span><br><span class="line">        :disabled=&quot;!allowed || isDisabled&quot;</span><br><span class="line">        variant=&quot;outline&quot;</span><br><span class="line">        @click=&quot;handleClick(&#x27;move&#x27;)&quot;&gt;</span><br><span class="line">        &lt;template #icon&gt;</span><br><span class="line">          &lt;IconTool icon=&quot;bi:arrow-bar-left&quot; size=&quot;16&quot; /&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">        移动</span><br><span class="line">      &lt;/NxButton&gt;</span><br><span class="line">    &lt;/Can&gt;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://casl.js.org/v6/en/package/casl-vue#augment-vue-types">https://casl.js.org/v6/en/package/casl-vue#augment-vue-types</a></li><li><a href="https://juejin.cn/post/6882645988293640200?searchId=202312191420517E21AD634C1879FB7C14#heading-1">https://juejin.cn/post/6882645988293640200?searchId=202312191420517E21AD634C1879FB7C14#heading-1</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="工程化系列" scheme="https://zlinni.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="casl" scheme="https://zlinni.github.io/tags/casl/"/>
    
  </entry>
  
  <entry>
    <title>TanStack Query 请求状态管理</title>
    <link href="https://zlinni.github.io/posts/20231015115155/"/>
    <id>https://zlinni.github.io/posts/20231015115155/</id>
    <published>2023-10-15T03:51:55.000Z</published>
    <updated>2025-02-27T07:29:34.334Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note primary flat"><p>这篇文章系统介绍了 TanStack Query 在前端请求状态管理中的应用，核心围绕三个关键模块：useQuery（响应式数据获取，支持自动刷新和条件请求）、useMutation（处理副作用操作，提供完整生命周期回调）和 queryClient（请求中继器，支持手动缓存控制）。文章重点阐述了项目实践规范，包括分层架构设计（api/query/type 文件分离）、类型安全规范（DTO/VO 实体定义）以及响应式参数处理技巧（maybeRefOrGetter + toValue 组合），最后还提及了通过 IDE 插件实现代码规范自动化生成的高效开发模式。</p></div><h1 id="TanStack-Query-请求状态管理"><a href="#TanStack-Query-请求状态管理" class="headerlink" title="TanStack Query 请求状态管理"></a>TanStack Query 请求状态管理</h1><h2 id="什么是-Tanstack-Query？为什么要使用它"><a href="#什么是-Tanstack-Query？为什么要使用它" class="headerlink" title="什么是 Tanstack Query？为什么要使用它"></a>什么是 Tanstack Query？为什么要使用它</h2><p>tanstackQuery 我个人认为是一个请求调用的效率提升工具；帮助开发者基于响应式获取请求数据，基于函数式规范调用接口；</p><p>tanstackquery 主要分为两部分实现，一部分是 useQuery，一部分是 useMutation；<br>两部分实现都是对请求的抽象调用和获取，我们可以简单的理解为，useQuery 是用于自动化（响应式）获取请求，而 useMutation 用于手动调用请求;<br>及后文会提到的 queryClient，掌握这三者的用法可以帮助你快速开发项目；</p><h3 id="useQuery"><a href="#useQuery" class="headerlink" title="useQuery"></a>useQuery</h3><ul><li>有了 useQuery 之后，我们不再需要手动请求接口，改为响应式获取值</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data &#125; = useQuery(&#123;</span><br><span class="line">  ...blogQuery.getBlogDetail(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">id</span>: id.value,</span><br><span class="line">  &#125;)),</span><br><span class="line">  <span class="attr">enabled</span>: <span class="function">() =&gt;</span> !!id.value,</span><br><span class="line">&#125;);</span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.value); <span class="comment">// data是响应式的</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>对于用户操作导致的接口数据更新，我们不再需要借助 store/emit 等通信方式，直接调用 queryClient.invalidateQueries()刷新请求</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">const</span> &#123; data &#125; = useQuery(&#123;</span><br><span class="line">  ...blogQuery.getBlogDetail(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">id</span>: id.value,</span><br><span class="line">  &#125;)),</span><br><span class="line">  <span class="attr">enabled</span>: <span class="function">() =&gt;</span> !!id.value,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件 刷新</span></span><br><span class="line"><span class="keyword">const</span> queryClient = useQueryClient();</span><br><span class="line">queryClient.invalidateQueries();</span><br></pre></td></tr></table></figure><ul><li>控制 useQuery 是否能执行<br>useQuery 自身具备控制请求是否能执行的函数：enabled</li></ul><p>enabled 是一个响应式参数，可以传入()=&gt;xxx.value 控制</p><p>示例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> id = ref();</span><br><span class="line">useQuery(&#123;</span><br><span class="line">  ...blogQuery.getBlogDetail(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">id</span>: id.value,</span><br><span class="line">  &#125;)),</span><br><span class="line">  <span class="attr">enabled</span>: <span class="function">() =&gt;</span> !!id.value,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>常见的使用 useQuery 的场景有：<br>列表类数据初始化获取</p><h3 id="useMutation"><a href="#useMutation" class="headerlink" title="useMutation"></a>useMutation</h3><p>useMutation 是一个回调函数式的 API，他有 onSuccess，onError，onSettled 回调，很方便的让使用者做不同阶段的操作；下面是一个示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">mutate</span>: createBlog &#125; = useMutation(&#123;</span><br><span class="line">  <span class="attr">mutationFn</span>: blogAPI.createBlog,</span><br><span class="line">  <span class="function"><span class="title">onSuccess</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 成功回调</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">onError</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 错误提示 上报等</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">onSettled</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建后刷新列表</span></span><br><span class="line">    queryClient.invalidateQuries();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>常见的使用 useMutation 的场景有：<br>post，put，delete 等请求</p><h3 id="queryClient"><a href="#queryClient" class="headerlink" title="queryClient"></a>queryClient</h3><p>queryClient 是 tanstackQuery 的请求中继，不依赖 setup，更像是对 api 的直接调用，但是他有如下的好处</p><ul><li>queryClient.fetchQuery() 手动调用请求，无视缓存</li></ul><p>我个人更喜欢在 useXXXDialog.tsx 中使用他，因为 naive-ui 的 dialog 是函数式创建的，尽量少写副作用较好</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> queryClient.fetchQuery(</span><br><span class="line">  blogQuery.getBlogDetail(&#123;</span><br><span class="line">    <span class="attr">id</span>: id.value,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>queryClient.ensureQuery() 手动调用请求，优先从缓存中寻找，再则调用请求</li></ul><p>这个使用的话更倾向于缓存优先，特别是有些时候在项目中明确这个请求是基于缓存的时候，就可以优先使用它</p><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><h3 id="文件夹规范"><a href="#文件夹规范" class="headerlink" title="文件夹规范"></a>文件夹规范</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apis / blog / api.ts; <span class="comment">// 存放封装了请求库的api合集</span></span><br><span class="line">apis / blog / query.ts; <span class="comment">// 存放需要tanstack query响应式请求的请求合集</span></span><br><span class="line">apis / blog / <span class="keyword">type</span>.ts; <span class="comment">// 存放api类型声明</span></span><br></pre></td></tr></table></figure><h3 id="API-规范"><a href="#API-规范" class="headerlink" title="API 规范"></a>API 规范</h3><p>在 query 中，我们需要借助 maybeRefOrGetter 和 toValue 实现响应式请求参数的导入和解析</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> blogQuery = &#123;</span><br><span class="line">  <span class="attr">getBlogDetail</span>: <span class="function">(<span class="params">DTO: DTOHelper&lt;<span class="keyword">typeof</span> blogAPI.getBlogDetail&gt;</span>) =&gt;</span></span><br><span class="line">    queryOptions(&#123;</span><br><span class="line">      <span class="attr">queryKey</span>: [<span class="string">&quot;blogQuery&quot;</span>, <span class="string">&quot;getBlogDetail&quot;</span>, DTO],</span><br><span class="line">      <span class="attr">queryFn</span>: <span class="function">() =&gt;</span> blogAPI.getBlogDetail(toValue(DTO)),</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> DTOHelper&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = MaybeRefOrGetter&lt;</span><br><span class="line">  Parameters&lt;T&gt;[<span class="number">0</span>]</span><br><span class="line">&gt;;</span><br></pre></td></tr></table></figure><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>主要了解三个概念：实体(Entity)，DTO，VO<br>参考：<a href="https://www.cnblogs.com/JerryMouseLi/p/11069237.html#vo%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9E%8B-%E4%B8%8E-dto%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB">https://www.cnblogs.com/JerryMouseLi/p/11069237.html#vo%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9E%8B-%E4%B8%8E-dto%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB</a></p><p>命名规范则为</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> BlogEntity &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> GetBlogListVO &#123;</span><br><span class="line">  <span class="attr">lists</span>: BlogEntity[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> GetBlogDetailDTO &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> GetBlogDetailVO <span class="keyword">extends</span> BlogEntity &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="插件-AI-快速生成规范"><a href="#插件-AI-快速生成规范" class="headerlink" title="插件/AI 快速生成规范"></a>插件/AI 快速生成规范</h3><p>借助 Vscode Module Templates 插件 / AI</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="工程化系列" scheme="https://zlinni.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="TanStack Query" scheme="https://zlinni.github.io/tags/TanStack-Query/"/>
    
  </entry>
  
  <entry>
    <title>Mock封装与实操</title>
    <link href="https://zlinni.github.io/posts/3034349472/"/>
    <id>https://zlinni.github.io/posts/3034349472/</id>
    <published>2023-03-11T16:00:00.000Z</published>
    <updated>2023-03-11T15:59:13.273Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>mock</code> 工具的使用以及拓展</p><h1 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h1><p>开启 <code>mock</code> 有两种形式 环境变量和注解</p><h2 id="通过环境变量开启-mock（生产阶段优选）"><a href="#通过环境变量开启-mock（生产阶段优选）" class="headerlink" title="通过环境变量开启 mock（生产阶段优选）"></a>通过环境变量开启 mock（生产阶段优选）</h2><p>这个需要 <code>env</code> 里面是否包含 <code>mock</code> 环境的判断<br>不过一旦构建好就改不了了 <code>mock</code></p><h2 id="通过注解开启-mock（开发阶段优选）"><a href="#通过注解开启-mock（开发阶段优选）" class="headerlink" title="通过注解开启 mock（开发阶段优选）"></a>通过注解开启 mock（开发阶段优选）</h2><p>项目默认开启 <code>mock</code>(<code>main.ts</code> 中注入)<br>不需要的时候直接注释掉即可</p><h2 id="综上的新方法"><a href="#综上的新方法" class="headerlink" title="综上的新方法"></a>综上的新方法</h2><p>开发环境：默认 <code>mock</code> 环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VUE_APP_MODE=mock</span><br><span class="line">VUE_APP_URL=x<span class="string">&#x27;x&#x27;</span>x</span><br><span class="line">VUE_APP_MARK_TEXT=开发环境</span><br></pre></td></tr></table></figure><p>生产环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VUE_APP_MODE=product</span><br><span class="line">VUE_APP_URL=xxxx</span><br><span class="line">VUE_APP_MARK_TEXT=生产环境</span><br></pre></td></tr></table></figure><p><code>main.ts</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过注释动态控制开发环境是否需要mock</span><br><span class="line"><span class="keyword">if</span> (process.env.VUE_APP_MODE === <span class="string">&quot;mock&quot;</span>) &#123;</span><br><span class="line">  // require(<span class="string">&quot;@/mock&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="mock-基本使用"><a href="#mock-基本使用" class="headerlink" title="mock 基本使用"></a>mock 基本使用</h1><p><a href="http://mockjs.com/examples.html">http://mockjs.com/examples.html</a><br>常用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;data|10&#x27;</span>:[],<span class="comment">// 表示十个data</span></span><br><span class="line"><span class="string">&quot;id|+1&quot;</span>: <span class="number">0</span>, <span class="comment">// id从0开始自增1</span></span><br><span class="line"><span class="string">&#x27;rate|0-5&#x27;</span>,<span class="comment">// rate 从0-5范围随机获取</span></span><br><span class="line"><span class="string">&#x27;name|1-100.3&#x27;</span>:<span class="number">1</span> <span class="comment">// 包含三位小数</span></span><br></pre></td></tr></table></figure><h1 id="mock-根据不同的请求参数返回不同的结果"><a href="#mock-根据不同的请求参数返回不同的结果" class="headerlink" title="mock 根据不同的请求参数返回不同的结果"></a>mock 根据不同的请求参数返回不同的结果</h1><p>由于普通的 <code>mock</code> 其实不需要参数，但是 <code>mock</code> 本身也可以接收参数，分为两种情况<br>先讲一下原理 一般 <code>mock</code> 方法是这样写的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mock.mock(url, method, <span class="function">(<span class="params">opts</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>其中 <code>url</code> 是拦截的地址 <code>method</code> 是请求方法 <code>opts</code> 则是一个对象<br>关键在于 <code>opts</code> 它的类型定义如下<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311235123.png" alt=""><br>也就是它会暴露三个参数 一个是拦截 <code>url</code> 一个是请求方法 一个是 <code>body</code><br>如果是 <code>GET</code> 请求 那么请求体则在 <code>opts.url</code> 中，需要单独分割出来，方法在下面看<br>如果是 <code>POST</code> 请求 那么请求体就是在 <code>body</code> 中，也是对象 直接用就好<br>那么基于上面 就可以拿到对应的参数 进行返回</p><h2 id="将-url-中的参数转对象"><a href="#将-url-中的参数转对象" class="headerlink" title="将 url 中的参数转对象"></a>将 url 中的参数转对象</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取url中的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>url url</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span>参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> getUrlSearchToObject = &lt;T&gt;(</span><br><span class="line">  url = <span class="built_in">window</span>.location.search</span><br><span class="line">): Record&lt;keyof T, <span class="built_in">string</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> urlStr = url.split(<span class="string">&quot;?&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> paramsArr = urlStr.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> paramsArr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = cur.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> [key, value] = arr;</span><br><span class="line">    pre[key <span class="keyword">as</span> keyof T] = value;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">  &#125;, &#123;&#125; <span class="keyword">as</span> Record&lt;keyof T, <span class="built_in">string</span>&gt;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="mock-封装"><a href="#mock-封装" class="headerlink" title="mock 封装"></a>mock 封装</h1><p>举个例子<br><code>mock/module/music.ts</code> 用于 <code>mock</code> 一个接口 返回 <code>url</code> <code>type</code> 和一个 <code>cb</code> <code>cb</code> 包含上述的结构体</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> musicMockEntity: Record&lt;</span><br><span class="line">  <span class="built_in">string</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">    cb: <span class="built_in">any</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&gt; = &#123;</span><br><span class="line">  <span class="attr">moduleStatusList</span>: &#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/mock/api/getModuleStatusList&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">cb</span>: <span class="function">(<span class="params">opts: MockjsRequestOptions</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(opts);</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">code</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">          <span class="attr">statusList</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">business_status</span>: <span class="string">&quot;1-1&quot;</span>,</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&quot;投票中&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>mock/index.ts</code> 用于全局定义一个 <code>mock</code> 实例 通过导入模块的方式 去拦截对应的请求并返回 这里的嵌套了一层 <code>Mock.mock</code> 会不太灵活 其实 应该放在上面 <code>cb</code> 返回值 因为有时候 <code>cb</code> <code>return</code> 的东西不一定要经过 <code>Mock.mock</code> 嵌套，有可能直接是一个 <code>json</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock, &#123; MockjsRequestOptions &#125; <span class="keyword">from</span> <span class="string">&quot;mockjs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; musicMockEntity &#125; <span class="keyword">from</span> <span class="string">&quot;./module/music&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> modules = [musicMockEntity];</span><br><span class="line">Mock.setup(&#123;</span><br><span class="line">  <span class="attr">timeout</span>: <span class="string">&quot;200-600&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line">modules.forEach(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(<span class="built_in">module</span>).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; url, type, cb &#125; = <span class="built_in">module</span>[key];</span><br><span class="line">    <span class="comment">// 用正则是因为直接写地址的话 后续的?xxx=就匹配不到</span></span><br><span class="line">    Mock.mock(<span class="keyword">new</span> <span class="built_in">RegExp</span>(url), type, <span class="function">(<span class="params">opts: MockjsRequestOptions</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(opts, <span class="string">&quot;opts&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> Mock.mock(cb(opts));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="在-apifox-中使用-mock"><a href="#在-apifox-中使用-mock" class="headerlink" title="在 apifox 中使用 mock"></a>在 apifox 中使用 mock</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>一般后端出接口文档 出在 <code>apifox</code> 上 所以可以直接使用 <code>apifox</code> 的 <code>mock</code> 然后在项目中导入<br>缺点是它并没有携带拦截功能<br>直接 <code>mock</code></p><ul><li>方式 1 通过生成的 mockjson 直接导入使用<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311235253.png" alt=""></li><li>方式 2 通过 mock 地址来注入<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311235302.png" alt=""><br>更改对应接口的地址 注意 axios 是可以通过 url 覆盖 baseUrl 的<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311235317.png" alt=""><br>日常开发更推荐方式 2 因为方式 2 不需要额外的文件产出，就是 url 丑了点</li></ul><h2 id="通过服务转发-注入-axios-来-mock"><a href="#通过服务转发-注入-axios-来-mock" class="headerlink" title="通过服务转发/注入 axios 来 mock"></a>通过服务转发/注入 axios 来 mock</h2><p>上述方式二带来的方法是 <code>url</code> 覆盖 <code>baseUrl</code> 但是这样做 不好维护 <code>mock</code> 地址<br>注入 <code>axios</code> + 环境(推荐)<br>环境变量文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  baseUrl: process.env.VUE_APP_URL,</span><br><span class="line">  mockUrl: process.env.VUE_APP_MOCK_URL,</span><br><span class="line">  mode: process.env.VUE_APP_MODE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>配置 <code>axios</code> 然后开发的时候可以通过 <code>isMock</code> 参数动态更新（因为 <code>axios</code> 不涉及部署 <code>webpack</code> 是会热更新的）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否开启mock</span></span><br><span class="line"><span class="keyword">const</span> isMock = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">axiosConfig: AxiosRequestConfig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: isMock &amp;&amp; config.mode === <span class="string">&quot;mock&quot;</span> ? config.mockUrl : config.baseUrl, <span class="comment">// env</span></span><br><span class="line">    <span class="comment">// 请看vue.config.js 的devserver.proxy</span></span><br><span class="line">    <span class="comment">// baseURL: &quot;/api&quot;, // env</span></span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">50000</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>上述方式可以达到本地开发和 <code>mock</code> 环境共存，通过修改参数动态注入 <code>mock</code><br>服务转发（不推荐） 因为不能动态更新 除非用插件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = defineConfig(&#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&quot;/mock&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: process.env.VUE_APP_URL, <span class="comment">//转发地址</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 跨域支持</span></span><br><span class="line">        <span class="attr">secure</span>: <span class="literal">false</span>, <span class="comment">//可选 默认对于没证书的https会拦截</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="comment">// 重写路径后的内容</span></span><br><span class="line">          <span class="string">&quot;^/mock&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="高级-mock"><a href="#高级-mock" class="headerlink" title="高级 mock"></a>高级 mock</h2><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>类似于通过入参出参决定数据 前端可以自己 <code>diy</code> 数据<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311235418.png" alt=""><br>注意！ 如果有脚本 会先走脚本 后走期望 如果有期望 则满足条件会走期望</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>期望的高级版本，相当于前端自己写 <code>mock</code> 数据，有一些 <code>apifox</code> 自带的语法<br><a href="https://www.apifox.cn/help/app/mock/mock-custom-scripts/#%E7%A4%BA%E4%BE%8B%E4%BA%8C">https://www.apifox.cn/help/app/mock/mock-custom-scripts/#%E7%A4%BA%E4%BE%8B%E4%BA%8C</a></p><p>结论<br>对比两种工具<br>Apifox（推荐）</p><ul><li>优势：<ul><li>学习成本低，且所有数据都有自带的 <code>mock</code></li><li>基于 <code>mockjs</code> 在工具上直接 <code>mock</code> 在工具上通过期望自定义 <code>mock</code> 在工具上通过脚本自定义 <code>mock</code></li></ul></li><li>劣势：<ul><li>如果需要一些自定义的情况 还是要学习 <code>mockjs</code></li></ul></li><li>如果采用了 <code>Apifox</code> 的 <code>mock</code><ul><li>使用 <code>apifox</code> 的 <code>mock</code> 则 需要开启 <code>apifox</code></li><li>如果通过服务转发/环境的方式 则前端需要区分 <code>mock</code> 环境和开发环境<br>Mockjs</li></ul></li><li>优势：<ul><li>纯 <code>js</code> 纯自己造数据 自由度高一点</li></ul></li><li>劣势：<ul><li>自带的拦截服务有时候会造成 <code>bug</code></li><li>因为文档的原因脱离不开 <code>apifox</code></li></ul></li><li>如果采用 <code>mockjs</code><ul><li><code>mockjs</code> 适合于 只需要部分接口 <code>mock</code> 的情况</li><li>前端的本地开发环境都是 <code>mock</code> 环境了 因为它自带了拦截</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Mock" scheme="https://zlinni.github.io/tags/Mock/"/>
    
  </entry>
  
  <entry>
    <title>记录一次histroy模式的vue项目部署到githubpage</title>
    <link href="https://zlinni.github.io/posts/1946841451/"/>
    <id>https://zlinni.github.io/posts/1946841451/</id>
    <published>2023-03-11T12:19:53.000Z</published>
    <updated>2023-03-11T15:59:13.268Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>history模式部署 需要注意的东西 如下：</p><h1 id="histroy模式加载baseUrl"><a href="#histroy模式加载baseUrl" class="headerlink" title="histroy模式加载baseUrl"></a>histroy模式加载baseUrl</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311202107.png" alt=""></p><h1 id="打包同样-前缀是baseUrl"><a href="#打包同样-前缀是baseUrl" class="headerlink" title="打包同样 前缀是baseUrl"></a>打包同样 前缀是baseUrl</h1><p><code>vue.config.js</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311202138.png" alt=""></p><h1 id="将dist文件夹下的东西提交到gh-pages"><a href="#将dist文件夹下的东西提交到gh-pages" class="headerlink" title="将dist文件夹下的东西提交到gh-pages"></a>将dist文件夹下的东西提交到gh-pages</h1><p>指令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree push --prefix dist origin gh-pages</span><br></pre></td></tr></table></figure><br>效果<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311202213.png" alt=""></p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311202226.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>microapp微前端实践</title>
    <link href="https://zlinni.github.io/posts/96411472/"/>
    <id>https://zlinni.github.io/posts/96411472/</id>
    <published>2023-03-11T12:19:53.000Z</published>
    <updated>2023-03-11T15:59:13.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于 <code>microapp</code> 的微前端实操</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><code>microapp</code> 需要基座项目+若干子项目这里以如下三个项目为例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue create base</span><br><span class="line">vue create first_child</span><br><span class="line">vue create second_child</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311203838.png" alt=""><br>Cd 到基座项目 安装 <code>microapp</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install @micro-zoe/micro-app --save</span><br></pre></td></tr></table></figure><p>在基座中的 <code>main.ts</code> 中引入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> microApp <span class="keyword">from</span> <span class="string">&quot;@micro-zoe/micro-app&quot;</span>;</span><br><span class="line">microApp.start(&#123;</span><br><span class="line">  <span class="comment">// microApp生命周期</span></span><br><span class="line">  <span class="attr">lifeCycles</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;created&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforemount</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;beforemount&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;mounted&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">unmount</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;unmount&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">error</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;error&quot;</span>, e);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">createApp(App).use(router).mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p><code>microapp</code> 支持如下的路由模式<br>基座应用是 <code>hash</code> 的话 子应用必须是 <code>hash</code><br>基座应用是 <code>history</code> 的话 子应用是 <code>history</code> 或者 <code>hash</code></p><p>我这边的配置是基座 <code>histroy</code> 子引用 <code>hash</code><br>所以先改一下基座的配置</p><h2 id="基座-history-模式的配置"><a href="#基座-history-模式的配置" class="headerlink" title="基座 history 模式的配置"></a>基座 history 模式的配置</h2><p><code>router.ts</code>中修改</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  <span class="comment">// history: createWebHashHistory(),</span></span><br><span class="line">  <span class="attr">history</span>: createWebHistory(<span class="string">&quot;/base&quot;</span>),</span><br><span class="line">  routes,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>vue.config.js</code> 中修改</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&quot;/base&quot;</span>, <span class="comment">// 主要是这个配置</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子项目由于 <code>vue</code> 初始化的时候就是默认的 <code>hash</code> 所以就不改了</p><h2 id="基座路由配置"><a href="#基座路由配置" class="headerlink" title="基座路由配置"></a>基座路由配置</h2><p><code>router.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  createRouter,</span><br><span class="line">  <span class="comment">// createWebHashHistory,</span></span><br><span class="line">  createWebHistory,</span><br><span class="line">  RouteRecordRaw,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> HomeView <span class="keyword">from</span> <span class="string">&quot;../views/HomeView.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: <span class="built_in">Array</span>&lt;RouteRecordRaw&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: HomeView,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/micro-app1/*&quot;</span>, <span class="comment">// 这里对应着micro的组件中的baseroute</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;child1&quot;</span>, <span class="comment">// 这里对应着micro组件中的name</span></span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/app_first.vue&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/micro-app2/*&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;child2&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/app_second.vue&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  <span class="comment">// history: createWebHashHistory(),</span></span><br><span class="line">  <span class="attr">history</span>: createWebHistory(<span class="string">&quot;/base&quot;</span>),</span><br><span class="line">  routes,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><p>创建子项目 <code>vue app_first.vue</code> 保证 <code>name</code> 和 <code>baseroute</code> 对应 且其中的 <code>url</code> 是子项目启动地址<br>（由于基座是 <code>history</code> 子项目是 <code>hash</code> 所以组件不需要设置 <code>baseroute）</code><br><code>url</code> 属性 <code>html</code> 地址 作用是加载 <code>html</code> 资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;micro-app name=&quot;child1&quot; url=&quot;http://localhost:1111/&quot;&gt;&lt;/micro-app&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>app_second.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;micro-app name=&quot;child2&quot; url=&quot;http://localhost:1112/&quot;&gt;&lt;/micro-app&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="基座-app-vue"><a href="#基座-app-vue" class="headerlink" title="基座 app.vue"></a>基座 app.vue</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">app_first</span>&gt;</span><span class="tag">&lt;/<span class="name">app_first</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app_second&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">app_second</span>&gt;</span><span class="tag">&lt;/<span class="name">app_second</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> app_first <span class="keyword">from</span> <span class="string">&quot;@/views/app_first.vue&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> app_second <span class="keyword">from</span> <span class="string">&quot;@/views/app_second.vue&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;scss&quot;</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-id">#app</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">font-family</span>: Avenir, Helvetica, Arial, sans-serif;</span></span></span><br><span class="line"><span class="css"><span class="xml">  -webkit-<span class="attribute">font-smoothing</span>: antialiased;</span></span></span><br><span class="line"><span class="css"><span class="xml">  -moz-osx-<span class="attribute">font-smoothing</span>: grayscale;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">text-align</span>: center;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-tag">nav</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">padding</span>: <span class="number">30px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="selector-tag">a</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">    <span class="attribute">font-weight</span>: bold;</span></span></span><br><span class="line"><span class="css"><span class="xml">    <span class="attribute">color</span>: <span class="number">#2c3e50</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span></span></span><br><span class="line"><span class="css"><span class="xml">    &amp;<span class="selector-class">.router-link-exact-active</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">      <span class="attribute">color</span>: <span class="number">#42b983</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="selector-class">.app_second</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">width</span>: <span class="number">100px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="attribute">height</span>: <span class="number">400px</span>;</span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="子项目配置"><a href="#子项目配置" class="headerlink" title="子项目配置"></a>子项目配置</h1><h2 id="配置跨域-和-port"><a href="#配置跨域-和-port" class="headerlink" title="配置跨域 和 port"></a>配置跨域 和 port</h2><p>子项目 1 端口是 1111 子项目 2 端口我写了 1112</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// publicPath: &quot;/micro-app1&quot;,</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">1111</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="app-vue"><a href="#app-vue" class="headerlink" title="app.vue"></a>app.vue</h2><p>子项目随便在 <code>app.vue</code> 中写点东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;nav&gt;这个是第一个app&lt;/nav&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: Avenir, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nav &#123;</span><br><span class="line">  padding: 30px;</span><br><span class="line"></span><br><span class="line">  a &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    color: #2c3e50;</span><br><span class="line"></span><br><span class="line">    &amp;.router-link-exact-active &#123;</span><br><span class="line">      color: #42b983;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>第二个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;nav&gt;这个是第二个app&lt;/nav&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: Avenir, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nav &#123;</span><br><span class="line">  padding: 30px;</span><br><span class="line"></span><br><span class="line">  a &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    color: #2c3e50;</span><br><span class="line"></span><br><span class="line">    &amp;.router-link-exact-active &#123;</span><br><span class="line">      color: #42b983;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>如果不是模块空间的话，就手动启动三个项目吧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm run serve</span><br></pre></td></tr></table></figure><p>出现的界面如下 则成功<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311204446.png" alt=""></p><h1 id="应用间跳转"><a href="#应用间跳转" class="headerlink" title="应用间跳转"></a>应用间跳转</h1><h2 id="基座控制子应用跳转"><a href="#基座控制子应用跳转" class="headerlink" title="基座控制子应用跳转"></a>基座控制子应用跳转</h2><p>原理是<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311204511.png" alt=""></p><p>注意事项：如果两个子应用的 <code>path</code> 是一样的 虽然 <code>setdata</code> 会触发相应的页面跳转，但是直接在网址上跳转的话两个子应用都会被触发</p><h3 id="子项目-1-配置"><a href="#子项目-1-配置" class="headerlink" title="子项目 1 配置"></a>子项目 1 配置</h3><p>App.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;这个是第一个app&lt;/div&gt;</span><br><span class="line">  &lt;RouterView&gt;&lt;/RouterView&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; useRouter &#125; from &quot;vue-router&quot;;</span><br><span class="line"></span><br><span class="line">const router = useRouter();</span><br><span class="line">// 监听基座下发的数据变化</span><br><span class="line">if (window?.microApp?.addDataListener) &#123;</span><br><span class="line">  window.microApp.addDataListener((data: any) =&gt; &#123;</span><br><span class="line">    console.log(data.path, &quot;datapath&quot;);</span><br><span class="line">    // 当基座下发跳转指令时进行跳转</span><br><span class="line">    if (data.path) &#123;</span><br><span class="line">      router.push(data.path);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子项目 1 的测试跳转页面为自带的 <code>about</code> 页<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311204607.png" alt=""></p><h3 id="子项目-2-配置"><a href="#子项目-2-配置" class="headerlink" title="子项目 2 配置"></a>子项目 2 配置</h3><p><code>App.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;这个是第二个app&lt;/div&gt;</span><br><span class="line">  &lt;RouterView&gt;&lt;/RouterView&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; useRouter &#125; from &quot;vue-router&quot;;</span><br><span class="line"></span><br><span class="line">const router = useRouter();</span><br><span class="line">// 监听基座下发的数据变化</span><br><span class="line">if (window?.microApp?.addDataListener) &#123;</span><br><span class="line">  window.microApp.addDataListener((data: any) =&gt; &#123;</span><br><span class="line">    console.log(data.path, &quot;datapath&quot;);</span><br><span class="line">    // 当基座下发跳转指令时进行跳转</span><br><span class="line">    if (data.path) &#123;</span><br><span class="line">      router.push(data.path);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子项目 2 的测试跳转页面同样为自带的 <code>about</code> 页 但是 <code>path</code> 要写不一样<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311204644.png" alt=""></p><h3 id="主项目-base-配置"><a href="#主项目-base-配置" class="headerlink" title="主项目 base 配置"></a>主项目 base 配置</h3><p><code>App.vue</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;app_first&gt;&lt;/app_first&gt;</span><br><span class="line">    &lt;div class=&quot;app_second&quot;&gt;</span><br><span class="line">      &lt;app_second&gt;&lt;/app_second&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;routeToProject(&#x27;child1&#x27;)&quot;&gt;跳转项目1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;routeToProject(&#x27;child2&#x27;)&quot;&gt;跳转项目2&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import microApp from &quot;@micro-zoe/micro-app&quot;;</span><br><span class="line">import app_first from &quot;@/views/app_first.vue&quot;;</span><br><span class="line">import app_second from &quot;@/views/app_second.vue&quot;;</span><br><span class="line">type routerType = &quot;child1&quot; | &quot;child2&quot;;</span><br><span class="line">const routeToProject = (type: routerType) =&gt; &#123;</span><br><span class="line">  console.log(type, &quot;type&quot;);</span><br><span class="line">  const typeMapper = &#123;</span><br><span class="line">    child1: &quot;/about/&quot;,</span><br><span class="line">    child2: &quot;/about2/&quot;,</span><br><span class="line">  &#125;;</span><br><span class="line">  microApp.setData(type, &#123; path: typeMapper[type] &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">#app &#123;</span><br><span class="line">  font-family: Avenir, Helvetica, Arial, sans-serif;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: #2c3e50;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nav &#123;</span><br><span class="line">  padding: 30px;</span><br><span class="line"></span><br><span class="line">  a &#123;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">    color: #2c3e50;</span><br><span class="line"></span><br><span class="line">    &amp;.router-link-exact-active &#123;</span><br><span class="line">      color: #42b983;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">.app_second &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 400px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311204744.png" alt=""></p><p>跳转项目 1<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311204754.png" alt=""><br>跳转项目 2<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311204832.png" alt=""><br>注意：我们发现跳转的时候 <code>url</code> 变了，但是跳转的过程中并没有重置之前项目 1 的状态，也就是项目 1 的状态仍然被保留了下来<br>我们试着刷新页面<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311204848.png" alt=""><br>发现此时子项目 1 的状态才被重置。<br>解决方法也很简单 给 <code>routerToProject</code> 方法提供一个还原其他页面状态的操作就 ok 了 这里就不写了</p><h2 id="子应用控制基座跳转"><a href="#子应用控制基座跳转" class="headerlink" title="子应用控制基座跳转"></a>子应用控制基座跳转</h2><p>如果有基座控制子应用跳转 那么自然有子应用控制基座跳转<br>原理是利用了回调函数的写法 给子项目传递一个回调函数去触发<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311213847.png" alt=""></p><h3 id="bug-探讨"><a href="#bug-探讨" class="headerlink" title="bug 探讨"></a>bug 探讨</h3><p>在使用了上述方法 流程是 <code>base</code> 项目触发跳转子项目 1，子项目 1 提供按钮回退到 <code>base</code> 项目<br>此时拿不到 <code>pushState</code> 或者说是 <code>window.mircoApp.getData</code> 的数据被刷新了<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311213905.png" alt=""><br>但是初始化的时候是存在这个内容的<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311213915.png" alt=""><br>所以我们得通过监听下发通知的方式去触发跳转，或者直接通过状态管理去存储初次的状态 后续就直接调用<br><code>pinia</code> 代码 <code>/store/useMicro.ts</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useMicro = defineStore(<span class="string">&quot;useMicro&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> microData = ref&lt;<span class="built_in">any</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    microData,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>子项目 1 的 <code>App.vue</code> 此时就收集到了基座项目的 <code>pushState</code> 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;这个是第一个app&lt;/div&gt;</span><br><span class="line">  &lt;RouterView&gt;&lt;/RouterView&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import &#123; useRouter &#125; from &quot;vue-router&quot;;</span><br><span class="line">import &#123; useMicro &#125; from &quot;@/store/useMicro&quot;;</span><br><span class="line">import &#123; storeToRefs &#125; from &quot;pinia&quot;;</span><br><span class="line">const &#123; microData &#125; = storeToRefs(useMicro());</span><br><span class="line">const router = useRouter();</span><br><span class="line">// 监听基座下发的数据变化</span><br><span class="line">if (window?.microApp?.addDataListener) &#123;</span><br><span class="line">  window.microApp.addDataListener((data: any) =&gt; &#123;</span><br><span class="line">    console.log(data.path, &quot;datapath&quot;);</span><br><span class="line">    // 当基座下发跳转指令时进行跳转</span><br><span class="line">    if (data.path) &#123;</span><br><span class="line">      router.push(data.path);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  microData.value = window.microApp.getData();</span><br><span class="line">  console.log(microData.value, &quot;window.microApp.getData()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>对应页面回调出去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;about&quot;&gt;</span><br><span class="line">    &lt;h1&gt;This is an about page child1&lt;/h1&gt;</span><br><span class="line">    &lt;button @click=&quot;routeToBaseProject&quot;&gt;基座跳转回首页&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">// import &#123; nextTick &#125; from &quot;vue&quot;;</span><br><span class="line">import &#123; useMicro &#125; from &quot;@/store/useMicro&quot;;</span><br><span class="line">import &#123; storeToRefs &#125; from &quot;pinia&quot;;</span><br><span class="line">const &#123; microData &#125; = storeToRefs(useMicro());</span><br><span class="line">const routeToBaseProject = () =&gt; &#123;</span><br><span class="line">  // nextTick(() =&gt; &#123;</span><br><span class="line">  if (window?.microApp?.getData) &#123;</span><br><span class="line">    console.log(window.microApp.getData(), &quot;window.microApp&quot;);</span><br><span class="line">    // window.microApp.getData().pushState(&quot;/&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(microData.value, &quot;microData.value&quot;);</span><br><span class="line">  microData.value.pushState(&quot;/baseTest&quot;);</span><br><span class="line">  // &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="多项目启动"><a href="#多项目启动" class="headerlink" title="多项目启动"></a>多项目启动</h1><p>一般来说 <code>npm</code> 不支持平行启动多个项目，参考了 <code>microapp</code> 仓库，他的 <code>packagejson</code> 里面有如下的东西<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311232951.png" alt=""><br>将子项目和主项目分开 然后通过一个 <code>run-all</code> 的命令去全部执行<br>于是找到了对应的 <code>npm</code> 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnpm install npm-run-all --save-dev</span><br></pre></td></tr></table></figure><p>从项目根目录下初始化一个 <code>packagejson</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311233029.png" alt=""></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line"><span class="string">&quot;dev-child:child1&quot;</span>: <span class="string">&quot;cd first_child &amp;&amp; pnpm run serve&quot;</span>,</span><br><span class="line"><span class="string">&quot;dev-child:child2&quot;</span>: <span class="string">&quot;cd second_child &amp;&amp; pnpm run serve&quot;</span>,</span><br><span class="line"><span class="string">&quot;dev-main:base&quot;</span>: <span class="string">&quot;cd base &amp;&amp; pnpm run serve&quot;</span>,</span><br><span class="line"><span class="string">&quot;dev-main&quot;</span>: <span class="string">&quot;npm-run-all --parallel dev-main:base dev-child:_&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>结果：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311233056.png" alt=""></p><h1 id="多项目打包"><a href="#多项目打包" class="headerlink" title="多项目打包"></a>多项目打包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;build-main:base&quot;</span>:<span class="string">&quot;cd base &amp;&amp; pnpm run build&quot;</span>,</span><br><span class="line"><span class="string">&quot;build-child:child1&quot;</span>:<span class="string">&quot;cd first_child &amp;&amp; pnpm run build&quot;</span>,</span><br><span class="line"><span class="string">&quot;build-child:child2&quot;</span>:<span class="string">&quot;cd second_child &amp;&amp; pnpm run build&quot;</span>,</span><br><span class="line"><span class="string">&quot;build-main&quot;</span>:<span class="string">&quot;npm-run-all --parallel build-main:base build-child:_&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="部署项目-本地-docker"><a href="#部署项目-本地-docker" class="headerlink" title="部署项目(本地 docker"></a>部署项目(本地 docker</h1><p>先修改之前 <code>base</code> 项目的 <code>router</code>，因为这样方便我们后续操作，将原来叫 <code>micro_app1</code> 和 2 的路径分别改为子项目的名字</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  createRouter,</span><br><span class="line">  <span class="comment">// createWebHashHistory,</span></span><br><span class="line">  createWebHistory,</span><br><span class="line">  RouteRecordRaw,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> HomeView <span class="keyword">from</span> <span class="string">&quot;../views/HomeView.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: <span class="built_in">Array</span>&lt;RouteRecordRaw&gt; = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: HomeView,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/baseTest&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;baseTest&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/AboutView.vue&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/first_child/*&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;child1&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/app_first.vue&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/second_child/*&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;child2&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/app_second.vue&quot;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  <span class="comment">// history: createWebHashHistory(),</span></span><br><span class="line">  <span class="attr">history</span>: createWebHistory(<span class="string">&quot;/base&quot;</span>),</span><br><span class="line">  routes,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><h2 id="Output-dir-配置打包路径（可以不写，参见-Dockerfile）"><a href="#Output-dir-配置打包路径（可以不写，参见-Dockerfile）" class="headerlink" title="Output dir 配置打包路径（可以不写，参见 Dockerfile）"></a>Output dir 配置打包路径（可以不写，参见 Dockerfile）</h2><p>我们继续编写各个 <code>vueconfigjs</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base 项目</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">publicPath</span>: <span class="string">&quot;/base&quot;</span>,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&quot;_&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">outputDir</span>: <span class="string">&quot;base&quot;</span>,</span><br><span class="line">  <span class="comment">// vue.config.js</span></span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">&quot;vue&quot;</span>)</span><br><span class="line">      .use(<span class="string">&quot;vue-loader&quot;</span>)</span><br><span class="line">      .tap(<span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">        options.compilerOptions = &#123;</span><br><span class="line">          ...(options.compilerOptions || &#123;&#125;),</span><br><span class="line">          <span class="attr">isCustomElement</span>: <span class="function">(<span class="params">tag</span>) =&gt;</span> <span class="regexp">/^micro-app/</span>.test(tag),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> options;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// first_child 项目</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// publicPath: &quot;/micro-app1&quot;,</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">1111</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&quot;_&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">outputDir</span>: <span class="string">&quot;first_child&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// second_child 项目</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// publicPath: &quot;/micro-app2&quot;,</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">1112</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">outputDir</span>: <span class="string">&quot;second_child&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="编写-default-conf"><a href="#编写-default-conf" class="headerlink" title="编写 default.conf"></a>编写 default.conf</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name localhost;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">root /usr/share/nginx/html;</span><br><span class="line">index index.php index.html index.htm; # add_header Cache-Control;</span><br><span class="line">add_header Access-Control-Allow-Origin _;</span><br><span class="line">if ( $request_uri ~_ ^.+.(js|css|jpg|png|gif|tif|dpg|jpeg|eot|svg|ttf|woff|json|mp4|rmvb|rm|wmv|avi|3gp)$ )&#123;</span><br><span class="line">add_header Cache-Control max-age=7776000;</span><br><span class="line">add_header Access-Control-Allow-Origin \*;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 主应用 base</span><br><span class="line"></span><br><span class="line">location /base &#123;</span><br><span class="line">root /usr/share/nginx/html;</span><br><span class="line">add_header Access-Control-Allow-Origin _;</span><br><span class="line">if ( $request_uri ~_ ^.+.(js|css|jpg|png|gif|tif|dpg|jpeg|eot|svg|ttf|woff|json|mp4|rmvb|rm|wmv|avi|3gp)$ )&#123;</span><br><span class="line">add_header Cache-Control max-age=7776000;</span><br><span class="line">add_header Access-Control-Allow-Origin \*;</span><br><span class="line">&#125;</span><br><span class="line">try_files $uri $uri/ /base/index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 子应用 first_child</span><br><span class="line"></span><br><span class="line">location /first_child &#123;</span><br><span class="line">root /usr/share/nginx/html;</span><br><span class="line">add_header Access-Control-Allow-Origin _;</span><br><span class="line">if ( $request_uri ~_ ^.+.(js|css|jpg|png|gif|tif|dpg|jpeg|eot|svg|ttf|woff|json|mp4|rmvb|rm|wmv|avi|3gp)$ )&#123;</span><br><span class="line">add_header Cache-Control max-age=7776000;</span><br><span class="line">add_header Access-Control-Allow-Origin \*;</span><br><span class="line">&#125;</span><br><span class="line">try_files $uri $uri/ /first_child/index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 子应用 second_child</span><br><span class="line"></span><br><span class="line">location /second_child &#123;</span><br><span class="line">root /usr/share/nginx/html;</span><br><span class="line">add_header Access-Control-Allow-Origin _;</span><br><span class="line">if ( $request_uri ~_ ^.+.(js|css|jpg|png|gif|tif|dpg|jpeg|eot|svg|ttf|woff|json|mp4|rmvb|rm|wmv|avi|3gp)$ )&#123;</span><br><span class="line">add_header Cache-Control max-age=7776000;</span><br><span class="line">add_header Access-Control-Allow-Origin \*;</span><br><span class="line">&#125;</span><br><span class="line">try_files $uri $uri/ /second_child/index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_page 404 /404.html;</span><br><span class="line">location = /40x.html &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_page 500 502 503 504 /50x.html;</span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>注意在 <code>window</code> 下 <code>mkdir</code> 会产生一个额外的目录 不过问题不大</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/share/nginx/html/&#123;base,first_child,second_child&#125;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> /base/base/ /usr/share/nginx/html/base</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> /first_child/first_child/ /usr/share/nginx/html/first_child</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> /second_child/second_child/ /usr/share/nginx/html/second_child</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> default.conf /etc/nginx/conf.d/default.conf</span></span><br></pre></td></tr></table></figure><p>如果在上述 <code>outputdir</code> 里面没有编写打包名称的话 问题也不大 道理是一样的 可以这样写</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/share/nginx/html/&#123;base,first_child,second_child&#125;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> /base/dist/ /usr/share/nginx/html/base</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> /first_child/dist/ /usr/share/nginx/html/first_child</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> /second_child/dist/ /usr/share/nginx/html/second_child</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> default.conf /etc/nginx/conf.d/default.conf</span></span><br></pre></td></tr></table></figure><h2 id="运行-docker"><a href="#运行-docker" class="headerlink" title="运行 docker"></a>运行 docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx//拉 nginx</span><br><span class="line">docker images// 查看镜像</span><br><span class="line">docker build -t docker_micro_app . --no-cache//构建镜像 记得加.</span><br><span class="line">dokcer run -d -p 5555:80 --name micro_app docker_micro_app // 运行容器</span><br><span class="line">docker <span class="built_in">exec</span> -it 容器 id bash // 进入容器</span><br><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html // 进入 nginx 内部的 html</span><br><span class="line">ls //查看所有文件 如下图 说明已经有对应的文件了</span><br><span class="line"><span class="built_in">exit</span> //退出</span><br><span class="line">// 如果不对 请删除镜像再操作</span><br><span class="line">docker rm -f xxxID</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230311233444.png" alt=""></p><p>在地址栏查看 <code>localhost:5555/base</code> 如果有内容则成功</p><h2 id="运行到本地-ip"><a href="#运行到本地-ip" class="headerlink" title="运行到本地 ip"></a>运行到本地 ip</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dokcer run -d -p 你的 ip:5555:80 --name micro_app docker_micro_app // 运行镜像</span><br></pre></td></tr></table></figure><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="基座应用警报"><a href="#基座应用警报" class="headerlink" title="基座应用警报"></a>基座应用警报</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue3: [Vue warn]: Failed to resolve component: micro-app</span><br></pre></td></tr></table></figure><p>解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">&quot;vue&quot;</span>)</span><br><span class="line">      .use(<span class="string">&quot;vue-loader&quot;</span>)</span><br><span class="line">      .tap(<span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">        options.compilerOptions = &#123;</span><br><span class="line">          ...(options.compilerOptions || &#123;&#125;),</span><br><span class="line">          <span class="attr">isCustomElement</span>: <span class="function">(<span class="params">tag</span>) =&gt;</span> <span class="regexp">/^micro-app/</span>.test(tag),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> options;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="microapp" scheme="https://zlinni.github.io/tags/microapp/"/>
    
  </entry>
  
  <entry>
    <title>利用h函数编写组件</title>
    <link href="https://zlinni.github.io/posts/1435485109/"/>
    <id>https://zlinni.github.io/posts/1435485109/</id>
    <published>2023-02-09T15:23:14.000Z</published>
    <updated>2023-02-09T15:37:32.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>h 函数 <code>hyperscript</code> （生成 script）用于生成对应的标签<br>其实所有的 <code>vue</code> 组件都是经过一次 <code>render</code> 之后转化成 h 函数，然后再去对应的渲染 <code>dom</code> 的。那么使用 h 函数渲染组件有什么优势呢？</p><h1 id="sfc-结构"><a href="#sfc-结构" class="headerlink" title="sfc 结构"></a>sfc 结构</h1><p><code>vue</code> 是使用了一段叫做 <code>sfc</code> 的结构，类似于一开始学习前端的时候 <code>body script style</code>，现在 <code>vue</code> 是 <code>template script style</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;example&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;Hello world!&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.example &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;custom1&gt;</span><br><span class="line">  This could be e.g. documentation for the component.</span><br><span class="line">&lt;/custom1&gt;</span><br></pre></td></tr></table></figure><p>而在 <code>template</code> 结构种的 <code>html</code> 代码 最后会被转化为 <code>h</code> 函数，如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;example&quot;</span> &#125;, msg);</span><br></pre></td></tr></table></figure><p><code>Vue</code> 通过这个 <code>h</code> 函数去真实的渲染 <code>dom</code>，和虚拟节点的 <code>diff</code> 对比等</p><h1 id="如何编写-h-函数"><a href="#如何编写-h-函数" class="headerlink" title="如何编写 h 函数"></a>如何编写 h 函数</h1><p><code>h</code> 函数接收的参数是根据使用者传入的参数决定的，下面只介绍重要的几个部分（有十九种，一般不可能都使用上）<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230209232459.png" alt=""></p><ul><li>参数一 <code>type</code>： 可以写一个标签或者 <code>component</code> 例如</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h(<span class="string">&quot;div&quot;</span>, <span class="string">&quot;this is a div tag&quot;</span>);</span><br><span class="line">h(YourComponent, <span class="string">&quot;do sth.&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>可选参数二 <code>props</code>： 用于给标签或者 <code>component</code> 传递 <code>props</code>,一般是对象形式 可以结合 tw 等 css 使用,可以写事件监听器,注意使用 <code>on</code> 前缀</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;h-full w-full text-[grey]&quot;</span> &#125;);</span><br><span class="line">h(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">onClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hahahhaha&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>可选参数三 <code>children</code>：字符串|number|对象类型 用于渲染子节点 注意子节点也可以是 h 函数生成的节点，可以模拟 <code>v-if</code> 的操作</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h(<span class="string">&quot;div&quot;</span>, <span class="string">&quot;this is a div tag&quot;</span>);</span><br><span class="line">h(<span class="string">&quot;div&quot;</span>, [h(<span class="string">&quot;div&quot;</span>, <span class="string">&quot;hahahah&quot;</span>), h(<span class="string">&quot;span&quot;</span>, <span class="string">&quot;???&quot;</span>)]);</span><br><span class="line"><span class="keyword">const</span> isShow = ref&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">false</span>);</span><br><span class="line">h(<span class="string">&quot;div&quot;</span>, isShow ? h(<span class="string">&quot;div&quot;</span>, <span class="string">&quot;show&quot;</span>) : <span class="string">&quot;noShow&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>一开始编写 <code>h</code> 函数的时候，传递了 <code>type</code> 之后 默认是以下可以直接传递 <code>children</code> 的类型，也就是 <code>h</code> 函数的后续参数是根据用于用户传递的值的类型去判断的<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230209232604.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230209232610.png" alt=""><br>这也就是为什么 <code>prop</code> 是对象类型 而 <code>children</code> 是 <code>string | number | array</code> 类型了 因为方便判断</p><h1 id="在-ts-js-中编写-component"><a href="#在-ts-js-中编写-component" class="headerlink" title="在 ts/js 中编写 component"></a>在 ts/js 中编写 component</h1><p>其实很早之前就有一个疑问，就是 <code>component</code> 是否可以直接在 <code>javascript</code> 文件里面编写，因为有点时候，只是一点点的内容，其实完全不需要写成一个 <code>vue</code> 文件，需求例如：<br>在表格上面的某一项，默认显示对应的文本，当点击的时候渲染一个 <code>input</code> 框<br>然后 <code>blur</code> 或者 <code>change</code> 事件触发的时候 去调用后台接口改变该项的值<br>如果写成一个 <code>vue</code> 文件 大致上长这样（可能会写错 但大致是这样的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input v-if=&#x27;props.text&#x27; onChange=&#x27;xxx&#x27; onBlur=&#x27;xxx&#x27;&gt;&#123;&#123;props.text&#125;&#125;&lt;/input&gt;</span><br><span class="line">    &lt;div v-else&gt;&#123;&#123;props.text&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export</span><br><span class="line">    xxx...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>实际上 做的功能很少 但写起来总感觉 没有必要装成一个 <code>vue</code> 文件 因为最后都是渲染成 <code>h</code> 函数 那为什么不直接写 <code>h</code> 函数呢？</p><h1 id="defineComponent-渲染组件-渲染一个带状态的-h-函数"><a href="#defineComponent-渲染组件-渲染一个带状态的-h-函数" class="headerlink" title="defineComponent = 渲染组件 = 渲染一个带状态的 h 函数"></a>defineComponent = 渲染组件 = 渲染一个带状态的 h 函数</h1><p>我们利用 <code>defineComponent</code> 这个函数 对应渲染组件<br>其中他有一个状态 <code>props</code> 和 原来的 <code>props</code> 是一样的<br>还有一个 <code>setup</code> 函数 也是一样的 接收 <code>props</code> 然后返回一个虚拟节点 也就是我们 <code>html</code> 上的内容<br>这样有了 <code>setup</code> 函数 我们就有了状态的编写 就大于单独编写 <code>h</code> 函数的作用了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> editableInputComponent = defineComponent(&#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">val</span>: <span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">onUpdateValue</span>: <span class="built_in">Function</span> <span class="keyword">as</span> PropType&lt;<span class="function">(<span class="params">v: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isEdit = ref&lt;<span class="built_in">boolean</span>&gt;(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> inputRef = ref&lt;<span class="built_in">any</span>&gt;(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">const</span> inputValue = ref(props.val || <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleOnClick</span>(<span class="params">e: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">      e.stopPropagation();</span><br><span class="line">      isEdit.value = <span class="literal">true</span>;</span><br><span class="line">      nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// inputRef.value &amp;&amp; inputRef.value?.focus();</span></span><br><span class="line">        inputRef.value?.focus();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      props.onUpdateValue &amp;&amp; props.onUpdateValue(inputValue.value);</span><br><span class="line">      isEdit.value = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> h(</span><br><span class="line">        <span class="string">&quot;div&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">class</span>: <span class="string">&quot;text-[#0256FF] h-[22.39px]&quot;</span>,</span><br><span class="line">          <span class="comment">// style: &quot;min-height: 22px&quot;,</span></span><br><span class="line">          <span class="attr">onClick</span>: handleOnClick,</span><br><span class="line">        &#125;,</span><br><span class="line">        isEdit.value</span><br><span class="line">          ? h(NInput, &#123;</span><br><span class="line">              <span class="attr">ref</span>: inputRef,</span><br><span class="line">              <span class="attr">value</span>: inputValue.value,</span><br><span class="line">              <span class="attr">class</span>: <span class="string">&quot;h-full&quot;</span>,</span><br><span class="line">              <span class="attr">onUpdateValue</span>: <span class="function">(<span class="params">v: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">                inputValue.value = v;</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">onChange</span>: handleChange,</span><br><span class="line">              <span class="attr">onBlur</span>: handleChange,</span><br><span class="line">            &#125;)</span><br><span class="line">          : h(NEllipsis, <span class="literal">null</span>, &#123;</span><br><span class="line">              <span class="attr">default</span>: <span class="function">() =&gt;</span> props.val,</span><br><span class="line">            &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结论就是 <code>defineComponent</code> 就是渲染组件 也就是执行一个带了自我状态的 <code>h</code> 函数<br><code>defineComponent</code> = 渲染组件 = 渲染一个带状态的 <code>h</code> 函数</p><h1 id="PropType"><a href="#PropType" class="headerlink" title="PropType"></a>PropType</h1><p>有个小细节 因为 <code>defineComponent</code> 的 <code>props</code> 不能很明确的定义 接收到的数据类型<br>所以使用了 <code>PropType</code> 去拓展他的类型 例如下面把 <code>Function</code> 拓展成接收一个参数类型为 <code>string</code>，返回值为空的函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">   <span class="attr">val</span>: <span class="built_in">String</span>,</span><br><span class="line">   <span class="attr">onUpdateValue</span>: <span class="built_in">Function</span> <span class="keyword">as</span> PropType&lt;<span class="function">(<span class="params">v: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>但需要注意的是是 如果多类型定义 是不能使用 <code>PropType</code> 的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">   <span class="attr">val</span>: [<span class="built_in">String</span>,<span class="built_in">Array</span> <span class="keyword">as</span> PropType&lt;<span class="built_in">string</span>[]&gt;],<span class="comment">//x 错误的</span></span><br><span class="line">   <span class="attr">onUpdateValue</span>: <span class="built_in">Function</span> <span class="keyword">as</span> PropType&lt;<span class="function">(<span class="params">v: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>建议改为</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> selectVal = <span class="built_in">string</span> | <span class="built_in">string</span>[]</span><br><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">   <span class="attr">val</span>: <span class="built_in">Object</span> <span class="keyword">as</span> PropType&lt;selectVal&gt;,</span><br><span class="line">   onUpdateValue: <span class="built_in">Function</span> <span class="keyword">as</span> PropType&lt;<span class="function">(<span class="params">v: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>或者直接使用</p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>关于 <code>h</code> 函数 实操的过程中还是会遇到不知道怎么写的情况，比如不知道怎么写自定义指令，不知道怎么写 <code>v-model</code> 等<br>可以参考这篇文章：<a href="https://www.lanmper.cn/vue/t9645">https://www.lanmper.cn/vue/t9645</a></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>要用 <code>h</code> 函数封装组件还是直接写组件去封装 各有利弊 <code>h</code> 函数需要更多的学习成本，如果组件库支持 <code>render</code> 函数编写肯定是更高的，比如 <code>Naive</code> 组件库，优势就是完全函数式编程，适用于不太需要 <code>css</code> 和 <code>html</code> 的情况。封装 <code>vue</code> 组件的话，就是能够更方便的编写 <code>html</code> 和 <code>css</code>，缺点就是可能会很冗余。<br>主要记住一句话：高粒度的封装无法适应低粒度的变化。谨慎封装！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue系列" scheme="https://zlinni.github.io/categories/Vue%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vue" scheme="https://zlinni.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记</title>
    <link href="https://zlinni.github.io/posts/394001834/"/>
    <id>https://zlinni.github.io/posts/394001834/</id>
    <published>2023-01-19T06:07:33.000Z</published>
    <updated>2023-01-19T06:25:07.608Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>Nginx 项目运行和打包</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装一个 windows 的 docker 略</p><h1 id="查看-docker"><a href="#查看-docker" class="headerlink" title="查看 docker"></a>查看 docker</h1><p>Cmd<br><code>docker version</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119141035.png" alt=""><br>使用 docker 启动一个项目<br>新建项目<br><code>npm init vue@latest</code><br>然后一路回车 给他起名字叫<code>docker-demo-vue</code><br>之后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> docker-demo-vue</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>就可以看见项目被运行起来了<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119141109.png" alt=""><br>运行起来后给项目打包<br><code>npm run build</code></p><h1 id="创建-Dockerfile"><a href="#创建-Dockerfile" class="headerlink" title="创建 Dockerfile"></a>创建 Dockerfile</h1><p>然后在项目根目录创建 Dockerfile<br>注意大小写 一定不能错 而且文件没有后缀<br>里面的内容后面配置镜像的时候会讲到</p><h1 id="拉取-nginx-镜像"><a href="#拉取-nginx-镜像" class="headerlink" title="拉取 nginx 镜像"></a>拉取 nginx 镜像</h1><p>之后拉取 nginx 镜像<br><code>win+r cmd</code> 打开控制台 输入<br><code>docker pull nginx</code><br>此时会有两种情况</p><ul><li>如果没有拉取过 <code>nginx</code> 后面会有条 <code>Status</code> 是 <code>Downloaded newer image for nginx:lastest</code></li><li>如果之前接触过拉过 则显示 <code>image is up to date for nginx:lastest</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119141200.png" alt=""></li></ul><h1 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h1><p>docker images<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119141400.png" alt=""><br>此时我们找到了 <code>nginx</code> 的镜像 142mb<br>创建 <code>nginx</code> 配置文件<br>项目根目录新建 <code>default.conf</code><br>先不管意思 继续下面的步骤</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/host.access.log  main;</span><br><span class="line">    <span class="attribute">error_log</span>  /var/log/nginx/error.log  <span class="literal">error</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置镜像"><a href="#配置镜像" class="headerlink" title="配置镜像"></a>配置镜像</h1><p>打开我们刚刚的 <code>Dockerfile</code> 写入</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"> <span class="keyword">COPY</span><span class="bash"> dist/ /usr/share/nginx/html/</span></span><br><span class="line"> <span class="keyword">COPY</span><span class="bash"> default.conf /etc/nginx/conf.d/default.conf</span></span><br></pre></td></tr></table></figure><ul><li><code>From nginx</code> 的意思是指定该镜像是基于 <code>nginx:latest</code> 镜像而构成的</li><li><code>COPY dist/ /usr/share/nginx/html/</code> 意思是将根目录下的打包后的 <code>dist</code> 文件夹中的所有文件复制到镜像中对应的目录下 镜像中的目录是不会变的</li><li><code>COPY default.conf /etc/nginx/conf.d/default.conf</code> 意思是将 <code>default.conf</code> 替换镜像中的 <code>conf</code> 配置</li></ul><h1 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h1><p>命令<br><code>docker build -t docker-demo-vue .</code></p><ul><li><code>-t</code> 的意思是给镜像命名</li><li><code>.</code> 是基于当前目录的 <code>Dockerfile</code> 构建镜像<br>然后继续运行 <code>docker images</code> 查看镜像<br><code>docker images</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119141922.png" alt=""><br>看到目前有两个镜像 并且镜像的名字也很清楚 大小是 142mb 基本上就是 <code>nginx</code> 的内容</li></ul><h1 id="查看端口是否被占用"><a href="#查看端口是否被占用" class="headerlink" title="查看端口是否被占用"></a>查看端口是否被占用</h1><p><code>netstat -a</code><br>查看所有的端口<br><code>netstat -ano|findstr 3000</code><br>找到对应的端口</p><h1 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h1><p><code>docker run -d -p 3000:80 --name docker-vue docker-demo-vue</code></p><ul><li><code>-d</code> 表示容器在后台运行</li><li><code>-p</code> 表示端口映射，把本机的 <code>3000</code> 端口映射到 <code>container</code> 的 <code>80</code> 端口（问题：容器运行前怎么知道端口是否被占用 怎么看容器内部的端口）</li><li><code>--name</code> 设置容器名</li><li><code>docker-demo-vue</code> 是镜像的名字</li></ul><h1 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h1><p><code>docker ps</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119142342.png" alt=""><br>我们就可以看到对应的 <code>docker</code> 容器名字 这里 <code>nginx</code> 由于我们没有对他命名所以他是默认的名字<br>修改容器名字<br>我们看到上述的 <code>nginx</code> 名字叫做 <code>great_villani</code> 那么对他重命名的方式就是<br><code>docker rename great_villani nginx</code><br>当然实际开发中肯定是直接在 run 容器的时候就直接命名了<br>比如<br><code>docker run --name nginx -d nginx</code><br>关闭容器<br><code>docker stop container_name</code><br>尝试一下关闭 <code>nginx</code><br><code>docker stop nginx</code><br>看到出现一个 <code>nginx</code> 就是关闭成功了</p><h1 id="查看静态项目资源"><a href="#查看静态项目资源" class="headerlink" title="查看静态项目资源"></a>查看静态项目资源</h1><p>我们可以通过指令去查看静态的打包文件<br><code>curl -v -i localhost:3000</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119142415.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="docker" scheme="https://zlinni.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>npm发布前端工具库</title>
    <link href="https://zlinni.github.io/posts/447422923/"/>
    <id>https://zlinni.github.io/posts/447422923/</id>
    <published>2023-01-19T03:51:55.000Z</published>
    <updated>2023-01-19T06:09:32.125Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>白浪费了那么多有用的代码.jpg<br>避免今后用到相同的代码却要在不同的仓库里反复找实现 我决定把公用的代码抽出来 方便以后能用(方便脑子短路的时候找不到合适的代码)<br>成果：<br><a href="https://www.npmjs.com/package/zlinni_common_pkg?activeTab=readme">https://www.npmjs.com/package/zlinni_common_pkg?activeTab=readme</a></p><h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><p>首先 GitHub 建一个仓库，我写的是 zlinni_common_pkg 之后添加一个 README，然后导出<br>clone 仓库后，npm init 出现 packgejson(稍后看)<br>新建一个 src 文件夹<br>新建一点代码 zlinniTool.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sayHi = (): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello~&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="包的规则"><a href="#包的规则" class="headerlink" title="包的规则"></a>包的规则</h1><p>打开我们的 pkgjson<br>这是我写的规则 附加注释</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;zlinni_common_pkg&quot;</span>, <span class="comment">//npm仓库对应的名字 不是github仓库的名字 这个包名一定不能重复</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>, <span class="comment">//包体对应的版本</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;个人工具库&quot;</span>, <span class="comment">//包体的功能性描述</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;./dist/zlinniTool.js&quot;</span>, <span class="comment">//入口文件</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;tsup src/zlinniTool.ts --minify&quot;</span> <span class="comment">//打包脚本 这个之后看</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;repository&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;git&quot;</span>, <span class="comment">//git 和仓库地址</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;git+https://github.com/Zlinni/common_pkg.git&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;zlinni&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;bugs&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 提交bug的地址</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://github.com/Zlinni/common_pkg/issues&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span>: <span class="string">&quot;https://github.com/Zlinni/common_pkg#readme&quot;</span>, <span class="comment">// npm首页展示</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;tsup&quot;</span>: <span class="string">&quot;^6.5.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [</span><br><span class="line">    <span class="comment">//搜索关键词</span></span><br><span class="line">    <span class="string">&quot;zlinni&quot;</span>,</span><br><span class="line">    <span class="string">&quot;common_pkg&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于包名查重</p><ol><li>直接去网站搜</li><li>执行命令<br><code>npm view 包名</code><br>如果找不到 就不重复</li></ol><h1 id="包的构建"><a href="#包的构建" class="headerlink" title="包的构建"></a>包的构建</h1><p>构建包体我们用到了 tsup 这个工具<br>是一款快速构建 ts 包体的工具<br>命令<br><code>tsup &lt;入口js&gt; --minify</code></p><ul><li><code>--minify</code> 可以缩小打包体积<br>然后就可以写在 <code>packagejson</code> 的 <code>build</code> 里面<br>执行 <code>npm run build</code> 就可以进行构建<br>就会看到打包出了一个 <code>dist</code> 文件，里面有 <code>zlinniTool.js</code> 和 <code>zlinniTool.mjs</code> 两个文件<h1 id="tsup-工具配置"><a href="#tsup-工具配置" class="headerlink" title="tsup 工具配置"></a><code>tsup</code> 工具配置</h1>分为两种 一种是单独写一个 <code>tsup.config.ts</code> 一种是直接在 <code>packgejson</code> 里面写<br>首先前者<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;tsup&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line"><span class="comment">// 入口文件 或者可以使用 entryPoints 底层是 esbuild</span></span><br><span class="line"><span class="attr">entry</span>: [<span class="string">&#x27;src/zlinniTool.ts&#x27;</span>],</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包类型 支持以下几种 &#x27;cjs&#x27; | &#x27;esm&#x27; | &#x27;iife&#x27;</span></span><br><span class="line"><span class="attr">format</span>: [<span class="string">&quot;cjs&quot;</span>, <span class="string">&quot;esm&quot;</span>],</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成类型文件 xxx.d.ts</span></span><br><span class="line"><span class="attr">dts</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码分割 默认 esm 模式支持 如果 cjs 需要代码分割的话就需要配置为 true</span></span><br><span class="line"><span class="attr">splitting</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// sourcemap</span></span><br><span class="line"><span class="attr">sourcemap</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次打包先删除 dist</span></span><br><span class="line"><span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// outExtension(&#123;format&#125;)&#123;</span></span><br><span class="line"><span class="comment">// return &#123;</span></span><br><span class="line"><span class="comment">// js:`.$&#123;format&#125;.js`</span></span><br><span class="line"><span class="comment">// &#125;  </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;);</span><br><span class="line">  </span><br></pre></td></tr></table></figure>这里比较关键的是 <code>dts</code> 先写为 <code>false</code><br>后者则是直接写进去 推荐前者<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119115909.png" alt=""><h1 id="包的发布"><a href="#包的发布" class="headerlink" title="包的发布"></a>包的发布</h1>上 npm 网站注册一个账号<a href="https://www.npmjs.com/">https://www.npmjs.com/</a><br>然后控制台 <code>npm login</code> 登录自己的账号 <code>npm publish</code> 发布<br>去网站上查看是否存在自己的包体 存在则成功<h1 id="去除无用的内容"><a href="#去除无用的内容" class="headerlink" title="去除无用的内容"></a>去除无用的内容</h1>当我们在网站上浏览的时候 会发现有 <code>dist</code> 目录，<code>src</code> 目录等<br>实际上 对于包体的使用者来说 是不需要 <code>src</code> 目录的 也就是不需要真实的代码<br>打个比方 前端打包出来的 <code>dist</code> 目录 是可以直接给到运维去构建的 他们也不需要关注我们的真实代码 只要 <code>dist</code> 能跑就行<br>同时 上传了 <code>src</code> 目录也增加了我们包体的体积<br>修改方式如下：<br>打开 <code>packgejson</code> 增加一行<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;files&quot;</span>: [<span class="string">&quot;/dist&quot;</span>,<span class="string">&quot;/README.md&quot;</span>,<span class="string">&quot;/package.json&quot;</span>]<span class="comment">// 只上传这些信息 很重要</span></span><br></pre></td></tr></table></figure>然后我们 <code>npm publish</code> 发现不行 这是因为我们没有修改版本号<br>我们只做了点小修改 所以把版本号改为 <code>1.0.1</code> 即可</li></ul><p>发布之后就会看到只剩下这些东西了<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119120031.png" alt=""></p><h1 id="dts"><a href="#dts" class="headerlink" title="dts"></a>dts</h1><p>在自己的项目中执行 <code>npm install zlinni_common_pkg</code><br>获取到相关的依赖后 引入文件<br>会发现没有类型提示 这是为什么呢？ 因为没有写 <code>dts</code><br><code>dts</code> 引入方法 <code>tsup.config.ts</code> 中 <code>dts</code> 设置为 <code>true</code><br><code>dts: true</code><br>然后继续 <code>build</code> 发现缺少了内容 <code>typescript</code><br>因为 <code>tsup</code> 虽然处理 <code>ts</code> 但是对于 <code>ts</code> 的生成还是需要 <code>typescript</code> 的支持<br>所以我们要安装一下 <code>ts</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -D</span><br></pre></td></tr></table></figure><br>再次 <code>build</code> 发现 <code>build</code> 成功了<br>打开 <code>dist</code> 目录 找到了 <code>zlinniTool.d.ts</code><br>这个就是函数的类型文件<br>再次 <code>publish</code><br>在对应的项目中执行<br><code>npm update zlinni_common_pkg</code><br>进行更新 就找得到类型声明了<br>一些问题<br>如果没有对 <code>tsconfig</code> 进行配置，那么可能输出的时候会缺少 <code>module</code> 的识别<br>添加代码 <code>tsconfig.json</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line"><span class="attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">&quot;lib&quot;</span>: [</span><br><span class="line"><span class="string">&quot;esnext&quot;</span>,</span><br><span class="line"><span class="string">&quot;dom&quot;</span>,</span><br><span class="line"><span class="string">&quot;dom.iterable&quot;</span>,</span><br><span class="line"><span class="string">&quot;scripthost&quot;</span>,</span><br><span class="line"><span class="string">&quot;ES6&quot;</span>,</span><br><span class="line"><span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line"><span class="string">&quot;ES2015.Promise&quot;</span>,</span><br><span class="line"><span class="string">&quot;ES2015.Generator&quot;</span></span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="CICD？"><a href="#CICD？" class="headerlink" title="CICD？"></a>CICD？</h1><p>Git 上传之后自动触发 <code>npm publish</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="npm" scheme="https://zlinni.github.io/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>jest单元测试学习</title>
    <link href="https://zlinni.github.io/posts/2976841894/"/>
    <id>https://zlinni.github.io/posts/2976841894/</id>
    <published>2023-01-19T03:05:58.000Z</published>
    <updated>2023-01-19T03:44:49.418Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>初始化一个项目：<br><code>yarn init</code><br><code>yarn add jest</code><br>插件 vscode jest 的 snippet<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119111503.png" alt=""><br>Jest 用于直接检测(自动 run 脚本)<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119111545.png" alt=""></p><h1 id="测试加法函数"><a href="#测试加法函数" class="headerlink" title="测试加法函数"></a>测试加法函数</h1><p>新建 src 编写一个 math.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; sum &#125;;</span><br></pre></td></tr></table></figure><p>在同目录下编写<code>math.jest.js</code><br>一个测试文件组成</p><ol><li>引入的测试 js</li><li>模块函数 describe<br>a. 包含了 test 函数，和 given when then</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; sum &#125; = <span class="built_in">require</span>(<span class="string">&quot;./math&quot;</span>);</span><br><span class="line">describe(<span class="string">&quot;Math module&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&quot;jest math return sum&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// given</span></span><br><span class="line">    <span class="keyword">const</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> anotherNumber = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// when</span></span><br><span class="line">    <span class="keyword">const</span> result = sum(number, anotherNumber);</span><br><span class="line">    <span class="comment">// then</span></span><br><span class="line">    expect(result).toEqual(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="编写脚本-packgejson"><a href="#编写脚本-packgejson" class="headerlink" title="编写脚本 packgejson"></a>编写脚本 packgejson</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jestDemo&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;MIT&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;jest&quot;</span>: <span class="string">&quot;^29.3.1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;jest &quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跑脚本"><a href="#跑脚本" class="headerlink" title="跑脚本"></a>跑脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn jest</span><br></pre></td></tr></table></figure><h3 id="成功状态"><a href="#成功状态" class="headerlink" title="成功状态"></a>成功状态</h3><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119111741.png" alt=""><br>把 equal 改成 1 测试失败状态</p><h3 id="失败状态"><a href="#失败状态" class="headerlink" title="失败状态"></a>失败状态</h3><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119111806.png" alt=""><br>看这个报错也可以知道是 toEqual 的报错<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119111822.png" alt=""></p><h1 id="toBe-和-toEqual"><a href="#toBe-和-toEqual" class="headerlink" title="toBe 和 toEqual"></a>toBe 和 toEqual</h1><p>toBe 相当于=== 缺点 不能判断引用类型<br>toEqual 则是完全相对 包括引用类型里面的值也要相等<br>编写<code>demo.test.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试toBe和toEqual</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> can1 = &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">  <span class="attr">test2</span>: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> can2 = &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">  <span class="attr">test2</span>: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&quot;test&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&quot;expect().toBe();&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(<span class="number">1</span> + <span class="number">1</span>).toBe(<span class="number">2</span>);</span><br><span class="line">    expect(<span class="number">1</span> + <span class="number">1</span>).not.toBe(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  test(<span class="string">&quot;expect().toEqual();&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(can1).toEqual(can2);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>run 脚本<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119111904.png" alt=""></p><h1 id="模块间依赖"><a href="#模块间依赖" class="headerlink" title="模块间依赖"></a>模块间依赖</h1><p>依赖分为两种类型：<br>社交型测试单元和独立型测试单元<br>当一个模块需要依赖其他模块来实现他的功能的时候，他就是一个社交型单元<br>当一个模块不需要依赖其他模块就能实现自己的功能的时候 就是一个独立型单元</p><h1 id="Mock-stub-和-spy"><a href="#Mock-stub-和-spy" class="headerlink" title="Mock stub 和 spy"></a>Mock stub 和 spy</h1><p>mock 用于替代某个模块</p><p>stub 意为打桩 用于模拟特定的行为<br>代码例子<br>第一个 test 创建了一个<code>jestfn</code> 虽然里面没有写东西但是代表他已经是一个函数 <code>toHaveBeenCalled</code>代表他是否被调用<br>第二个 test 创建了个返回值永远为<code>true</code>的<code>jestfn</code>, 调用返回了<code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stub用于模拟特定行为</span></span><br><span class="line">describe(<span class="string">&quot;jest stub&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&quot;jestfn&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> mockFn = jest.fn();</span><br><span class="line">    mockFn();</span><br><span class="line">    expect(mockFn).toHaveBeenCalled();</span><br><span class="line">  &#125;);</span><br><span class="line">  test(<span class="string">&quot;returnsTrue&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> returnsTrue = jest.fn(<span class="function">() =&gt;</span> <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(returnsTrue());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119111958.png" alt=""><br>spy 用于监听模块的行为</p><h1 id="单元模块的易测性"><a href="#单元模块的易测性" class="headerlink" title="单元模块的易测性"></a>单元模块的易测性</h1><p>我们编写测试代码的时候，相互间依赖的模块应该以最简单的形式展现出来，而我们的 mock 作用是代替某个模块，如果我们 mock 次数多了就要考虑这个模块的独立性了</p><p>所以在保持模块独立性的同时，也是促使自己去思考什么样的模块符合职责单一原则</p><p>代码的易测性也代表着代码的可维护性</p><h1 id="实现一个查找名称的方法并测试"><a href="#实现一个查找名称的方法并测试" class="headerlink" title="实现一个查找名称的方法并测试"></a>实现一个查找名称的方法并测试</h1><p>新建一个 searchName.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> services <span class="keyword">from</span> <span class="string">&quot;./service&quot;</span>; <span class="comment">// 这个是后端代码 可以暂时不写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果数据大于三个返回三个 小于三个直接返回</span></span><br><span class="line"><span class="keyword">const</span> searchNames = <span class="function">(<span class="params">term</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matches = services.getNames().filter(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name.includes(term);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> matches.length &gt; <span class="number">3</span> ? matches.slice(<span class="number">0</span>, <span class="number">3</span>) : matches;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> searchNames;</span><br><span class="line">编写测试代码searchName.test.js;</span><br><span class="line"><span class="keyword">import</span> searchNames <span class="keyword">from</span> <span class="string">&quot;./searchName&quot;</span>;</span><br><span class="line">test(<span class="string">&quot;should return empty result when not search&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  <span class="keyword">const</span> keyword = <span class="string">&quot;JOJO&quot;</span>;</span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line">  <span class="keyword">const</span> result = searchNames(keyword);</span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  expect(result).toEqual([]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时运行<br>发现他不支持 esm 所以我们需要借助 babel<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112059.png" alt=""><br><a href="https://jestjs.io/docs/getting-started">https://jestjs.io/docs/getting-started</a><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112109.png" alt=""><br>操作完成后就可以执行了</p><h2 id="借助于-jest-mock"><a href="#借助于-jest-mock" class="headerlink" title="借助于 jest mock"></a>借助于 jest mock</h2><p>其实我们做测试的时候并不关心传过来的数据，而是想测试这个函数的功能是否健壮<br>那么我们就可以利用 jest 的 mock 去取代这个模块 注意不要写<code>desrcribe</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> searchNames <span class="keyword">from</span> <span class="string">&quot;./searchName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于拦截了service里面的getNames</span></span><br><span class="line">jest.mock(<span class="string">&quot;./service&quot;</span>, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">getNames</span>: jest.fn(<span class="function">() =&gt;</span> [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Paul&quot;</span>, <span class="string">&quot;George&quot;</span>, <span class="string">&quot;Ringo&quot;</span>]),</span><br><span class="line">&#125;));</span><br><span class="line">test(<span class="string">&quot;should return empty result when not search&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  <span class="keyword">const</span> keyword = <span class="string">&quot;JOJO&quot;</span>;</span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line">  <span class="keyword">const</span> result = searchNames(keyword);</span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  expect(result).toEqual([]);</span><br><span class="line">&#125;);</span><br><span class="line">test(<span class="string">&quot;should return empty result when found search&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  <span class="keyword">const</span> keyword = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line">  <span class="keyword">const</span> result = searchNames(keyword);</span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  expect(result).toEqual([<span class="string">&quot;John&quot;</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时就可以跑通上述两个测试</p><h2 id="mockImplementation-单独模拟"><a href="#mockImplementation-单独模拟" class="headerlink" title="mockImplementation 单独模拟"></a>mockImplementation 单独模拟</h2><p>如果我们想对单个测试使用单独的 mock，那么可以写拦截方法.mockImplementation<br>这个方法可以单独模拟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> searchNames <span class="keyword">from</span> <span class="string">&quot;./searchName&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getNames &#125; <span class="keyword">from</span> <span class="string">&quot;./service&quot;</span>;</span><br><span class="line"><span class="comment">// describe(&#x27;searchName&#x27;, () =&gt; &#123;</span></span><br><span class="line"><span class="comment">// 拦截了service里面的getNames</span></span><br><span class="line"><span class="comment">// jest.mock(&quot;./service&quot;, () =&gt; (&#123;</span></span><br><span class="line"><span class="comment">//   getNames: jest.fn(() =&gt; [&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;]),</span></span><br><span class="line"><span class="comment">// &#125;));</span></span><br><span class="line">jest.mock(<span class="string">&quot;./service&quot;</span>, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">getNames</span>: jest.fn(),</span><br><span class="line">&#125;));</span><br><span class="line">test(<span class="string">&quot;should return empty result when not search&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  <span class="keyword">const</span> keyword = <span class="string">&quot;JOJO&quot;</span>;</span><br><span class="line">  getNames.mockImplementation(<span class="function">() =&gt;</span> []);</span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line">  <span class="keyword">const</span> result = searchNames(keyword);</span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  expect(result).toEqual([]);</span><br><span class="line">&#125;);</span><br><span class="line">test(<span class="string">&quot;should return empty result when found search&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  <span class="keyword">const</span> keyword = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">  getNames.mockImplementation(<span class="function">() =&gt;</span> [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Paul&quot;</span>, <span class="string">&quot;George&quot;</span>, <span class="string">&quot;Ringo&quot;</span>]);</span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line">  <span class="keyword">const</span> result = searchNames(keyword);</span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  expect(result).toEqual([<span class="string">&quot;John&quot;</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// &#125;);</span></span><br></pre></td></tr></table></figure><p>不过此时抛出一个疑问 为什么没有提示<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112216.png" alt=""><br>为了保证测试的完整性和简单性 我们应该重复的去使用他 也就是说测试里面不应该有任何逻辑</p><h2 id="toHaveLength-判断长度"><a href="#toHaveLength-判断长度" class="headerlink" title="toHaveLength 判断长度"></a>toHaveLength 判断长度</h2><p>补充两个测试 并学习 toHaveLength 的用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;should not return more than 3 matches&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  <span class="keyword">const</span> keyword = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">  getNames.mockImplementation(<span class="function">() =&gt;</span> [<span class="string">&quot;John 1&quot;</span>, <span class="string">&quot;John 2&quot;</span>, <span class="string">&quot;John 3 &quot;</span>, <span class="string">&quot;John4&quot;</span>]);</span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line">  <span class="keyword">const</span> result = searchNames(keyword);</span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  expect(result).toHaveLength(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;should handle null or undefined as input&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  getNames.mockImplementation(<span class="function">() =&gt;</span> []);</span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  expect(searchNames(<span class="literal">undefined</span>)).toEqual([]);</span><br><span class="line">  expect(searchNames(<span class="literal">null</span>)).toEqual([]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="测试帮助我们快速重构代码"><a href="#测试帮助我们快速重构代码" class="headerlink" title="测试帮助我们快速重构代码"></a>测试帮助我们快速重构代码</h2><p>如果我们想实现输出的结果对于输入的大小写不敏感 那么测试用例应该是如下编写 此时是跑不通的 所以我们去重构代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;should return search result is not case sensitive&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  getNames.mockImplementation(<span class="function">() =&gt;</span> [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Paul&quot;</span>, <span class="string">&quot;George&quot;</span>, <span class="string">&quot;Ringo&quot;</span>]);</span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  <span class="comment">// 目前这个测试用例是跑不通的 因为我们并没有实现这样的功能</span></span><br><span class="line">  expect(searchNames(<span class="string">&quot;john&quot;</span>)).toEqual([<span class="string">&quot;John&quot;</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> services <span class="keyword">from</span> <span class="string">&quot;./service&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果数据大于三个返回三个 小于三个直接返回</span></span><br><span class="line"><span class="keyword">const</span> searchNames = <span class="function">(<span class="params">keyword</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> matches = services.getNames().filter(<span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name.toUpperCase().includes(keyword.toUpperCase());</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> matches.length &gt; <span class="number">3</span> ? matches.slice(<span class="number">0</span>, <span class="number">3</span>) : matches;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> searchNames;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112320.png" alt=""><br>总结<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112339.png" alt=""><br>我们可以通过 vscode 看到每个单元测试，让我们能够快速回顾逻辑，并且他们都是可以自动化运行的，避免在我们今后改动了某些实现导致测试失败</p><h1 id="jest-的-watch-模式"><a href="#jest-的-watch-模式" class="headerlink" title="jest 的 watch 模式"></a>jest 的 watch 模式</h1><p>注意该功能需要<code>git init</code><br>监视者模式<br><code>yarn jest --watch</code><br>有多个辅助命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Watch Usage</span><br><span class="line"> <span class="comment"># 按 a 进入 a 模式：运行所有的测试。</span></span><br><span class="line"> <span class="comment"># a 进入，a 退出</span></span><br><span class="line"> <span class="comment"># 也可以使用 jest --watchAll 直接进入 a 模式</span></span><br><span class="line"> <span class="comment"># 只有 jest --watch 时才能使用</span></span><br><span class="line"> › Press a to run all tests.</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 按 f 进入 f 模式：只运行失败的测试。</span></span><br><span class="line"> <span class="comment"># f 进入，f 退出</span></span><br><span class="line"> › Press f to run only failed tests.</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 按 o 进入 o 模式：只运行与更改文件相关的测试。</span></span><br><span class="line"> <span class="comment"># 需要 Git 支持</span></span><br><span class="line"> <span class="comment"># 也可以使用 jest --watch 直接进入 o 模式</span></span><br><span class="line"> <span class="comment"># 只有 jest --watchAll 时才能使用</span></span><br><span class="line"> › Press o to only run tests related to changed files.</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 按 p 以文件名正则表达式模式进行过滤。</span></span><br><span class="line"> <span class="comment"># 只有 --watchAll 的时候 p 模式才可以使用</span></span><br><span class="line"> <span class="comment"># 注意：testRegex 将尝试使用绝对文件路径来检测测试文件，因此，具有名称与之匹配的文件夹将所有文件作为测试运行</span></span><br><span class="line"> <span class="comment"># testRegex 会忽略 testMatch</span></span><br><span class="line"> › Press p to filter by a filename regex pattern.</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 按 t 以测试名称（test 方法第一个参数）正则表达式模式进行过滤。</span></span><br><span class="line"> › Press t to filter by a <span class="built_in">test</span> name regex pattern.</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 按 q 退出监视模式</span></span><br><span class="line"> › Press q to quit watch mode.</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 按 Enter 键触发测试运行</span></span><br><span class="line"> › Press Enter to trigger a <span class="built_in">test</span> run.</span><br></pre></td></tr></table></figure><h1 id="jest-的-coverage"><a href="#jest-的-coverage" class="headerlink" title="jest 的 coverage"></a>jest 的 coverage</h1><p>命令:<br><code>yarn jest --coverage</code><br>Jest coverage 我们可以看到有多少语句是被测试过的，有多少分支是被测试过的<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112444.png" alt=""><br>然后他会在根目录生成一个文件夹 coverage<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112454.png" alt=""><br>里面的 html 可以打开看此次的测试报告<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112503.png" alt=""></p><h1 id="快照系统"><a href="#快照系统" class="headerlink" title="快照系统"></a>快照系统</h1><p>jest 提供了一个快照方法能够直接打印出对应的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sayHelloToName = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 下面是测试</span></span><br><span class="line">test(<span class="string">&quot;should say Hello when search&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = sayHelloToName(<span class="string">&quot;JOJO&quot;</span>);</span><br><span class="line">  <span class="comment">// expect(result).toEqual(&quot;Hello JOJO&quot;);</span></span><br><span class="line">  <span class="comment">// 能够快速的把结果显示出来</span></span><br><span class="line">  expect(result).toMatchInlineSnapshot(<span class="string">`&quot;Hello JOJO&quot;`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="测试原则"><a href="#测试原则" class="headerlink" title="测试原则"></a>测试原则</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112533.png" alt=""></p><p>分为端到端测试（模拟用户行为）集成测试（验证多个单元能否协调工作）单元测试，静态检查（ts eslint）</p><h1 id="组件化测试"><a href="#组件化测试" class="headerlink" title="组件化测试"></a>组件化测试</h1><p>安装项目<br><code>yarn create react-app fed-testing-react --template typescript</code><br>执行测试<br><code>yarn test</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112558.png" alt=""><br>观察一下他的测试代码 也是非常经典的 given when then</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render, screen &#125; <span class="keyword">from</span> <span class="string">&quot;@testing-library/react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;renders learn react link&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// given</span></span><br><span class="line">  render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line">  <span class="comment">// when</span></span><br><span class="line">  <span class="keyword">const</span> linkElement = screen.getByText(<span class="regexp">/learn react/i</span>);</span><br><span class="line">  <span class="comment">// then</span></span><br><span class="line">  expect(linkElement).toBeInTheDocument();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>传递了两个函数 一个是<code>render</code> 用于渲染组件，<code>screen</code> 用于获取对应的组件元素 这里是在 app 里面通过文本的方式找到了这个 a 标签<br>然后 <code>toBeInTheDocument</code> 就可以验证这个元素是否在 <code>document</code> 中</p><h2 id="编写一个输入框，查看输入的内容是否显示在对应的标签中并测试"><a href="#编写一个输入框，查看输入的内容是否显示在对应的标签中并测试" class="headerlink" title="编写一个输入框，查看输入的内容是否显示在对应的标签中并测试"></a>编写一个输入框，查看输入的内容是否显示在对应的标签中并测试</h2><p>稍微修改一下我们的 <code>app.tsx</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="comment">// import logo from &#x27;./logo.svg&#x27;;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./App.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [fullName, setFullName] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">placeholder</span>=<span class="string">&#123;</span>&quot;<span class="attr">Type</span> <span class="attr">your</span> <span class="attr">name</span>&quot;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">value</span>=<span class="string">&#123;fullName&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setFullName(e.target.value)&#125;</span></span><br><span class="line"><span class="xml">      &gt;<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;/_ 要用 span 包起来 _/&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        my name is <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;fullName&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>运行<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112659.png" alt=""><br>可以操作<br>接下来修改我们的测试代码 我们发现我们需要找到输入框，那么我们可以通过找输入框一开始的 placeHolder 去查找到该输入框<br>这里介绍一下两个 api</p><ul><li><code>getByPlaceholderText</code> 找到输入框的 <code>placeHolder</code> 找不到返回 <code>null</code></li><li><code>queryByPlaceholderText</code> 同理 但 ts 会报错<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112710.png" alt=""><br>因为我们需要确定一定能找到 所以一般用的是前者</li></ul><p>然后我们需要找到输入的 <code>name</code> 是否在页面中 则要用到 <code>getByText</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render, screen &#125; <span class="keyword">from</span> <span class="string">&quot;@testing-library/react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> userEvent <span class="keyword">from</span> <span class="string">&quot;@testing-library/user-event&quot;</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;should show fullName when type&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//given</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;JOJO&quot;</span>;</span><br><span class="line">  <span class="comment">//when</span></span><br><span class="line">  render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line">  <span class="comment">// 模拟用户行为在输入框上面输入</span></span><br><span class="line">  userEvent.type(screen.getByPlaceholderText(<span class="string">&quot;Type your name&quot;</span>), name);</span><br><span class="line">  <span class="comment">//then</span></span><br><span class="line">  <span class="comment">// 找到输出结果一致的地方</span></span><br><span class="line">  expect(screen.getByText(name)).toBeInTheDocument();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112803.png" alt=""><br>运行成功 成功测试组件</p><h2 id="TODO-组件测试"><a href="#TODO-组件测试" class="headerlink" title="TODO 组件测试"></a>TODO 组件测试</h2><p>代码仓库：<a href="https://github.com/JimmyLv/fed-testing-react">https://github.com/JimmyLv/fed-testing-react</a><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112907.png" alt=""><br>首先这个 <code>todo</code> 组件有三个默认的事件，而且我们可以对他进行增删改，现在我们要对他的功能进行测试<br>然后在对应的 <code>Todo.tsx</code> 目录下面新建 <code>Todo.test.tsx</code><br>我们了解到这个 <code>todo</code> 能分别进行以下的事情</p><ul><li>渲染新的 <code>todo</code></li><li>点击 <code>complete</code> 按钮执行 <code>toggleTodo</code></li><li>点击 <code>Redo</code> 按钮执行 <code>toggleTodo</code></li><li>点击 <code>x</code> 按钮执行 <code>removeTodo</code></li></ul><p>所以我们要针对这几个交互事件去做单测</p><h3 id="渲染新的-item"><a href="#渲染新的-item" class="headerlink" title="渲染新的 item"></a>渲染新的 <code>item</code></h3><p>我们在输入框输入事件之后回车会生成新的 <code>todo</code> 现在我们要开始测试这一项<br>首先观察组件传递新 <code>todo</code> 的方式<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119112920.png" alt=""><br>我们发现他是通过 <code>prop</code> 传递了 <code>todo</code> 事件 <code>index</code> 和两个 <code>function</code> 进去的<br>所以我们对应也要创建新的 <code>todo</code> 给他送进去 对于 <code>function</code> 我们可以用 <code>jest.fn()</code>去暂时隔离 那么代码就是</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render,screen &#125; <span class="keyword">from</span> <span class="string">&quot;@testing-library/react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Todo &#125; <span class="keyword">from</span> <span class="string">&quot;./Todo&quot;</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;Name of the group&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">test(<span class="string">&quot;should render new item&quot;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">const</span> todo = &#123;</span><br><span class="line"><span class="attr">id</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">text</span>:<span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line"><span class="attr">completed</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">Todo</span> <span class="attr">todo</span>=<span class="string">&#123;todo&#125;</span> <span class="attr">index</span>=<span class="string">&#123;todo.id&#125;</span> <span class="attr">toggleTodo</span>=<span class="string">&#123;jest.fn()&#125;</span> <span class="attr">removeTodo</span>=<span class="string">&#123;jest.fn()&#125;/</span>&gt;</span></span>)</span><br><span class="line">expect(screen.getByText(<span class="string">&quot;Hello World&quot;</span>)).toBeInTheDocument();</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那么这个单侧就能通过了</p><h3 id="test-todo"><a href="#test-todo" class="headerlink" title="test.todo"></a><code>test.todo</code></h3><p>我们写完整的测试代码之前可能要经历一个类似于 <code>todo</code> 的过程，那么其实 <code>jest</code> 也是有提供类似的代码的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.todo(<span class="string">&quot;should render completed item&quot;</span>);</span><br><span class="line">test.todo(<span class="string">&quot;should delete item&quot;</span>);</span><br><span class="line">test.todo(<span class="string">&quot;should toggle item&quot;</span>);</span><br></pre></td></tr></table></figure><p>编写好之后，会发现他实际上是不会跑的，就相当于一个注释放在那里用于后续的测试流程<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119113056.png" alt=""></p><h3 id="渲染完成状态"><a href="#渲染完成状态" class="headerlink" title="渲染完成状态"></a>渲染完成状态</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;should render completed item&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> todo = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">    <span class="attr">isCompleted</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Todo</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">todo</span>=<span class="string">&#123;todo&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">index</span>=<span class="string">&#123;todo.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">toggleTodo</span>=<span class="string">&#123;jest.fn()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">removeTodo</span>=<span class="string">&#123;jest.fn()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  expect(screen.getByText(<span class="string">&quot;Redo&quot;</span>)).toBeInTheDocument();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="是否调用了-toggleTodo"><a href="#是否调用了-toggleTodo" class="headerlink" title="是否调用了 toggleTodo"></a>是否调用了 <code>toggleTodo</code></h3><ul><li>对于已完成的事件 点击 Redo</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;should toggle item&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> todo = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">    <span class="attr">isCompleted</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> toggleTodo = jest.fn();</span><br><span class="line">  render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Todo</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">todo</span>=<span class="string">&#123;todo&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">index</span>=<span class="string">&#123;todo.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">toggleTodo</span>=<span class="string">&#123;toggleTodo&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">removeTodo</span>=<span class="string">&#123;jest.fn()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 已经完成的事件 点击了 Redo 之后</span></span><br><span class="line">  userEvent.click(screen.getByText(<span class="string">&quot;Redo&quot;</span>));</span><br><span class="line">  <span class="comment">// toggleTodo 这个函数是否被触发一次</span></span><br><span class="line">  expect(toggleTodo).toHaveBeenCalledTimes(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 我们在此单元测试里面不需要关心 toggleTodo 这个函数产生了什么样的结果</span></span><br><span class="line">  <span class="comment">// 只需要知道他被调用过了即可</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>对于未完成的事件 点击 Complete</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;should toggle item when todo not completed&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> todo = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">    <span class="attr">isCompleted</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> toggleTodo = jest.fn();</span><br><span class="line">  render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Todo</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">todo</span>=<span class="string">&#123;todo&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">index</span>=<span class="string">&#123;todo.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">toggleTodo</span>=<span class="string">&#123;toggleTodo&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">removeTodo</span>=<span class="string">&#123;jest.fn()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 未完成的事件 点击 Complete 之后</span></span><br><span class="line">  userEvent.click(screen.getByText(<span class="string">&quot;Complete&quot;</span>));</span><br><span class="line">  <span class="comment">// removeTodo 这个函数是否被触发一次</span></span><br><span class="line">  expect(toggleTodo).toHaveBeenCalledTimes(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="是否调用了-deleteTodo"><a href="#是否调用了-deleteTodo" class="headerlink" title="是否调用了 deleteTodo"></a>是否调用了 <code>deleteTodo</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;should delete item&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> todo = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">    <span class="attr">isCompleted</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> removeTodo = jest.fn();</span><br><span class="line">  render(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Todo</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">todo</span>=<span class="string">&#123;todo&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">index</span>=<span class="string">&#123;todo.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">toggleTodo</span>=<span class="string">&#123;jest.fn()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">      <span class="attr">removeTodo</span>=<span class="string">&#123;removeTodo&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    /&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 点击了 Redo 之后</span></span><br><span class="line">  userEvent.click(screen.getByText(<span class="string">&quot;x&quot;</span>));</span><br><span class="line">  <span class="comment">// removeTodo 这个函数是否被触发一次</span></span><br><span class="line">  expect(removeTodo).toHaveBeenCalledTimes(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="检验测试覆盖率"><a href="#检验测试覆盖率" class="headerlink" title="检验测试覆盖率"></a>检验测试覆盖率</h3><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119113252.png" alt=""></p><h2 id="Todo-Form-组件测试"><a href="#Todo-Form-组件测试" class="headerlink" title="Todo Form 组件测试"></a>Todo Form 组件测试</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">TodoForm</span>(<span class="params">&#123; addTodo &#125;: &#123; addTodo: (todo: string) =&gt; <span class="keyword">void</span> &#125;</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [value, setValue] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleSubmit = <span class="function">(<span class="params">e: React.FormEvent</span>) =&gt;</span> &#123;</span><br><span class="line">e.preventDefault();</span><br><span class="line"><span class="keyword">if</span> (!value) <span class="keyword">return</span>;</span><br><span class="line">addTodo(value);</span><br><span class="line">setValue(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">placeholder</span>=<span class="string">&#123;</span>`<span class="attr">What</span>&#x27;<span class="attr">s</span> <span class="attr">your</span> <span class="attr">plan</span>?`&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">className</span>=<span class="string">&quot;input&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">value</span>=<span class="string">&#123;value&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setValue(e.target.value)&#125;</span></span><br><span class="line"><span class="xml">/&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>观察这段组件代码 我们可以知道 <code>form</code> 组件做了以下几件事情</p><ul><li>输入值之后 执行 <code>addTodo</code> 和 <code>setValue</code></li><li>输入空值 不执行 <code>addTodo</code><h3 id="输入值后执行-addTodo"><a href="#输入值后执行-addTodo" class="headerlink" title="输入值后执行 addTodo"></a>输入值后执行 <code>addTodo</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;should allow add todo when not empty input&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//given</span></span><br><span class="line"><span class="keyword">const</span> addTodo = jest.fn();</span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">TodoForm</span> <span class="attr">addTodo</span>=<span class="string">&#123;addTodo&#125;</span> /&gt;</span></span>);</span><br><span class="line"><span class="comment">//when</span></span><br><span class="line"><span class="comment">// 模拟回车输入值</span></span><br><span class="line">userEvent.type(screen.getByPlaceholderText(<span class="string">&quot;What&#x27;s your plan?&quot;</span>), <span class="string">&quot;do sth&#123;enter&#125;&quot;</span>);</span><br><span class="line"><span class="comment">//then</span></span><br><span class="line"><span class="comment">//这里写 toBeCalledWith 是代表 addTodo 这个函数是否被 do sth 这个参数调用</span></span><br><span class="line">expect(addTodo).toBeCalledWith(<span class="string">&#x27;do sth&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="输入空值不执行-addTodo"><a href="#输入空值不执行-addTodo" class="headerlink" title="输入空值不执行 addTodo"></a>输入空值不执行 addTodo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;should ignore empty input&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//given</span></span><br><span class="line"><span class="keyword">const</span> addTodo = jest.fn();</span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">TodoForm</span> <span class="attr">addTodo</span>=<span class="string">&#123;addTodo&#125;</span> /&gt;</span></span>);</span><br><span class="line"><span class="comment">//when</span></span><br><span class="line"><span class="comment">// 模拟回车输入空值 用花括号标识回车</span></span><br><span class="line">userEvent.type(screen.getByPlaceholderText(<span class="string">&quot;What&#x27;s your plan?&quot;</span>), <span class="string">&quot;&#123;enter&#125;&quot;</span>);</span><br><span class="line"><span class="comment">//then</span></span><br><span class="line"><span class="comment">// 这里要写 toBeCalled 不能写 toHaveBeenCalled 因为后者需要传递大于 0 的整数</span></span><br><span class="line">expect(addTodo).not.toBeCalled();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="app-组件测试"><a href="#app-组件测试" class="headerlink" title="app 组件测试"></a>app 组件测试</h2><p>  观察一下 app 组件的代码<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  <span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line">  <span class="keyword">import</span> <span class="string">&quot;./App.css&quot;</span>;</span><br><span class="line">  <span class="keyword">import</span> &#123; Todo &#125; <span class="keyword">from</span> <span class="string">&quot;./components/Todo&quot;</span>;</span><br><span class="line">  <span class="keyword">import</span> &#123; TodoForm &#125; <span class="keyword">from</span> <span class="string">&quot;./components/TodoForm&quot;</span>;</span><br><span class="line">  <span class="keyword">import</span> &#123; TodoType &#125; <span class="keyword">from</span> <span class="string">&#x27;./types&#x27;</span></span><br><span class="line">  <span class="keyword">import</span> &#123; toggleOneTodo &#125; <span class="keyword">from</span> <span class="string">&quot;./utils/toggleOneTodo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [todos, setTodos] = useState&lt;TodoType[]&gt;([</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">text</span>: <span class="string">&quot;Learn about React&quot;</span>,</span><br><span class="line"><span class="attr">isCompleted</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">text</span>: <span class="string">&quot;Meet friend for lunch&quot;</span>,</span><br><span class="line"><span class="attr">isCompleted</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">text</span>: <span class="string">&quot;Build really cool todo app&quot;</span>,</span><br><span class="line"><span class="attr">isCompleted</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addTodo = <span class="function">(<span class="params">text: string</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> newTodos = [...todos, &#123; text &#125;];</span><br><span class="line">setTodos(newTodos);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toggleTodo = <span class="function">(<span class="params">index: number</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> newTodos = toggleOneTodo(todos, index);</span><br><span class="line">setTodos(newTodos);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> removeTodo = <span class="function">(<span class="params">index: number</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> newTodos = [...todos];</span><br><span class="line">newTodos.splice(index, <span class="number">1</span>);</span><br><span class="line">setTodos(newTodos);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;todo-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#123;todos.map((todo, index) =&gt; (</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Todo</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">key</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">index</span>=<span class="string">&#123;index&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">todo</span>=<span class="string">&#123;todo&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">toggleTodo</span>=<span class="string">&#123;toggleTodo&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">removeTodo</span>=<span class="string">&#123;removeTodo&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          /&gt;</span></span></span><br><span class="line"><span class="xml">))&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">TodoForm</span> <span class="attr">addTodo</span>=<span class="string">&#123;addTodo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></p><p>他做了以下几件事情</p><ul><li>渲染了三个 todo list</li><li>执行 <code>addTodo</code> 会添加一个 <code>item</code></li><li>执行 <code>removeTodo</code> 会删除一个 <code>item</code></li><li>执行 <code>toggleTodo</code> 会切换 <code>todo</code> 的状态<h3 id="渲染三个-todo（getAllByTestId-的使用）"><a href="#渲染三个-todo（getAllByTestId-的使用）" class="headerlink" title="渲染三个 todo（getAllByTestId 的使用）"></a>渲染三个 todo（<code>getAllByTestId</code> 的使用）</h3>我们在这里会发现没办法借助什么标识符去知道我们到底渲染了多少个初始 todo<br>那么回去 todo 组件查看 发现写了一个 <code>data-testid</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119113517.png" alt=""><br>那么就可以借助这个 <code>id</code> 来看目前渲染的 item 数目<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;should render todo-list&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//given</span></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>)</span><br><span class="line"><span class="comment">//when</span></span><br><span class="line"><span class="keyword">const</span> todos = screen.getAllByTestId(<span class="string">&quot;todo-item&quot;</span>);</span><br><span class="line"><span class="comment">//then</span></span><br><span class="line">expect(todos).toHaveLength(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="检测-add-Todo"><a href="#检测-add-Todo" class="headerlink" title="检测 add Todo"></a>检测 add Todo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;should add todo&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//given</span></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line"><span class="comment">//when</span></span><br><span class="line"><span class="comment">// 模拟用户输入</span></span><br><span class="line">userEvent.type(</span><br><span class="line">screen.getByPlaceholderText(<span class="string">&quot;What&#x27;s your plan?&quot;</span>),</span><br><span class="line"><span class="string">&quot;do sth&#123;enter&#125;&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//then</span></span><br><span class="line"><span class="keyword">const</span> todos = screen.getAllByTestId(<span class="string">&quot;todo-item&quot;</span>);</span><br><span class="line"><span class="comment">//then</span></span><br><span class="line">expect(todos).toHaveLength(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="检测-removeTodo（within，getByTestId-的使用）"><a href="#检测-removeTodo（within，getByTestId-的使用）" class="headerlink" title="检测 removeTodo（within，getByTestId 的使用）"></a>检测 removeTodo（<code>within</code>，<code>getByTestId</code> 的使用）</h3><p>  removeTodo 的话呢 我们最好就是对默认的数据进行操作，因为如果我们需要先添加后操作的话其实是会有可能出错的<br> <img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119113621.png" alt=""><br>  我们可以通过 remove-todo 这个 <code>testid</code> 去找到 <code>remove</code><br>  但是页面有三个默认的 item 我们要怎么去找到对应 <code>item</code> 的 <code>remove</code> 呢<br>  这里就涉及到一个新的 api within 他能找到在这个对应元素内部的东西<br>  那我们就需要根据默认 item 的名字加上 within 去找到里面的 testid 就可以了<br> <code>within(screen.getByText(&quot;Learn about React&quot;)).getByTestId(&#39;remove-todo&#39;)</code><br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;should remove todo&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//given</span></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line"><span class="comment">//when</span></span><br><span class="line"><span class="comment">// 模拟用户输入</span></span><br><span class="line">userEvent.click(</span><br><span class="line">within(screen.getByText(<span class="string">&quot;Learn about React&quot;</span>)).getByTestId(<span class="string">&#x27;remove-todo&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//then</span></span><br><span class="line">expect(screen.getAllByTestId(<span class="string">&quot;todo-item&quot;</span>)).toHaveLength(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="检测-toggleTodo"><a href="#检测-toggleTodo" class="headerlink" title="检测 toggleTodo"></a>检测 toggleTodo</h3><p>  步骤是先找到第一个默认的 item<br>  使用 within 找到其中的 Complete 按钮<br>  模拟用户点击<br>  期望该默认的 item 能给到 Redo 显示<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">test(<span class="string">&quot;should toggle todo&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//given</span></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br><span class="line"><span class="comment">//when</span></span><br><span class="line"><span class="comment">// 根据名字找到第一个 item</span></span><br><span class="line"><span class="keyword">const</span> firstTodo = within(screen.getByText(<span class="string">&quot;Learn about React&quot;</span>));</span><br><span class="line"><span class="comment">// 模拟用户点击 Complete</span></span><br><span class="line">userEvent.click(firstTodo.getByText(<span class="string">&quot;Complete&quot;</span>));</span><br><span class="line"><span class="comment">//then</span></span><br><span class="line"><span class="comment">// 期望第一个 item 中的 Redo 出现在 dom 中</span></span><br><span class="line">expect(firstTodo.getByText(<span class="string">&quot;Redo&quot;</span>)).toBeInTheDocument();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="测试异步代码"><a href="#测试异步代码" class="headerlink" title="测试异步代码"></a>测试异步代码</h1><p>  如何测试异步代码呢</p><ul><li><code>callback</code> 回调函数的方式<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119113737.png" alt=""><br>这种方式是使用了一个 <code>done</code> 方法来给函数一个断言 告诉 <code>jest</code> 这里是异步终止的地方<br>但是这个方法有一个缺点 就是大量异步回调的时候会产生类似于回调地狱的情况 并且违背了我们之前 given when then 的三段式写法</li><li><code>Promise then</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119113753.png" alt=""><br>这种方式是使用了 <code>promise</code> 的 <code>then</code> 来进行异步结果的判断 但是代码显得很长 而且本质上就是把 <code>done</code> 换成了 <code>then</code>，还是影响了我们对 given when then 的使用<br><code>fetchData</code> 就相当于 when then 就相当于 <code>then</code><br>但我们也可以通过 <code>resolve</code> 和 <code>reject</code> 抽离出结果 单独对他们进行结果的测试</li><li><code>async/await</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119113825.png" alt=""><br>这个 <code>await</code> 的好处就是符合 gwt 的原则 而且代码看上去比较好看<h2 id="最佳实践-MSW-mock-service-worker"><a href="#最佳实践-MSW-mock-service-worker" class="headerlink" title="最佳实践 MSW (mock service worker)"></a>最佳实践 MSW (mock service worker)</h2>msw 可以在浏览器和 api 之间的 service worker 中拦截对应的请求<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><code>yarn add msw</code><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><code>app.tsx</code> 代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line">  <span class="keyword">import</span> React, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line">  <span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">&#x27;https://randomuser.me/api&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> [fullName,setFullName] = useState(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> [loading,setLoading] = useState(<span class="literal">false</span>);</span><br><span class="line">useEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">setLoading(<span class="literal">true</span>);</span><br><span class="line">axios.get(url).then(<span class="function">(<span class="params">&#123;data&#125;</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123;first,last&#125; = data.results[<span class="number">0</span>].name;</span><br><span class="line">setFullName(<span class="string">`<span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>`</span>);</span><br><span class="line">setLoading(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,[]);</span><br><span class="line"><span class="keyword">if</span>(loading)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&#123;</span>&quot;<span class="attr">Type</span> <span class="attr">your</span> <span class="attr">name</span>&quot;&#125; <span class="attr">value</span>=<span class="string">&#123;fullName&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span>=&gt;</span>setFullName(e.target.value)&#125;&gt;<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#123;/_ 要用 span 包起来 _/&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>my name is <span class="tag">&lt;<span class="name">span</span> <span class="attr">data-testid</span>=<span class="string">&quot;full-name&quot;</span>&gt;</span>&#123;fullName&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h3 id="拦截请求"><a href="#拦截请求" class="headerlink" title="拦截请求"></a>拦截请求</h3><p>我们看到 我们借助了这个网址去请求异步的数据渲染到我们页面对应的 input 框内<br>那我们编写测试代码的时候 就要去模拟这个请求<br>我们新建一个 Mock 文件夹 再新建一个 handlers.ts<br>引入 msw 的 rest 这个是他的一个模拟 api 相当于 axios 我们可以拦截这个地址 并把它最后的请求结果修改成我们想要的结果<br>他拥有一个 req 和 res 以及上下文 ctx 这点用法和 express 非常相似<br>这个 handlers 是一个数组 里面可以写很多拦截<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;rest&#125; <span class="keyword">from</span> <span class="string">&#x27;msw&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> handlers = [</span><br><span class="line">rest.get(<span class="string">&quot;https://randomuser.me/api&quot;</span>,<span class="function">(<span class="params">req,res,ctx</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> res(</span><br><span class="line">ctx.status(<span class="number">200</span>),</span><br><span class="line">ctx.json(&#123;</span><br><span class="line"><span class="attr">results</span>:[&#123;</span><br><span class="line"><span class="attr">name</span>:&#123;</span><br><span class="line"><span class="attr">title</span>:<span class="string">&#x27;Mr&#x27;</span>,</span><br><span class="line"><span class="attr">first</span>:<span class="string">&#x27;JOJO&#x27;</span>,</span><br><span class="line"><span class="attr">last</span>:<span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;)</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="建立服务器"><a href="#建立服务器" class="headerlink" title="建立服务器"></a>建立服务器</h3><p>我们有了拦截代码 还需要一个 <code>node</code> 服务器 继续新建一个 <code>server.ts</code><br>引入我们的 <code>handlers</code> 因为他是一个数组 所以可以解构出来 直接使用在 <code>setupServer</code> 中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;setupServer&#125; <span class="keyword">from</span> <span class="string">&#x27;msw/node&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; handlers &#125; <span class="keyword">from</span> <span class="string">&#x27;./handlers&#x27;</span>;</span><br><span class="line"><span class="comment">// 设置一个服务器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> server = setupServer(...handlers)</span><br></pre></td></tr></table></figure></p><p>之后我们要在 setupTest.ts 里面去启动服务器的监听 告诉服务器什么时候开始准备拦截请求</p><h3 id="jest-四个钩子-beforeAll-beforeEach-afterEach-afterAll"><a href="#jest-四个钩子-beforeAll-beforeEach-afterEach-afterAll" class="headerlink" title="jest 四个钩子 beforeAll beforeEach afterEach afterAll"></a>jest 四个钩子 <code>beforeAll</code> <code>beforeEach</code> <code>afterEach</code> <code>afterAll</code></h3><p>这里有四个阶段 <code>beforeAll</code> <code>beforeEach</code> <code>afterEach</code> <code>afterAll</code><br>分别代表全部测试开始前 单个测试开始前 单个测试结束后 全部测试结束后<br>我们对应要做的事情就是在全部测试开始前进行监视 在单个测试结束后重置我们的拦截 在全部测试结束后关闭 server<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jest-dom adds custom jest matchers for asserting on DOM nodes.</span></span><br><span class="line"><span class="comment">// allows you to do things like:</span></span><br><span class="line"><span class="comment">// expect(element).toHaveTextContent(/react/i)</span></span><br><span class="line"><span class="comment">// learn more: https://github.com/testing-library/jest-dom</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@testing-library/jest-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; server &#125; <span class="keyword">from</span> <span class="string">&#x27;./mock/server&#x27;</span>;</span><br><span class="line">beforeAll(<span class="function">()=&gt;</span>server.listen())</span><br><span class="line">afterEach(<span class="function">()=&gt;</span>server.resetHandlers())</span><br><span class="line">afterAll(<span class="function">()=&gt;</span>server.close())</span><br></pre></td></tr></table></figure></p><h3 id="测试拦截的结果是否显示在-dom-中"><a href="#测试拦截的结果是否显示在-dom-中" class="headerlink" title="测试拦截的结果是否显示在 dom 中"></a>测试拦截的结果是否显示在 dom 中</h3><p>我们刚刚写的 <code>mock</code> 结果是 <code>JOJO ABC</code> 所以 <code>setFullName</code> 会把他转为 <code>JOJO ABC</code><br>我们现在就要利用 <code>findByText</code> 这个 api 去正则查找这几个单词是否在 <code>screen</code> 中<br>因为这个 <code>api</code> 是异步的 所以要加 <code>async</code> <code>await</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&quot;should display name from api directly&quot;</span>,<span class="keyword">async</span>()=&gt;&#123;</span><br><span class="line"><span class="comment">//given</span></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>)</span><br><span class="line"><span class="comment">//when</span></span><br><span class="line"><span class="comment">// 找到对应的名字 这个方法是异步方法 所以要 await</span></span><br><span class="line"><span class="keyword">const</span> text = <span class="keyword">await</span> screen.findByText(<span class="regexp">/JOJO ABC/ig</span>);</span><br><span class="line"><span class="comment">//then</span></span><br><span class="line">expect(text).toBeInTheDocument();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="异步修改了初始状态-测试异步后的结果"><a href="#异步修改了初始状态-测试异步后的结果" class="headerlink" title="异步修改了初始状态 测试异步后的结果"></a>异步修改了初始状态 测试异步后的结果</h3><p>做完了上述的测试 发现我们原先的测试代码出错了，这个是因为我们的组件里面已经有了异步的 <code>setState</code><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119114140.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119114146.png" alt=""><br>导致结果发生了变化 所以他找不到这个元素<br>所以我们要使用 <code>findByPlaceholderText</code> 并进行 <code>await</code> 来找到 <code>input</code> 框<br>并通过正则获取对应的测试结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;should show fullName when type&#x27;</span>, <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line"><span class="comment">//given</span></span><br><span class="line"><span class="keyword">const</span> appendText = <span class="string">&#x27;Welcome&#x27;</span>;</span><br><span class="line"><span class="comment">//when  </span></span><br><span class="line"> render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>);</span><br><span class="line"><span class="comment">// 模拟用户行为在输入框上面输入 因为一开始在 setState 里面有异步的操作 所以找不到</span></span><br><span class="line"><span class="comment">// 要使用 findByPlaceholderText 并进行 await 来找到 input 框</span></span><br><span class="line"><span class="keyword">const</span> input = <span class="keyword">await</span> screen.findByPlaceholderText(<span class="string">&#x27;Type your name&#x27;</span>)</span><br><span class="line">userEvent.type(</span><br><span class="line">input,</span><br><span class="line">appendText</span><br><span class="line">)</span><br><span class="line"><span class="comment">//then</span></span><br><span class="line"><span class="comment">//由于我们一开始请求获取了一些人名 所以我们这里要用正则来找到对应的测试结果</span></span><br><span class="line">expect(screen.getByText(<span class="regexp">/Welcome/i</span>).textContent).toMatchInlineSnapshot(<span class="string">`&quot;JOJO ABCWelcome&quot;`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="让-msw-和开发环境共用一套-mock"><a href="#让-msw-和开发环境共用一套-mock" class="headerlink" title="让 msw 和开发环境共用一套 mock"></a>让 msw 和开发环境共用一套 mock</h1><p>我们发现我们在写 <code>msw</code> 的时候需要写一套 <code>mock</code> 但是我们在开发的时候也需要写一套 <code>mock</code><br>这个时候 <code>mock</code> 能不能共用一套呢？<br>答案是可以的<br>先在 <code>mock</code> 文件夹下面编写一个 <code>browser.ts</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setupWorker &#125; <span class="keyword">from</span> <span class="string">&quot;msw&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; handlers &#125; <span class="keyword">from</span> <span class="string">&quot;./handlers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一个 worker</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> worker = setupWorker(...handlers);</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>我们发现和之前的 <code>server</code> 有异曲同工之妙，<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20230119114304.png" alt=""><br>但是 <code>server</code> 是借用了 <code>node</code> 的 属于服务端的 我们这次用的是直接借助于浏览器的<br>然后在 <code>app.tsx</code>中添加以下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">&#x27;development&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">const</span> &#123;worker&#125; = <span class="built_in">require</span>(<span class="string">&#x27;./mock/browser&#x27;</span>);</span><br><span class="line">worker.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>并配置 <code>msw</code><br><code>npx init msw public/ --save</code><br>然后就会看到 <code>public</code> 下面多了个 <code>mockServiceWorker.js</code><br><code>packagejson</code> 里面多了<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;msw&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;workerDirectory&quot;</span>: <span class="string">&quot;public&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>说明已经生成好了 运行项目 会发现请求的值一直是我们 <code>mock</code> 的值<br>所以开发也直接在 <code>handlers.ts</code> 里面去使用 <code>mock</code> 即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="前端进阶" scheme="https://zlinni.github.io/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="单元测试" scheme="https://zlinni.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器地址栏输入url到显示页面的步骤</title>
    <link href="https://zlinni.github.io/posts/1583217180/"/>
    <id>https://zlinni.github.io/posts/1583217180/</id>
    <published>2022-09-15T12:33:14.000Z</published>
    <updated>2022-09-17T07:58:00.699Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>这是一道非常非常经典的面试题，但涉及到的内容非常的广，接下来从小到大逐步分析他所包含的内容</p></div><h1 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a>详细版</h1><ol><li>在浏览器地址栏输入 url(这里可能会问 url 的长度最长是多少，状态码，编码方式，)</li><li>浏览器查看缓存，如果请求资源在缓存中且新鲜，则跳到转码步骤(这里考缓存的形式，新鲜度的计算，缓存的头字段，缓存策略)<br>2.1 如果资源未缓存，发起新请求<br>2.2 如果已缓存，检测是否足够新鲜，足够新鲜提供给客户端，否则与服务器进行验证。</li><li>解析 url 获取协议 端口 主机 path(这里可能会考 https 协议 端口看协议 主机可能和主机托管相关)</li><li>浏览器组装一个 HTTP 请求报文(当然这个不一定是 get 请求，所以可能考各种请求方式，如果是 2 的话还要考流的运输组装)</li><li>浏览器获取主机 ip 地址 过程如下<br>5.1 浏览器本地缓存<br>5.2 本机缓存<br>5.3 hosts 文件(考 host 的话可能考 linux 里面的 host 路径和 windows 下的 host 路径 其实改 host 能解决 github 被墙的原因也是来自于此)<br>5.4 路由器缓存(这个不了解)<br>5.5 ISP DNS 缓存()<br>5.6 DNS 递归查询</li></ol><h1 id="url-最长长度"><a href="#url-最长长度" class="headerlink" title="url 最长长度"></a>url 最长长度</h1><p>关于这个问题其实不同的浏览器规范不一样的，比如 ie 是 2083，chrome8182 等。但最好不要超过 2048 个字符，虽然 ie 被干掉了，但是还是保持 get 请求的 url 短一点吧<br>所以如果后端给批量操作的接口的时候，你就有理由告诉他改成 post 了</p><h1 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h1><p>这块遇到过考察 汉字是多少个字节<br>在 GBK 中，我们的汉字是两个字节，UTF-16 中是两个字节，UTF-8 则是 3 个字节</p><p>这里不讲原理 因为我也不会 当他自己是这么定义的好了</p><p>问题是你知道怎么输出一个字母或者汉字的字节吗</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> enc = <span class="keyword">new</span> TextEncoder();</span><br><span class="line"><span class="built_in">console</span>.log(enc.encode(<span class="string">&quot;哈&quot;</span>).length); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(enc.encode(<span class="string">&quot;1&quot;</span>).length); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(enc.encode(<span class="string">&quot;j&quot;</span>).length); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>使用这个 api 可以返回 utf-8 下面的字节数。其实他本来是可以传入参数的，但目前 mdn 上说被废弃掉了</p><p>有了 encoder 肯定会有 decoder</p><p>下面是我搬运 mdn 的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> utf8decoder = <span class="keyword">new</span> TextDecoder(); <span class="comment">// default &#x27;utf-8&#x27; or &#x27;utf8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">240</span>, <span class="number">160</span>, <span class="number">174</span>, <span class="number">183</span>]);</span><br><span class="line"><span class="keyword">let</span> i8arr = <span class="keyword">new</span> <span class="built_in">Int8Array</span>([-<span class="number">16</span>, -<span class="number">96</span>, -<span class="number">82</span>, -<span class="number">73</span>]);</span><br><span class="line"><span class="keyword">let</span> u16arr = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>([<span class="number">41200</span>, <span class="number">47022</span>]);</span><br><span class="line"><span class="keyword">let</span> i16arr = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([-<span class="number">24336</span>, -<span class="number">18514</span>]);</span><br><span class="line"><span class="keyword">let</span> i32arr = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([-<span class="number">1213292304</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(utf8decoder.decode(u8arr)); <span class="comment">//𠮷</span></span><br><span class="line"><span class="built_in">console</span>.log(utf8decoder.decode(i8arr)); <span class="comment">//𠮷</span></span><br><span class="line"><span class="built_in">console</span>.log(utf8decoder.decode(u16arr)); <span class="comment">//𠮷</span></span><br><span class="line"><span class="built_in">console</span>.log(utf8decoder.decode(i16arr)); <span class="comment">//𠮷</span></span><br><span class="line"><span class="built_in">console</span>.log(utf8decoder.decode(i32arr)); <span class="comment">//𠮷</span></span><br></pre></td></tr></table></figure><p>这个看一看就好了 平时可能就不太会用到</p><h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p>说到这个状态码 url 超出服务器限制的时候返回的是 414(URI Too Long)</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>缓存这块涉及的知识点就很多了，主要分为强缓存和协商缓存。</p><h2 id="强缓存是什么呢？"><a href="#强缓存是什么呢？" class="headerlink" title="强缓存是什么呢？"></a>强缓存是什么呢？</h2><p>指的是该缓存在存在的期间不需要发送请求，会返回状态码 200 且告诉你是 memoryCache 还是 diskCache</p><p>memoryCache指的是资源存在内存中，当页面被关闭就会释放<br>diskCache指的是资源存在磁盘中</p><p>至于这两者什么时候是 memoryCache 什么时候是 diskCache 取决于浏览器</p><p>参考网上的一个表格，chrome浏览器对于cache的统计<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220917115135.png" alt=""></p><p>一般样式就存在disk，但是js这类的就存在memory，因为从磁盘读脚本对IO的开销比较大</p><h2 id="浏览器中查看的方式："><a href="#浏览器中查看的方式：" class="headerlink" title="浏览器中查看的方式："></a>浏览器中查看的方式：</h2><p>先把停用缓存/disable cache关掉 然后ctrl+r刷新你的页面 这里拿掘金为例子 可以看见缓存中memoryCache和diskCache都有<br>memoryCache<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220917105130.png" alt=""></p><p>diskCache<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220917105300.png" alt=""></p><p>没走缓存 要下载的资源，注意了噢 如果是200 则是资源的大小 如果是304则是报文的大小<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220917105328.png" alt=""></p><h2 id="强缓存怎么触发呢？"><a href="#强缓存怎么触发呢？" class="headerlink" title="强缓存怎么触发呢？"></a>强缓存怎么触发呢？</h2><p>这块涉及到头字段:<code>Expires</code>和<code>Cache-Control:max-age</code></p><p>首先前者 来自于 http1.0 其中的值是一个 GMT 格式字符串 代表缓存过期时间</p><p>eg</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Oct <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure><p>设置的方式也很简单：<br>(不同框架实现不一样 随便写个例子)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.set(<span class="string">&quot;Expires&quot;</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">30000</span>).toUTCString());<span class="comment">//当前时间+30s</span></span><br></pre></td></tr></table></figure></p><h2 id="expires的缺点"><a href="#expires的缺点" class="headerlink" title="expires的缺点"></a>expires的缺点</h2><p>受限于本地时间 修改本地时间可能导致缓存失败</p><h2 id="Cache-Control-max-age"><a href="#Cache-Control-max-age" class="headerlink" title="Cache-Control:max-age"></a><code>Cache-Control:max-age</code></h2><p>1.1提出的规范</p><p>优先级高于Expires，且设置的是秒数，前者是毫秒数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.set(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;max-age=30&#x27;</span>)</span><br></pre></td></tr></table></figure><p>cachecontrol除了是设置maxage之外还有别的value<br>可以连起来写 </p><ul><li><code>private</code>：客户端可以缓存</li><li><code>public</code>：客户端和代理服务器都可以缓存</li><li><code>s-maxage</code>：和max-age一样，但这个是设定代理服务器的缓存时间</li><li><code>no-cache</code>：需要使用协商缓存来验证缓存数据</li><li><code>no-store</code>：所有内容都不会缓存</li></ul><p>注意经常考的是 <code>no-store</code>和<code>no-cache</code>的区别，这个要牢记</p><p>除此之外 如果是采用了CDN的形式 但是有些内容不想放在CDN上，比如一些敏感信息 此时采用private更加合适 只有客户端才能缓存</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>这块的话 分两个字段：<code>Last-Modified</code>,<code>If-Modified-Since</code><br><code>Last-modified</code>是服务端返回给客户端携带的头字段<br><code>If-Modified-Since</code>是客户端请求的头字段</p><p>先从字面上去理解字段的意思：前者是最后一次操作(资源)，后者是如果有操作(资源)的话，则从操作(资源)之后发送新的(资源)</p><p>前者的值是资源最后的更新时间，后者的值是前者的值。</p><p>过程是这样的：<br>首先有一个txt文件，前端请求后端返回，返回的过程携带了<code>Last-modified</code>响应头，值是这个txt文件最后一次修改的时间</p><p>然后前端接收到了，再次请求该txt文件，请求的时候带上(这一步是浏览器帮你带的不需要自己带)<code>If-Modified-Since</code>字段，值是<code>Last-modified</code>的值，到后端 后端会去验证 该请求字段的值是否和txt文件最后一次修改的时间一致，如果一致，说明txt文件没改，没改的话则返回304。且不会返回<code>Last-modified</code><br>和资源内容</p><p>上一段来自掘金的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文件信息</span></span><br><span class="line"><span class="keyword">const</span> getFileStat = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.stat(path, <span class="function">(<span class="params">_, stat</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(stat)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = ctx.request.url</span><br><span class="line">  <span class="keyword">if</span> (url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 访问根路径返回index.html</span></span><br><span class="line">    ctx.set(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)</span><br><span class="line">    ctx.body = <span class="keyword">await</span> parseStatic(<span class="string">&#x27;./index.html&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> filePath = path.resolve(__dirname, <span class="string">`.<span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">const</span> ifModifiedSince = ctx.request.header[<span class="string">&#x27;if-modified-since&#x27;</span>]</span><br><span class="line">    <span class="keyword">const</span> fileStat = <span class="keyword">await</span> getFileStat(filePath)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(fileStat.mtime).getTime())</span><br><span class="line">    ctx.set(<span class="string">&#x27;Cache-Control&#x27;</span>, <span class="string">&#x27;no-cache&#x27;</span>)</span><br><span class="line">    ctx.set(<span class="string">&#x27;Content-Type&#x27;</span>, parseMime(url))</span><br><span class="line">    <span class="comment">// 比对时间，mtime为文件最后修改时间</span></span><br><span class="line">    <span class="comment">// 如果时间不变则返回304，且不携带`Last-Modified`和资源文件</span></span><br><span class="line">    <span class="keyword">if</span> (ifModifiedSince === fileStat.mtime.toGMTString()) &#123;</span><br><span class="line">      ctx.status = <span class="number">304</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.set(<span class="string">&#x27;Last-Modified&#x27;</span>, fileStat.mtime.toGMTString())</span><br><span class="line">      ctx.body = <span class="keyword">await</span> parseStatic(filePath)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="Last-modified的缺点"><a href="#Last-modified的缺点" class="headerlink" title="Last-modified的缺点"></a><code>Last-modified</code>的缺点</h2><p>其实lastmodify本身也有缺点，就是他主要区分的话还是在于文件的修改时间的一个对比</p><p>假设我们有一个txt文件里面有一个字符串jojo，此时修改的时间是a</p><p>那么我把txt里面的jojo去掉 保存之后 又重新添加回去 再保存 此时修改的时间变成了b</p><p>按正常人的思路肯定是期望这个资源还能被缓存，因为内容没有发生变化，这样一个周期性的变化，<code>Last-modified</code>是检测不了的，因为修改的时间变了</p><p>再说另外一个缺点<br>文件修改时间这个值本身返回的是秒，要是我的内容本身小于单位秒，比如几毫秒内修改了，那么依旧也是检测不到的</p><h2 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h2><p>所以出现了另外一个终极方案叫Etag，他是借由文件的内容生成的hash值，这样就能保证资源周期性和唯一性，然后Etag也是后端发来的，前端再次请求会携带一个<code>If-None-Match</code>。</p><p>也就是只要记得他是通过文件内容生成hash值就行了，他的优先级比lastmodify高，他的校验方式和lastmodify是一样的</p><h1 id="待补充的："><a href="#待补充的：" class="headerlink" title="待补充的："></a>待补充的：</h1><p>这一块还有的内容是新鲜度的计算，启发式缓存，代理缓存，客户端的代理宽容限制等</p><h1 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h1><p>s指的是TLS/SSL证书 以前是叫做SSL，现在还是叫TLS好一点点，和http的区别如下:(老生常谈)<br>首先是钱 https要申请CA证书，画的比较多，但安全，http纯白嫖<br>安全性上面 https加密传输，http明文<br>端口 https是443端口 http是80</p><p>这块涉及到的内容有很多 一个是TLS1.2和1.3的握手方式。OSI七层模型。数字签名，CA证书，安全问题(中间人)，对称加密非对称加密，</p><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>先简单的说一下OSI七层模型，这块经常忘记，实际上它是一个可以展开描述的重点内容</p><p>七层分别是应用层，表示层，会话层，传输层，网络层，数据链路层，物理层</p><p>图片来自网络：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220917150035.png" alt=""></p><p>首先应用层是为了提供给用户接口或者说网络服务，所以在这一层里面自然的就是一些网络服务协议<br>可能比较陌生的协议提一嘴：telnet，它是TCP/IP协议中的一员，用于处理远程登陆服务这块的；SNMP协议全称Simple Network Management Protocol简单网络管理协议,它们提供了一种从网络上的设备中收集网络管理信息的方法,简单来说它就是收集信息的</p><p>表示层这块是为了给上述的应用层提供一个数据格式服务转换的功能让对方的应用层能够理解，也就是它类似于生活中的翻译官，需要给对方的应用层做一个翻译，或者说它是一个电报员需要发加密的电报防止中间人窃取这样。主要就是加密解密，编码解码。但其实压缩和解压缩也是在这块的需要注意。</p><p>会话层这块是为了给上述表示层做一个通信处理的，首先它会建立一个会话连接，然后去验证对方是否是自己这边的人，然后把我方表示层的资料包装起来给到下面的传输层去传输，确定了传输完成之后会话就会终止。<br>会话层主要的作用就是集中管理这些会话，过程中有一些常见的场景比如验证登陆，断点续传。</p><p>传输层就是把上述会话层封装好的表示层资料给传输到对方，TCP和UDP就是常见的传输协议，在这一层里面还要负责处理一些数据包的错误。</p><p>网络层呢，其实就是一个IP层，它通过ip寻址来建立两个节点的连接，为上述传输层的数据选择一个合适的路由和交换节点，正确无误的按照地址传送给对方的传输层。传输层和网络层就相当于快递员和快递中心的关系</p><p>数据链路层和物理层就不太展开介绍了涉及到的东西很多</p><h2 id="数字签名-CA证书"><a href="#数字签名-CA证书" class="headerlink" title="数字签名 CA证书"></a>数字签名 CA证书</h2><p>数字签名是公钥加一些个人信息用哈希算法生成摘要之后，再用私钥加密生成的东西。<br>数字证书应用了数字签名的技术，将个人信息和公钥用哈希算法生成摘要之后，再用CA的私钥加密，这整个就是数字证书。</p><h2 id="TLS1-2和1-3的握手方式"><a href="#TLS1-2和1-3的握手方式" class="headerlink" title="TLS1.2和1.3的握手方式"></a>TLS1.2和1.3的握手方式</h2><h3 id="TLS1-2握手"><a href="#TLS1-2握手" class="headerlink" title="TLS1.2握手"></a>TLS1.2握手</h3><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220413091420.png" alt=""></p><h4 id="step1：Client-Hello"><a href="#step1：Client-Hello" class="headerlink" title="step1：Client Hello"></a>step1：Client Hello</h4><p>首先浏览器发送client_random,TLS版本，加密套件列表。</p><p>client_random是什么？用来形成最终secret的一个参数</p><p>加密套件列表是什么？eg<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TLS_ECDHE_WITH_AES_128_GCM_SHA256</span><br></pre></td></tr></table></figure></p><p>意思是在TLS握手的过程中，使用ECDHE算法pre_random,128位的AES算法进行对称加密，在对称加密的过程中使用主流的GCM分组模式，因为对称加密中很重要的一个问题就是如何分组，最后一个是采用哈希摘要算法，采用SHA256算法。</p><p>其中值得解释的是这个哈希摘要算法，试想一下这个场景，服务端现在给客户端发信息来了，而客户端不知道此时的消息是服务端的还是中间人的，现在引入这个哈希摘要算法，将服务端的证书信息通过这个算法生成一个摘要，用来标识这个服务器的身份，然后用CA私钥加密后把加密后的标识和CA公钥发给客户端。客户端拿到这个CA公钥来解密，生成另外一份摘要。两个摘要进行对比，如果相同则能确认服务器的身份。这也就是所谓数字签名的原理。其中除了哈希摘要算法，最重要的是私钥加密，公钥解密。</p><h4 id="step2-Server-Hello"><a href="#step2-Server-Hello" class="headerlink" title="step2 Server Hello"></a>step2 Server Hello</h4><p>server_random发送这个随机数，确认TLS版本，需要使用的加密套件和自己的证书，那么这个server_params是做什么的呢？</p><h4 id="step3-Client验证证书，生成secret"><a href="#step3-Client验证证书，生成secret" class="headerlink" title="step3 Client验证证书，生成secret"></a>step3 Client验证证书，生成secret</h4><p>客户端验证服务器传过来的证书和签名是否通过，如果验证通过，则将client_params传递给服务器。</p><p>接着客户端通过ECDHE算法计算出了pre_random,其中传入两个参数：server_params和client_params。现在你应该清楚这两个参数的作用了吧，由于ECDHE算法是基于椭圆曲线离散对数，这两个参数也称作椭圆曲线的公钥。</p><p>客户端现在拥有了client_random,server_random和pre_random,接下来这三个数通过一个伪随机数函数计算出最终的secret</p><h4 id="step4-Server生成secret"><a href="#step4-Server生成secret" class="headerlink" title="step4 Server生成secret"></a>step4 Server生成secret</h4><p>客户端传了client_params过来了，服务端开始用ECDHE算法生成pre_random,接着用和客户端同样的伪随机函数生成最后的secret</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><div class="note primary flat"><p>TLS握手实际上是一个双向认证的过程，从step1可以看出客户端有能力验证服务器的身份（数字签名），那么服务器能不能验证客户端的身份呢？</p></div><p>当然是可以的。具体来说，在step3中，客户端发送client_params,实际上是给服务器一个验证消息，让服务器走相同的流程（哈希摘要，私钥加密，公钥解密），确认客户端的身份</p><div class="note primary flat"><p>在客户端生成secret后，会给服务器发送一个收尾的信息，告诉服务器之后都要用对称加密，对称加密的算法就是用第一次约定的，服务器生成完secret后也会向客户端发送一个收尾信息，告诉客户端以后用对称加密来通信。</p></div><p>这个收尾信息包括两个部分，一部分是<code>Change Cipher Spec</code>,意味着后面加密传输了，另外一个是Finished消息，这个消息是对之前发送的所有数据做的摘要，对摘要进行加密，让对方验证一下。</p><p>当双方都验证通过之后，握手才正式结束，后面的HTTP正式开始传输加密报文。</p><h2 id="什么是中间人攻击？"><a href="#什么是中间人攻击？" class="headerlink" title="什么是中间人攻击？"></a>什么是中间人攻击？</h2><p>中间人攻击(Man-in-the-MiddleAttack，简称“MITM攻击”)是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方 直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻 击中，攻击者可以拦截通讯双方的通话并插入新的内容。中间人攻击是一个(缺乏)相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信 任的数字证书认证机构颁发，并且能执行双向身份认证。<br>中间人攻击过程 1客户端发送请求到服务端，请求被中间人截获。<br>2)服务器向客户端发送公钥。<br>3)中间人截获公钥，保留在自己手上。然后自己生成一个【伪 造的】公钥，发给客户端。<br>4)客户端收到伪造的公钥后，生成加密hash值发给服务器。<br>5)中间人获得加密hash值，用自己的私钥解密获得真秘钥。同时生成假的加密hash值，发给服务器。<br>6 ) 服务器用私钥解密获得假密钥。然后加密数据传输给客户端。</p><h1 id="hosts"><a href="#hosts" class="headerlink" title="hosts"></a>hosts</h1><p>window下：<code>C:\windows\system32\drivers\etc。</code></p><p>host文件的作用：<br>作用1. 加快域名解析作用<br>我们会经常访问网站，那么我们则可以通过hosts文件来配置域名以及IP之间的关系，提高域名解析速度。这主要是因为两者之间的映射关系，简单来说就是我们输入域名计算机就能很快解析出IP。而不是在网络上请求服务器。</p><p>作用2.方便局域网用户<br>在很多的局域网中，我们会有很多的服务器提供给用户进行使用。而在局域网中是缺少DNS服务器的，那么输入进去的IP地址就很难记住。hosts文件则是能够有效减少这样的麻烦，方便用户使用。</p><p>作用3.屏蔽网站<br>在很多的网站中，我们会看见很多没有经过用户同意就安装上去的插件。在这些插件中存在木马病毒的可能性很大，使用hosts文件可以将错误IP映射到本地IP之中，将网站屏蔽。</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="DNS-1"><a href="#DNS-1" class="headerlink" title="DNS"></a>DNS</h2><div class="note primary flat"><p>DNS的作用就是通过域名查询到IP</p></div><p>因为IP存在数字和英文的组合IPv6，很不利于人类记忆，所以出现了域名。你可以把域名看成某个IP的别名，DNS就是去查询这个别名真正的名称是什么</p><div class="note primary flat"><p>在TCP握手之前就已经进行了DNS查询，这个查询是操作系统自己完成的，当在浏览器中想访问<code>www.google.com</code>会进行以下操作。</p></div><ul><li>本地客户端向服务器发起请求查询 IP 地址</li><li>查看浏览器有没有该域名的 IP 缓存</li><li>查看操作系统有没有该域名的 IP 缓存</li><li>查看 Host 文件有没有该域名的解析配置</li><li>如果这时候还没得话，会通过直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器</li><li>然后去该服务器查询 google.com 这个二级域名</li><li>接下来查询 www.google.com 这个三级域名的地址</li><li>返回给 DNS 客户端并缓存起来</li></ul><div class="note primary flat"><p>以上介绍的是DNS迭代查询，还有一种是递归查询，区别是前者是由客户端去请求，后者是由系统配置的DNS去请求，得到结果之后将数据返回给客户端。</p></div><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220414083618.png" alt=""></p><h3 id="DNS解析优化"><a href="#DNS解析优化" class="headerlink" title="DNS解析优化"></a>DNS解析优化</h3><p>主要分为两个方案</p><ul><li>DNS预解析</li><li>减少DNS请求</li></ul><h3 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h3><div class="note primary flat"><p>DNS解析也需要时间的，可以通过预解析的方式来预先获取域名所对应的IP</p></div><p>link方式：手动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//blog.poetries.top&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>meta方式：https自动解析<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><br>设置响应头：自动解析<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.set(<span class="string">&#x27;X-DNS-Prefetch-Control&#x27;</span>, <span class="string">&#x27;on&#x27;</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试指南" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>感受正则之美</title>
    <link href="https://zlinni.github.io/posts/2097459314/"/>
    <id>https://zlinni.github.io/posts/2097459314/</id>
    <published>2022-09-10T02:13:08.000Z</published>
    <updated>2022-09-12T04:13:10.636Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>之前对正则的理解一直是半懂不懂，现在和houdunren学一波正则。本篇是js正则相关的案例与细节学习笔记</p><p>十分建议配套quokka使用,是vscode一个显示代码实时结果的一个插件,非常方便.</p><p>学习笔记GitHub仓库:<a href="">传送门</a></p></div><h1 id="取出数字"><a href="#取出数字" class="headerlink" title="取出数字"></a>取出数字</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出数字</span></span><br><span class="line"><span class="comment">// case: jojo123jojo321</span></span><br><span class="line"><span class="comment">// 正常写法：</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="string">&quot;jojo123jojo321&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num = [...test].filter(<span class="function"><span class="params">n</span>=&gt;</span>!<span class="built_in">Number</span>.isNaN(<span class="built_in">parseInt</span>(n)));</span><br><span class="line"><span class="built_in">console</span>.log(num.join(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则写法</span></span><br><span class="line"><span class="built_in">console</span>.log(test.match(<span class="regexp">/\d/g</span>).join(<span class="string">&#x27;&#x27;</span>))</span><br></pre></td></tr></table></figure><h1 id="字面量创建正则-存放变量"><a href="#字面量创建正则-存放变量" class="headerlink" title="字面量创建正则/存放变量"></a>字面量创建正则/存放变量</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面量创建正则</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="string">&quot;jojo123jojo321&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/o/</span>.test(test))</span><br><span class="line"></span><br><span class="line"><span class="comment">//字面量中放变量</span></span><br><span class="line"><span class="keyword">let</span> useO = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">`/<span class="subst">$&#123;useO&#125;</span>/`</span>).test(test))</span><br></pre></td></tr></table></figure><h1 id="对象创建正则"><a href="#对象创建正则" class="headerlink" title="对象创建正则"></a>对象创建正则</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="string">&quot;jojolin&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;lin&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(a, <span class="string">&quot;g&quot;</span>); <span class="comment">//g代表全局</span></span><br><span class="line"><span class="comment">//是否包含某个字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(test));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// replace 后面也可以根一个函数自定义替换</span></span><br><span class="line">test = test.replace(<span class="regexp">/\w/g</span>,<span class="function">(<span class="params">str</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;dio&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(test)</span><br></pre></td></tr></table></figure><h1 id="选择符"><a href="#选择符" class="headerlink" title="选择符"></a>选择符</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="string">&quot;jojolin&quot;</span>;</span><br><span class="line"><span class="comment">// | 表示或</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/j|k/</span>.test(test))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tel = <span class="string">&#x27;010-9999999&#x27;</span></span><br><span class="line"><span class="keyword">let</span> tel2 = <span class="string">&#x27;010&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/(010|020)\-\d&#123;7,8&#125;/</span>.test(tel))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/(010|020)\-\d&#123;7,8&#125;/</span>.test(tel2))</span><br></pre></td></tr></table></figure><h1 id="原子表和原子组"><a href="#原子表和原子组" class="headerlink" title="原子表和原子组"></a>原子表和原子组</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原子表和原子组</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/[123456]/</span></span><br><span class="line"><span class="keyword">let</span> hd = <span class="string">&#x27;123123&#x27;</span></span><br><span class="line"><span class="comment">// 原子表 [] 表示任选里面的其中一个/多选一 注意只能选一</span></span><br><span class="line"><span class="built_in">console</span>.log(hd.match(reg))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子组 () 整体正则</span></span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="regexp">/(12|34)/</span>;<span class="comment">//表示12是一个整体或者34是一个整体</span></span><br><span class="line"><span class="built_in">console</span>.log(hd.match(reg2))</span><br></pre></td></tr></table></figure><h1 id="正则表达式中的转义"><a href="#正则表达式中的转义" class="headerlink" title="正则表达式中的转义"></a>正则表达式中的转义</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正则表达式中的转义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> price = <span class="number">23.34</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .有两层含义 优先级最高的：除换行外所有字符 正常：普通的点</span></span><br><span class="line"><span class="comment">// 所以我们需要对.进行转义</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d+\.\d+/</span>.test(price))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象里面就又不一样了,需要多一层转义 建议先看看对应字符串转出来是否和字面量相同</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;\\d+\\.\\d+&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(str)</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(price)) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配是否合法网站</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;https://www.baidu.com&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^https?:\/\/\w+\.\w+\.\w+/</span>.test(url))</span><br></pre></td></tr></table></figure><h1 id="字符边界约束"><a href="#字符边界约束" class="headerlink" title="字符边界约束"></a>字符边界约束</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符边界约束</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">// ^匹配以x开头的 $匹配以x结束的 \d匹配单个数字</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^\d$/</span>.test(test))</span><br><span class="line"><span class="comment">// 上面有个坑点就是\d只匹配一个数字 需要使用\d+</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^\d+$/</span>.test(test))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//案例 使得字符串满足3-6位是字母且只有3-6位</span></span><br><span class="line"><span class="keyword">const</span> reg  = <span class="regexp">/^[a-z]&#123;3,6&#125;$/</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;&#x27;</span>.match(reg))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>.match(reg))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ab&#x27;</span>.match(reg))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc&#x27;</span>.match(reg))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abcd&#x27;</span>.match(reg))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abcde&#x27;</span>.match(reg))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abcdef&#x27;</span>.match(reg))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abcdefg&#x27;</span>.match(reg))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以得出 限定的情况下 就使用开头符和结束符号,顺便这里复习一下原子表 是多选1 </span></span><br></pre></td></tr></table></figure><h1 id="数值与空白元字符"><a href="#数值与空白元字符" class="headerlink" title="数值与空白元字符"></a>数值与空白元字符</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数值与空白元字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配中文除外的所有字符</span></span><br><span class="line"><span class="keyword">let</span> hd = <span class="string">`</span></span><br><span class="line"><span class="string">    张三:010-9999999,李四:020-99999999</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面讲到的\d 其实是匹配0-9的数字 \d+是匹配多个这样的数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// \D 则相反 是匹配所有的非数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次复习一下 我们想用正则取出东西 可以使用match 会把匹配的结果返回数组回来 或者replace去掉不想要的 再或者exec逐个匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为我们不知道怎么直接匹配中文 所以这里把除了中文之外的排除也能拿到中文</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// \s 表示匹配到空白 \n这种也算空白</span></span><br><span class="line"><span class="comment">// ^在原子表里面是非的意思 也就是不要这里面任意一个</span></span><br><span class="line"><span class="built_in">console</span>.log(hd.match(<span class="regexp">/[^\d,:-\s]+/g</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="w与W元字符"><a href="#w与W元字符" class="headerlink" title="w与W元字符"></a>w与W元字符</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// w与W元字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// \w 表示字母数字下划线 已经囊括了\d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现邮箱匹配</span></span><br><span class="line"><span class="keyword">let</span> email = <span class="string">&#x27;9813123123@qq.com&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(email.match(<span class="regexp">/^\w+@\w+\.\w+$/</span>));</span><br></pre></td></tr></table></figure><h1 id="点元字符的使用"><a href="#点元字符的使用" class="headerlink" title="点元字符的使用"></a>点元字符的使用</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点元字符的使用</span></span><br><span class="line"><span class="comment">// 因为.只能匹配除了换行符的 也就是遇到换行他就停止了，那么在模板的这个情况下是走不通的</span></span><br><span class="line"><span class="comment">// 使用 /s 视为单行匹配，就可以了</span></span><br><span class="line"><span class="keyword">let</span> hd = <span class="string">`</span></span><br><span class="line"><span class="string">    jojo</span></span><br><span class="line"><span class="string">    jojolin</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="built_in">console</span>.log(hd.match(<span class="regexp">/.+/</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">console</span>.log(hd.match(<span class="regexp">/.+/</span>s))</span><br></pre></td></tr></table></figure><h1 id="匹配所有字符"><a href="#匹配所有字符" class="headerlink" title="匹配所有字符"></a>匹配所有字符</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有字符</span></span><br><span class="line"><span class="keyword">let</span> hd = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;span&gt;</span></span><br><span class="line"><span class="string">        jojolin @abc</span></span><br><span class="line"><span class="string">        @@@cajsocj    </span></span><br><span class="line"><span class="string">    &lt;/span&gt;</span></span><br><span class="line"><span class="string">`</span>   </span><br><span class="line"><span class="comment">// [\s\S]表示所有字符 当然[\d\D]也是</span></span><br><span class="line"><span class="built_in">console</span>.log(hd.match(<span class="regexp">/&lt;span&gt;[\s\S]+&lt;\/span&gt;/</span>))</span><br></pre></td></tr></table></figure><h1 id="模式修正符gi"><a href="#模式修正符gi" class="headerlink" title="模式修正符gi"></a>模式修正符gi</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式修正符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /i忽略大小写 /g全局匹配 /gi 模式组合</span></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;jojoJOJOJO&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/o/gi</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line"><span class="built_in">console</span>.log(text.replace(<span class="regexp">/o/gi</span>,<span class="string">&#x27;?&#x27;</span>))</span><br></pre></td></tr></table></figure><h1 id="模式修正符m"><a href="#模式修正符m" class="headerlink" title="模式修正符m"></a>模式修正符m</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hd = <span class="string">`</span></span><br><span class="line"><span class="string">    #1 js,200元 #</span></span><br><span class="line"><span class="string">    #2 php,300元 #</span></span><br><span class="line"><span class="string">    #55 houdunren.com # 后盾人</span></span><br><span class="line"><span class="string">    #56 nodejs,180元 #</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="comment">// 模式m修正符将多行中每一行单独看待 </span></span><br><span class="line"><span class="comment">// 不用m的话 这个语法 使用.会匹配到# 然后\s+#会匹配到下一行的# 很明显不是想要的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(hd.match(<span class="regexp">/\s*#\d+\s+.+\s+#/g</span>));</span><br><span class="line"><span class="comment">// 使用m后</span></span><br><span class="line"><span class="built_in">console</span>.log(hd.match(<span class="regexp">/^\s*#\d+\s+.+\s+#$/gm</span>));</span><br><span class="line"><span class="keyword">let</span> lessons = hd.match(<span class="regexp">/^\s*#\d+\s+.+\s+#$/gm</span>).map(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  v = v.replace(<span class="regexp">/^\s*#\d+\s+/</span>, <span class="string">&quot;&quot;</span>).replace(<span class="regexp">/\s#$/</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">  <span class="keyword">let</span> [name,price] = v.split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,price</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(lessons,<span class="literal">null</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h1 id="模式修正符u"><a href="#模式修正符u" class="headerlink" title="模式修正符u"></a>模式修正符u</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模式u unicode</span></span><br><span class="line"><span class="comment">// 每个字符都有相应的属性去区分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里虽然不是很懂 但是有几个例子 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;jojostoneocean2022.,&#125;[com笑死我了哈哈哈&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检测字符的属性为字母的情况 (中文也加进去了？？)</span></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/\p&#123;L&#125;/gu</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测标点符号</span></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/\p&#123;P&#125;/gu</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//检测中文</span></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/\p&#123;sc=Han&#125;/gu</span>))</span><br></pre></td></tr></table></figure><h1 id="lastIndex属性的使用"><a href="#lastIndex属性的使用" class="headerlink" title="lastIndex属性的使用"></a>lastIndex属性的使用</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lastIndex属性的使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;jojo&#x27;</span></span><br><span class="line"><span class="comment">//正常这样操作会得到匹配字符的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/\w/</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//加了g全匹配之后 就丢失了相关属性</span></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/\w/g</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用exec</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\w/g</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个属性会有一个index 每次执行的时候index就会+1 直到走完</span></span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/\w/g</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以我们使用循环</span></span><br><span class="line"><span class="keyword">while</span>((res = reg2.exec(text)))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(res) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意exec只有在全模式g的情况下 才会逐个搜索 </span></span><br><span class="line"><span class="keyword">const</span> reg3 = <span class="regexp">/\w/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg3.lastIndex)</span><br><span class="line"><span class="built_in">console</span>.log(reg3.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg3.lastIndex)</span><br><span class="line"><span class="built_in">console</span>.log(reg3.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg3.lastIndex)</span><br><span class="line"><span class="built_in">console</span>.log(reg3.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg3.lastIndex)</span><br><span class="line"><span class="built_in">console</span>.log(reg3.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg3.lastIndex)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意reg在最后一个搜索完之后又会开始重新搜索</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结 exec就是一个可重新执行的迭代器</span></span><br></pre></td></tr></table></figure><h1 id="有效率的y模式"><a href="#有效率的y模式" class="headerlink" title="有效率的y模式"></a>有效率的y模式</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效率的y模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看个例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;asdasdasdas的,213123123,33333,asdasd&#x27;</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/\d/g</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(text))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模式g会使得整个需要匹配的字符串都走下去，假设我只需要取出里面的某段连续数字，然后后面又没有连续数字，使用m性能上就不太好</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以诞生了个模式y，匹配不到就返回null 后面就不匹配了</span></span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/(\d+,?)/y</span></span><br><span class="line">reg2.lastIndex = <span class="number">13</span></span><br><span class="line"><span class="keyword">while</span>((res=reg2.exec(text)))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实也有弊端 也就是y模式依赖于lastIndex 得事先知道他在哪里才行</span></span><br></pre></td></tr></table></figure><h1 id="原子表原子组-新使用"><a href="#原子表原子组-新使用" class="headerlink" title="原子表原子组 新使用"></a>原子表原子组 新使用</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子表 新使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给个具体案例如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="string">&#x27;2022-01-22&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求date可以是-连接也可以是/连接 但是前后的符号必须一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="string">&#x27;2022/01/22&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> date3 = <span class="string">&#x27;2022-01/22&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里注意的是/需要转义</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/^\d&#123;4&#125;[-\/]\d&#123;2&#125;[-\/]\d&#123;2&#125;/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(date))</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(date2))</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(date3))</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据结果我们发现date3 这个情况也被匹配了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写reg 使用原子组加原子表</span></span><br><span class="line"><span class="keyword">const</span> reg2 = <span class="regexp">/^\d&#123;4&#125;([-\/])\d&#123;2&#125;\1\d&#123;2&#125;/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg2.exec(date))</span><br><span class="line"><span class="built_in">console</span>.log(reg2.exec(date2))</span><br><span class="line"><span class="built_in">console</span>.log(reg2.exec(date3))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原理是原子组里面的东西是一个整体 后续用\1表示采用之前的结果 所以前后一致才满足</span></span><br></pre></td></tr></table></figure><h1 id="区间匹配"><a href="#区间匹配" class="headerlink" title="区间匹配"></a>区间匹配</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实之前用过了 注意的点是 区间匹配不能降序 只能升序</span></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;213123jojoj&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/[0-9]/g</span>));</span><br><span class="line"><span class="comment">// console.log(text.match(/[9-0]/g));</span></span><br></pre></td></tr></table></figure><h1 id="排除匹配"><a href="#排除匹配" class="headerlink" title="排除匹配"></a>排除匹配</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排除匹配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;张三:010-9999999;李四:020-9999999&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/[^\d\-:;]+/g</span>))</span><br></pre></td></tr></table></figure><h1 id="原子表字符不解析"><a href="#原子表字符不解析" class="headerlink" title="原子表字符不解析"></a>原子表字符不解析</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子表字符不解析</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;(jo-jo).+&#x27;</span></span><br><span class="line"><span class="comment">//原子组在外面才是原子组,在原子表里面是括号的意思</span></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/[()]/g</span>))</span><br><span class="line"><span class="comment">// .+在原子表里面也是单一的含义 就是本身的意思 不需要转义</span></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/[.+]/g</span>))</span><br><span class="line"><span class="comment">// 直接用- 本身他有两个意思 一个是-自身 一个是区间匹配 正常情况下我们会转义-来保证他是第一层意思</span></span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/[-]/g</span>))</span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/[\-]/g</span>))</span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/[j\-]/g</span>))</span><br><span class="line"><span class="built_in">console</span>.log(text.match(<span class="regexp">/[a-z]/g</span>))</span><br></pre></td></tr></table></figure><h1 id="案例删除dom元素"><a href="#案例删除dom元素" class="headerlink" title="案例删除dom元素"></a>案例删除dom元素</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除dom元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 案例</span></span><br><span class="line"><span class="keyword">let</span> dom = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h1&gt;</span></span><br><span class="line"><span class="string">        jojo</span></span><br><span class="line"><span class="string">    &lt;/h1&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">let</span> dom2 = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;H3&gt;</span></span><br><span class="line"><span class="string">    &lt;/H3&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/&lt;(h[1-6])&gt;[\s\S]*&lt;\/\1&gt;/gi</span></span><br><span class="line"><span class="built_in">console</span>.log(dom.replace(reg,<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(dom2.replace(reg,<span class="string">&#x27;&#x27;</span>))</span><br></pre></td></tr></table></figure><h1 id="邮箱验证中原子组的使用"><a href="#邮箱验证中原子组的使用" class="headerlink" title="邮箱验证中原子组的使用"></a>邮箱验证中原子组的使用</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邮箱验证中原子组的使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test1 = <span class="string">&#x27;123131313@qq.com&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> test2 = <span class="string">&#x27;123131313@sina.com.cn&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> test3 = <span class="string">&#x27;jojo-123@qq.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以看到对于第二种情况是不行的 要继续修改</span></span><br><span class="line"><span class="built_in">console</span>.log(test1.match(<span class="regexp">/^[\w-]+@\w+\.(com|cn|org)$/</span>))</span><br><span class="line"><span class="built_in">console</span>.log(test2.match(<span class="regexp">/^[\w-]+@\w+\.(com|cn|org)$/</span>))</span><br><span class="line"><span class="built_in">console</span>.log(test3.match(<span class="regexp">/^[\w-]+@\w+\.(com|cn|org)$/</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// (\w+\.)+ 表示这样一组的可能有很多个 但是最后都要以com cn org结尾</span></span><br><span class="line"><span class="built_in">console</span>.log(test2.match(<span class="regexp">/^[\w-]+@(\w+\.)+(com|cn|org)$/</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="built_in">console</span>.log(test1.match(<span class="regexp">/^[\w-]+@(\w+\.)+(com|cn|org)$/</span>))</span><br><span class="line"><span class="built_in">console</span>.log(test2.match(<span class="regexp">/^[\w-]+@(\w+\.)+(com|cn|org)$/</span>))</span><br><span class="line"><span class="built_in">console</span>.log(test3.match(<span class="regexp">/^[\w-]+@(\w+\.)+(com|cn|org)$/</span>))</span><br></pre></td></tr></table></figure><h1 id="原子组引用完成替换操作"><a href="#原子组引用完成替换操作" class="headerlink" title="原子组引用完成替换操作"></a>原子组引用完成替换操作</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原子组引用完成替换操作</span></span><br><span class="line"><span class="keyword">let</span> text = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;h1&gt;jojo&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;jojolin&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;h3&gt;jojostoneocean&lt;/h3&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/&lt;(h[1-6])&gt;([\s\S]+)&lt;\/\1&gt;/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(text.match(reg));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里取出第二个括号内的内容出来 并替换整个字符串</span></span><br><span class="line"><span class="comment">// 确定index的技巧是数括号 第一个对于1 以此类推</span></span><br><span class="line"><span class="built_in">console</span>.log(text.replace(reg, <span class="string">&quot;&lt;p&gt;$2&lt;/p&gt;&quot;</span>));</span><br><span class="line"></span><br><span class="line">text.replace(reg,<span class="function">(<span class="params">p0,p1,p2,p3,p4</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p0)</span><br><span class="line">    <span class="built_in">console</span>.log(p1)</span><br><span class="line">    <span class="built_in">console</span>.log(p2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="js" scheme="https://zlinni.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>自问自答八股文</title>
    <link href="https://zlinni.github.io/posts/4161554500/"/>
    <id>https://zlinni.github.io/posts/4161554500/</id>
    <published>2022-08-24T11:07:36.000Z</published>
    <updated>2022-09-14T08:51:29.148Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>其实有时候学习八股并非是一件不好的事情，我们能从八股文里面学到很多平时自己没注意到的知识点，算是查漏补缺</p></div><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="js-有多少种数据类型"><a href="#js-有多少种数据类型" class="headerlink" title="js 有多少种数据类型"></a>js 有多少种数据类型</h2><p>7+1 USONB undefined string symbol object null number boolean bigint</p><h2 id="栈和堆的概念-什么是堆空间共享-如何改变引用地址"><a href="#栈和堆的概念-什么是堆空间共享-如何改变引用地址" class="headerlink" title="栈和堆的概念 什么是堆空间共享 如何改变引用地址"></a>栈和堆的概念 什么是堆空间共享 如何改变引用地址</h2><p>栈中存放基本数据类型，栈内的数据大小固定，体积较小，会被频繁使用，拷贝或者引用的时候会创建一份相同的复制</p><p>堆存放引用类型，堆内的数据大小不定，占据空间大。当一个引用类型被创建的时候，其属性会被放在堆空间中，指针放在栈中，当被引用的时候，先从栈找到对应的指针，指向堆空间的地址，获取属性。</p><p>堆空间共享指的是 多个引用指向同一个地址。</p><p>引用地址可以使用 bind call apply 去改变。</p><p>栈和堆的存在是为了维持 js 的内存平衡</p><h2 id="闭包是怎么存储的"><a href="#闭包是怎么存储的" class="headerlink" title="闭包是怎么存储的"></a>闭包是怎么存储的</h2><p>闭包被创建的时候，会创建一个 closure 对象到堆中，用于保存闭包中的变量，这就是为什么闭包可以常驻在内存的原因。且会导致内存泄漏。</p><h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>内存泄漏指的是堆内存中的变量由于某种原因无法及时释放造成系统资源的浪费，甚至导致系统崩溃。</p><p>怎么解决内存泄漏：<br>销毁闭包的变量，比如使用 clearTimeout 消除 settimeout 的 id 等</p><h2 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h2><p>闭包的本质是当前作用域中存在指向父级作用域的引用。</p><p>所以闭包并不一定表现为返回一个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fun3;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  fun3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line">fun3();</span><br></pre></td></tr></table></figure><p>可以看出其中输出的结果还是 2 因为在给 fun3 赋值的时候，fun3 就可以访问到 window fun1 和本身的作用域，然后由下往上查找 找到了 fun1 中的 2 输出 2</p><h2 id="如何解决循环输出问题"><a href="#如何解决循环输出问题" class="headerlink" title="如何解决循环输出问题"></a>如何解决循环输出问题</h2><p>let IIFE 注入变量 定时器第三个参数传入变量</p><h2 id="undefined-和-null-的理解"><a href="#undefined-和-null-的理解" class="headerlink" title="undefined 和 null 的理解"></a>undefined 和 null 的理解</h2><p>undefined 和 null 一般用于对变量赋初始值。需要注意的是 undefined 在 js 中并不是一个保留字，所以 undefined 可以作为变量名，那么要如何获取安全的 undefined 呢？可以使用 void<br>null 代表空对象，但不是真的空对象</p><h2 id="什么是-BigInt-用途是什么-怎么实现一个-BigInt-的运算"><a href="#什么是-BigInt-用途是什么-怎么实现一个-BigInt-的运算" class="headerlink" title="什么是 BigInt 用途是什么 怎么实现一个 BigInt 的运算"></a>什么是 BigInt 用途是什么 怎么实现一个 BigInt 的运算</h2><p>js 只支持 2 的 53 次方的数字，大于这个范围会四舍五入，表现在最后一位数不对，BigInt 是数字+n 或者使用 BigInt 构造函数传入数字格式的字符串就可以生成。</p><p>注意 bigint 并不是 number 所以不等于 number 类型</p><p>bigint 可以用在比如发送请求之前将请求的数字包装成 bigint 类型发送，常用一些库函数。</p><p>bigint 之间的运算使用位运算</p><p>leetcode</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</span></span><br><span class="line"><span class="string">最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</span></span><br><span class="line"><span class="string">你可以假设除了整数 0 之外，这个整数不会以零开头。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">示例 1:</span></span><br><span class="line"><span class="string">输入: [1,2,3]</span></span><br><span class="line"><span class="string">输出: [1,2,4]</span></span><br><span class="line"><span class="string">解释: 输入数组表示数字 123。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">示例 2:</span></span><br><span class="line"><span class="string">输入: [4,3,2,1]</span></span><br><span class="line"><span class="string">输出: [4,3,2,2]</span></span><br><span class="line"><span class="string">解释: 输入数组表示数字 4321。`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plusOne = <span class="function">(<span class="params">digits</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">BigInt</span>(digits.join(<span class="string">&quot;&quot;</span>)) + <span class="number">1n</span>).toString().split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1+0.2!==0.3?"></a>0.1+0.2!==0.3?</h2><p>刚刚说了只支持到 2 的五十三次方，而由于小数计算机是识别不了的，要转二进制，所以 0.1 其实相当于一个无限循环的二进制数<code>0.0001100110011001100...</code>，而考虑到内存的原因，到某一位就被四舍五入了，导致结果计算出来不是 0.3 而是一个近似值。</p><p>解决方法：<br>使用 toFixed 或者变成整数再除以对应的倍数</p><h2 id="0-2-0-3-0-5？"><a href="#0-2-0-3-0-5？" class="headerlink" title="0.2+0.3===0.5？"></a>0.2+0.3===0.5？</h2><p>因为后面转二进制都是 0 所以刚好是 0.5</p><h2 id="那既然-0-1-不是-0-1-了，为什么在console-log-0-1-的时候还是-0-1-呢"><a href="#那既然-0-1-不是-0-1-了，为什么在console-log-0-1-的时候还是-0-1-呢" class="headerlink" title="那既然 0.1 不是 0.1 了，为什么在console.log(0.1)的时候还是 0.1 呢?"></a>那既然 0.1 不是 0.1 了，为什么在<code>console.log(0.1)</code>的时候还是 0.1 呢?</h2><p>在 console.log 的时候会二进制转换为十进制，十进制再会转为字符串的形式，在转换的过程中发生了取近似值，所以打印出来的是一个近似值的字符串</p><h2 id="js-有多少种判断数据的方式-分别是什么"><a href="#js-有多少种判断数据的方式-分别是什么" class="headerlink" title="js 有多少种判断数据的方式 分别是什么"></a>js 有多少种判断数据的方式 分别是什么</h2><p>4 typeof instanceof constructor Object.prototype.toString.call()</p><h2 id="为什么-typeof-null-是-object"><a href="#为什么-typeof-null-是-object" class="headerlink" title="为什么 typeof null 是 object"></a>为什么 typeof null 是 object</h2><p>typeof 的原理就是通过类型的地址判断，对于 null 和 object 来说，地址开头的前几位都是 0 所以判断相同</p><p>注意 typeof 是可以判断 function 的</p><h2 id="instanceof-的原理-为什么-instanceof-无法判断-null-和-undefined-手写-instanceof"><a href="#instanceof-的原理-为什么-instanceof-无法判断-null-和-undefined-手写-instanceof" class="headerlink" title="instanceof 的原理 为什么 instanceof 无法判断 null 和 undefined 手写 instanceof"></a>instanceof 的原理 为什么 instanceof 无法判断 null 和 undefined 手写 instanceof</h2><p>instanceof 是通过原型链判断的，相当于是在判断该变量是否是某个类的实例。</p><p>null 和 undefined 没有构造函数 也就是他没有对应的原型</p><p>手写 instanceof</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myInstanceof = <span class="function">(<span class="params">example, classFn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(example);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="built_in">Object</span>.getPrototypeOf(classFn)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用-constructor-检测有什么缺点？"><a href="#使用-constructor-检测有什么缺点？" class="headerlink" title="使用 constructor 检测有什么缺点？"></a>使用 constructor 检测有什么缺点？</h2><p>constructor 是构造函数，会指向原型。使用 constructor 的时候，相当于判断该变量的构造函数是否指向对应的原型。</p><p>但由于原型是可以改变的，所以原型指向改变之后，原本的构造函数就会指向新的原型，所以会判断失误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Fn.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor === Fn); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Object-prototype-toString-call-为什么要用-prototype，为什么要用-call，以及他能判断什么类型，如何封装一个判断类型的函数"><a href="#Object-prototype-toString-call-为什么要用-prototype，为什么要用-call，以及他能判断什么类型，如何封装一个判断类型的函数" class="headerlink" title="Object.prototype.toString().call 为什么要用 prototype，为什么要用 call，以及他能判断什么类型，如何封装一个判断类型的函数"></a>Object.prototype.toString().call 为什么要用 prototype，为什么要用 call，以及他能判断什么类型，如何封装一个判断类型的函数</h2><p>类似于 Number，String,Array 上面都重写了 toString 方法.而它们最终指向的 Object 上有共同的方法，所以要使用 prototype 去找 Object 上的方法，使用 call 是为了改变 this 的指向。他能判断所有的类型，以及一些特殊的比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>); <span class="comment">//&quot;[object HTMLDocument]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>); <span class="comment">//&quot;[object Window]&quot;</span></span><br></pre></td></tr></table></figure><p>封装一个判断类型函数的思路就是，基本类型除了 null 使用 typeof 判断，非基本类型使用该方法判断</p><h2 id="对象是怎么转原始类型的，可以自己设置转换规则吗"><a href="#对象是怎么转原始类型的，可以自己设置转换规则吗" class="headerlink" title="对象是怎么转原始类型的，可以自己设置转换规则吗"></a>对象是怎么转原始类型的，可以自己设置转换规则吗</h2><p>对象中有 toPrimitive 方法，该方法优先级是 valueOf，到 toString，能转到原始类型就转</p><p>自己设置转换规则的话 使用<code>Symobol.toPrimitive</code>就可以自定义规则了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toStirng</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>+a <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>常考：[1,2,3]转原始类型</p><h2 id="的隐式转换"><a href="#的隐式转换" class="headerlink" title="==的隐式转换"></a>==的隐式转换</h2><ol><li>其中一个是<code>null</code>或者<code>undefined</code> 另外一个也要是 否则为 false</li><li>其中一个是<code>string/number</code> 转 number</li><li>boolean 转 number</li><li>object 转原始 （注意！！！两个 obj 比较的是地址值）</li><li>NaN 和任何值都不相等 包括他自己</li></ol><p>常考</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意这里a又可以等于1、2、3</span></span><br><span class="line"><span class="built_in">console</span>.log(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>常见坑:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小坑</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">false</span> <span class="comment">// -&gt; true  这里false先被转为0，&quot;0&quot;也会转为0，所以为true</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="string">&quot;&quot;</span> <span class="comment">// -&gt; false 两个都是字符串类型，直接比较</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span> <span class="comment">// -&gt; true 空字符串直接转为0</span></span><br><span class="line"><span class="literal">false</span> == [] <span class="comment">// -&gt; true false先转为0；[]空数组转为&#x27;&#x27;，之后ToNumber操作转为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大坑</span></span><br><span class="line">[] == ![] <span class="comment">// -&gt; true []  这里![]先被强制转换为false，变成[]与fasle的比较，之后fasle-&gt;0；[]-&gt;&#x27;&#x27;-&gt;0，所以为true。</span></span><br><span class="line"><span class="number">2</span>==[<span class="number">2</span>] <span class="comment">// -&gt; true [2]-&gt;&#x27;2&#x27;-&gt;2 所以为true</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span>==[<span class="literal">null</span>] <span class="comment">// true [null]-&gt;&#x27;&#x27;</span></span><br><span class="line"><span class="number">0</span>==<span class="string">&#x27;\n&#x27;</span> <span class="comment">// -&gt; true &#x27;\n&#x27;-&gt;&#x27;&#x27;-&gt;0</span></span><br><span class="line"><span class="string">&#x27;true&#x27;</span>==<span class="literal">true</span> <span class="comment">// -&gt; false true-&gt;0;&#x27;true&#x27;-&gt;NaN，所以为false</span></span><br></pre></td></tr></table></figure><h2 id="的隐式转换-1"><a href="#的隐式转换-1" class="headerlink" title="+的隐式转换"></a>+的隐式转换</h2><ol><li>其中一个是字符串，另外的是基本类型则转 string，引用类型转原始(存在优先级)</li><li>其中一个是数字，另外的是基本类型则转 number，引用类型转原始(存在优先级)</li><li>如果一个是字符串一个是数字则拼接</li></ol><h2 id="isNaN和Number-isNaN的区别"><a href="#isNaN和Number-isNaN的区别" class="headerlink" title="isNaN和Number.isNaN的区别"></a><code>isNaN</code>和<code>Number.isNaN</code>的区别</h2><p>前者是 ES6 之前的全局方法，判断的方式是先把传进来的内容使用 Number 进行转换，然后再判断是否为 NaN，后者更方便一点，首先判断传进来的内容是否为数值类型，非数值直接返回 NaN，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>); <span class="comment">// false 布尔值true会转为非0值</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">false</span>); <span class="comment">// false 布尔值false会转换成0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">null</span>); <span class="comment">// false  null会转为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// strings</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;37&quot;</span>); <span class="comment">// false: 可以被转换成数值37</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;37.37&quot;</span>); <span class="comment">// false: 可以被转换成数值37.37</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;37,5&quot;</span>); <span class="comment">// true &quot;37,5&quot;不能转换为数值</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;123ABC&quot;</span>); <span class="comment">// true：parseInt(&quot;123ABC&quot;) = 123, 但是Number(&quot;123ABC&quot;) = NaN</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// false: 空字符串被转换成0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// false: 包含空格的字符串被转换成0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// false 会转换成当前的时间</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().toString()); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>([]); <span class="comment">// false []转换成0</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">String</span>()); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="keyword">new</span> <span class="built_in">Array</span>()); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;Infinity&quot;</span>); <span class="comment">// false：&quot;Infinity&quot;转换为Infinity</span></span><br><span class="line"><span class="built_in">isNaN</span>(-<span class="number">0.1</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(x) == <span class="built_in">isNaN</span>(<span class="built_in">Number</span>(x)); <span class="comment">// 不论x为何值 都返回true 哪怕x = undefined</span></span><br><span class="line"><span class="comment">// 因为isNaN(undefined) = true 且 Number(undefined) = NaN 使得isNaN(NaN) = true</span></span><br><span class="line"><span class="built_in">isNaN</span>() == <span class="built_in">isNaN</span>(<span class="built_in">Number</span>()); <span class="comment">// false, because isNaN() = true and Number() = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下全部返回true</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;); <span class="comment">// 空对象执行toString方法 结果是&#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">String</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Array</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;blabla&quot;</span>); <span class="comment">// &quot;blabla&quot;不能转换成数值</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;-blabla&quot;</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">0</span> / <span class="number">0</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&quot;0/0&quot;</span>); <span class="comment">// &quot;0/0&quot;不能转换成数字</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">Infinity</span> / <span class="literal">Infinity</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">undefined</span>); <span class="comment">//</span></span><br><span class="line"><span class="built_in">isNaN</span>();</span><br></pre></td></tr></table></figure><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a><code>Object.is</code></h2><p>用法和<code>===</code>基本一致 不同在于</p><ol><li>0 和+0 是一样的 但是 0 和-0 是不一样的</li><li>NaN 与 NaN 为 true</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="number">0</span>, +<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="number">0</span> / <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数为什么不能和-this-结合"><a href="#箭头函数为什么不能和-this-结合" class="headerlink" title="箭头函数为什么不能和 this 结合"></a>箭头函数为什么不能和 this 结合</h2><p>因为箭头函数的指向在定义函数的时候就已经指定好了，所以不能和 this 结合</p><p>因为 this 是固定的了，所以也不能去改变<br>比如使用 call/bind/apply<br>那么进一步说，new 也不能用在箭头函数实例化，因为 new 的原理其实也是把 this 指向给到新的实例</p><p>并且 也没有 arguments，(为什么) 但是可以访问别人的 arguments</p><h2 id="this-有多少种指向"><a href="#this-有多少种指向" class="headerlink" title="this 有多少种指向"></a>this 有多少种指向</h2><p>5 种</p><p>在浏览器中 全局范围的 this 指向 window(控制台)<br>在函数中 this 指向最后调用它的对象<br>在构造函数中指向实例<br><code>call/apply/bind</code>中指向被强绑定的对象<br>箭头函数，声明的时候就固定，是静态的</p><h2 id="call-apply-bind三者区别"><a href="#call-apply-bind三者区别" class="headerlink" title="call/apply/bind三者区别"></a><code>call/apply/bind</code>三者区别</h2><p>共同点 都能改变 this 指向<br>call 和 apply 区别在于传参，一个是字符串，一个是数组<br>bind 的话 会生成一个函数或者是生成一个新的对象(当传入 null)的时候</p><h2 id="三者手写"><a href="#三者手写" class="headerlink" title="三者手写"></a>三者手写</h2><p>参考手写篇<br>比较需要注意的点是，call 和 apply 的 context 不传的时候是 window，我们直接在编译器里面拿是拿不到的，可以使用 globalThis 关键字。</p><p>bind 的话要考虑那个 new 的情况，也就是传 null 相当于生成了一个构造函数，需要实例化</p><h2 id="如何实现柯里化"><a href="#如何实现柯里化" class="headerlink" title="如何实现柯里化"></a>如何实现柯里化</h2><p>柯里化有两种：定长和不定长，柯里化的思想是：收集和执行<br>对于定长的柯里化：<br>收集当前参数，如果形参长度未达到真实函数形参长度，则继续回调收集，否则执行真实函数</p><p>对于不定长的柯里化：<br>收集当前参数，然后把执行的结果放到函数的 toString 里面，这里涉及到对象转原始类型优先级的知识。</p><h2 id="如何给类数组添加-push-方法"><a href="#如何给类数组添加-push-方法" class="headerlink" title="如何给类数组添加 push 方法"></a>如何给类数组添加 push 方法</h2><p>其实就是用 bind 改变 push 方法的 this 指向 就可以了</p><h2 id="什么时候要使用到-bind"><a href="#什么时候要使用到-bind" class="headerlink" title="什么时候要使用到 bind"></a>什么时候要使用到 bind</h2><p>防止 this 指向到不正确的对象/永久绑定 this 指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">nickname</span>: <span class="string">&quot;jojo&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">eatWatermelon</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.nickname + <span class="string">&quot; 吃西瓜&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.eatWatermelon(); <span class="comment">//jojo吃西瓜</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eatWatermelon = person.eatWatermelon;</span><br><span class="line">eatWatermelon(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>this 的指向变成了 eatWatermelon() 执行时所在作用域的 this。也就是 window，所以找不到</p><p>解决方法: 使用 bind 永久绑定 this 指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eatWatermelon = person.eatWatermelon.bind(person);</span><br><span class="line">eatWatermelon(); <span class="comment">//jojo吃西瓜</span></span><br></pre></td></tr></table></figure><p>预置函数参数<br>eg2 预置函数参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addSix = add.bind(<span class="literal">null</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> addSixThenAddFour = addSix.bind(<span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line">addSixThenAddFour(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">addSixThenAddFour(<span class="number">7</span>);</span><br><span class="line"><span class="comment">// 17</span></span><br></pre></td></tr></table></figure><h2 id="什么是变量提升"><a href="#什么是变量提升" class="headerlink" title="什么是变量提升"></a>什么是变量提升</h2><p>var 声明变量的时候 var 变量会提升到作用域顶部为 undefined，然后在对应的位置重新赋值</p><p>这里还涉及函数提升 函数提升优于变量提升</p><p>常考的：在函数中输出函数的名字 误导性极强</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line">b(); <span class="comment">//jojo</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//[Function: b]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line">b(); <span class="comment">//jojo</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//jojo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">b(); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//[Function: b]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  b = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">b(); <span class="comment">// [Function: b]</span></span><br><span class="line"><span class="built_in">console</span>.log(b)(</span><br><span class="line">  <span class="comment">// jojo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// case5 这里涉及的是闭包的知识，闭包会将函数名存储进去，无法修改</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    b = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">//[Function: b]</span></span><br><span class="line">  &#125;</span><br><span class="line">)();</span><br></pre></td></tr></table></figure><h2 id="什么是暂时性死区"><a href="#什么是暂时性死区" class="headerlink" title="什么是暂时性死区"></a>什么是暂时性死区</h2><p>let const 声明的变量在声明前就被调用 产生暂时性死区 表现为 Reference Error</p><h2 id="js-执行环境有哪些"><a href="#js-执行环境有哪些" class="headerlink" title="js 执行环境有哪些"></a>js 执行环境有哪些</h2><p>全局执行环境和函数执行环境</p><h2 id="js-执行上下文有哪几种"><a href="#js-执行上下文有哪几种" class="headerlink" title="js 执行上下文有哪几种"></a>js 执行上下文有哪几种</h2><p>全局上下文 函数上下文 eval 上下文</p><h2 id="执行上下文中有哪些重要属性"><a href="#执行上下文中有哪些重要属性" class="headerlink" title="执行上下文中有哪些重要属性"></a>执行上下文中有哪些重要属性</h2><ul><li>变量对象（VO),包含变量，函数声明和函数的形参，该属性只能在全局上下文中访问。</li><li>作用域链，js 采用词法作用域链，也就是说变量的作用域是在定义的时候决定了。</li><li><code>this</code></li></ul><h2 id="js-代码执行的过程"><a href="#js-代码执行的过程" class="headerlink" title="js 代码执行的过程"></a>js 代码执行的过程</h2><ul><li>先创建全局执行上下文 global EC</li><li>全局执行上下文 caller 逐行 自上而下执行。遇到函数的时候，函数执行上下文 callee 会被 push 到执行栈顶层</li><li>执行上下文被激活后，成为 active EC 开始执行函数中的代码，caller 被挂起</li><li>函数执行完后 callee 被 pop 出执行栈 控制权还给 caller 继续执行</li></ul><h2 id="作用域和作用域链的理解"><a href="#作用域和作用域链的理解" class="headerlink" title="作用域和作用域链的理解"></a>作用域和作用域链的理解</h2><ul><li>作用域：作用域就是定义变量的区域，他有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找</li><li>作用域链：作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数</li></ul><div class="note primary flat"><p>作用域链本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象</p></div><ul><li>当我们查找一个变量的时候，如果在当前执行环境中没有找到，我们可以沿着作用域链向后查找</li><li>作用域链的创建过程和执行上下文的建立有关。</li></ul><div class="note primary flat"><p>作用域可以理解为变量的可访问性 总共分为三种类型 分别为：</p></div><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul><h2 id="new-的原理以及实现"><a href="#new-的原理以及实现" class="headerlink" title="new 的原理以及实现"></a>new 的原理以及实现</h2><ul><li>创建一个空对象</li><li>将对象连接到构造函数原型(装载原型方法)</li><li>改变构造函数的 this 指向为新的对象并获取执行构造获取结果</li><li>判断结果是否返回了一个对象<br>如果是 那么返回该对象 否则 使用连接的新对象</li></ul><p>注意 构造函数默认返回实例对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!fn <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">let</span> res = fn.call(obj, ...args); <span class="comment">//改变了this指向的同时获取到构造的结果</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="proto-prototype-constructor三者关系"><a href="#proto-prototype-constructor三者关系" class="headerlink" title="__proto__,prototype,constructor三者关系"></a><code>__proto__,prototype,constructor</code>三者关系</h2><p><code>__proto__</code>是隐式原型，用于实例去访问其原型对象，但是不规范，一般使用<code>getPrototypeOf</code>去访问</p><p><code>constructor</code>是构造函数，用于创建对象，以及给新对象设置原型对象(相当于设置了一个指针指向 prototype)。存放于<code>constructor.prototype</code>属性中。</p><p><code>prototype</code>是对象，通常叫他原型对象，存在于构造函数中，是他的一个属性。</p><p>常考的东西：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链</span></span><br><span class="line"><span class="built_in">console</span>.log(test.__proto__ === <span class="built_in">Array</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(test.constructor === <span class="built_in">Array</span>); <span class="comment">//实例的构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.constructor === <span class="built_in">Array</span>); <span class="comment">//构造函数自身有原型属性去访问原型，原型又可以通过construtor属性去访问构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.constructor === <span class="built_in">Array</span>); <span class="comment">//原型链 找到原型上的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数的原型的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure><p>对于实例来说 有两个属性 <code>__proto__</code>和<code>constructor</code>分别可以去访问原型和构造函数<br>对于构造函数来说 有两个属性<code>__proto__</code>和<code>prototype</code>分别可以去访问构造函数的原型和原型<br>对于原型来说 有两个属性 <code>__proto__</code>和<code>constructor</code>分别可以去访问原型的原型和构造函数</p><h2 id="如何获取对象的原型"><a href="#如何获取对象的原型" class="headerlink" title="如何获取对象的原型"></a>如何获取对象的原型</h2><ul><li><code>p.__proto__</code></li><li><code>p.constructor.prototype</code></li><li><code>Object.getPrototypeOf(p)</code></li></ul><h2 id="原型链本质"><a href="#原型链本质" class="headerlink" title="原型链本质"></a>原型链本质</h2><p>对象可以通过<code>__proto__</code>来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链。本质上就是链表结构，<code>__proto__</code>算是链表的指针，指向下一个位置</p><h2 id="说说你知道的-js-继承方式，为什么要继承"><a href="#说说你知道的-js-继承方式，为什么要继承" class="headerlink" title="说说你知道的 js 继承方式，为什么要继承"></a>说说你知道的 js 继承方式，为什么要继承</h2><p>继承的目的是为了 让子类拥有父类的属性和方法，属性放在构造函数中，方法挂载在原型中</p><p>组合继承，寄生组合继承，Class 继承</p><p>代码参见手写</p><h2 id="组合继承有什么问题？"><a href="#组合继承有什么问题？" class="headerlink" title="组合继承有什么问题？"></a>组合继承有什么问题？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//缺点 使得prototype上面有了不必要的属性</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>组合继承让实例的原型继承了不应该继承的东西，因为他是在子类构造函数里用了一次 call 执行父类构造函数 然后在外面链接父类原型的时候(链接原型的目的是为了继承父类的方法，而继承父类方法的方式可以是使用 new) 使用了 new 方法，new 方法又会执行一遍构造函数，于是子类原型上面也有了父类原型的一些属性</p><p>而 call 的时候已经继承过了一次属性到子类构造函数中，造成了属性冗余</p><h2 id="寄生组合继承怎么解决组合继承的问题？又有什么缺点？"><a href="#寄生组合继承怎么解决组合继承的问题？又有什么缺点？" class="headerlink" title="寄生组合继承怎么解决组合继承的问题？又有什么缺点？"></a>寄生组合继承怎么解决组合继承的问题？又有什么缺点？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用SuperType()</span></span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="comment">// 构建原型链</span></span><br><span class="line"><span class="comment">// 第一次调用SuperType()</span></span><br><span class="line"><span class="comment">//   SubType.prototype = new SuperType();</span></span><br><span class="line"><span class="comment">// 重写SubType.prototype的constructor属性，指向自己的构造函数SubType</span></span><br><span class="line">SubType.prototype = <span class="built_in">Object</span>.create(SuperType.prototype, &#123;</span><br><span class="line">  <span class="attr">constructor</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: SubType,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// SubType.prototype.__proto__ = SuperType.prototype; //或者这么使用</span></span><br></pre></td></tr></table></figure><p>我们知道。组合继承的问题在于给子类添加父类方法的时候又调用了一遍父类的构造函数使得子类原型上面多了很多无关的属性。</p><p>寄生组合继承的解决方法有两种，一种是采用 api<code>Object.create(子类,constructor)</code>去重写子类的原型的 constructor 属性为子类自身的构造函数</p><p>或者直接把子类的原型链接到父类原型上面。这样子类调用方法的时候找不到就去父类找，属于原型链的方法。</p><p>缺点：缺点在于不能调用父类静态方法。</p><h2 id="什么是-class-继承"><a href="#什么是-class-继承" class="headerlink" title="什么是 class 继承"></a>什么是 class 继承</h2><p>class 其实也是一个函数，使用方法是，子类采用 extends 关键字继承父类，然后在子类的构造函数中，采用 super 继承父类的属性。</p><h2 id="事件流的三个阶段是什么"><a href="#事件流的三个阶段是什么" class="headerlink" title="事件流的三个阶段是什么"></a>事件流的三个阶段是什么</h2><p>捕获 目标 冒泡</p><h2 id="preventDefault与stopPropagation的区别"><a href="#preventDefault与stopPropagation的区别" class="headerlink" title="preventDefault与stopPropagation的区别"></a><code>preventDefault</code>与<code>stopPropagation</code>的区别</h2><p>前者是阻止默认事件 比如表单提交<br>后者是阻止冒泡</p><h2 id="onClick-和-addEventListener-的区别"><a href="#onClick-和-addEventListener-的区别" class="headerlink" title="onClick 和 addEventListener 的区别"></a>onClick 和 addEventListener 的区别</h2><p>前者不需要销毁 后者需要<br>前者阻止冒泡需要 stopPropagation，后者在第三个参数决定是否需要冒泡 默认 false 是冒泡</p><h2 id="Promise-是什么，解决了什么问题"><a href="#Promise-是什么，解决了什么问题" class="headerlink" title="Promise 是什么，解决了什么问题"></a>Promise 是什么，解决了什么问题</h2><p>Promise 是一种状态机，状态有 fulfilled,rejected,pending。状态只能由 fulfilled 向其他两个转换，一旦转换就不能再改变。</p><p>Promise 解决了回调地狱的问题，回调地狱指的是回调函数里面又嵌套回调函数，导致代码缩进非常难看，可读性差，Promise 链式调用可以帮我们解决这个痛点。</p><p>而实际上 async await 更方便一点点</p><h2 id="Promise-中直接-return-一个-error-对象会发生什么"><a href="#Promise-中直接-return-一个-error-对象会发生什么" class="headerlink" title="Promise 中直接 return 一个 error 对象会发生什么"></a>Promise 中直接 return 一个 error 对象会发生什么</h2><p>在 promise 中，任何的 return 都视为成功的回调。不写的话默认<code>return Promise.resolve(undefined)</code> return 一个 error 对象也是会进入成功回调的</p><h2 id="new-Promise-需要注意什么"><a href="#new-Promise-需要注意什么" class="headerlink" title="new Promise 需要注意什么"></a>new Promise 需要注意什么</h2><p>new Promise 会先执行构造器的内容，常考在异步任务中</p><h2 id="Promise-all-race-any-allSettled-具体实现"><a href="#Promise-all-race-any-allSettled-具体实现" class="headerlink" title="Promise.all race any allSettled 具体实现"></a>Promise.all race any allSettled 具体实现</h2><p>参考手写代码<br>all 的话 传入可迭代对象，一般是数组，如果其中的有一个失败则进入失败回调，全都成功才算成功<br>race 传参相同，以第一个改变状态的任务为最终结果<br>any 传参相同 全部失败算失败 全部成功算成功<br>allSettled 传参相同，不会因为一个失败就停止，会返回全部任务的最终状态</p><h2 id="Promise-实现-fetch-请求的-abort"><a href="#Promise-实现-fetch-请求的-abort" class="headerlink" title="Promise 实现 fetch 请求的 abort"></a>Promise 实现 fetch 请求的 abort</h2><p>利用 promise race API</p><h2 id="如果实现异步请求并发限制"><a href="#如果实现异步请求并发限制" class="headerlink" title="如果实现异步请求并发限制"></a>如果实现异步请求并发限制</h2><p>all 方法可以保证，promise 数组中所有的 promis 对象都达到 resolve 的状态才执行 then 的回调。</p><p>此时如果数组内有几十万个 promise，那么就会在一瞬间发出几十万跳请求，导致内存溢出。</p><p>所以需要 promiseall 进行并发限制。每一个时刻并发执行的 promise 数量是固定的。最终执行结果和原来的保持一致。</p><h2 id="race-方法的用途"><a href="#race-方法的用途" class="headerlink" title="race 方法的用途"></a>race 方法的用途</h2><p>实现一个超时停止请求</p><h2 id="Promise-finally-的用法"><a href="#Promise-finally-的用法" class="headerlink" title="Promise finally 的用法"></a>Promise finally 的用法</h2><p>不论最后状态如何都会去执行，一般用做中间件，因为无论状态如何都会走 finally，这样就可以用作过度。</p><h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><p>并行是指多个事件在同一时间点执行<br>并发指的是多个事件在同一时间段执行，但是多个指令进程被快速的交替进行，因此在宏观上长得和并行差不多，但是微观上不一样</p><h2 id="all-方法是并发的还是并行的。"><a href="#all-方法是并发的还是并行的。" class="headerlink" title="all 方法是并发的还是并行的。"></a>all 方法是并发的还是并行的。</h2><p>并发的，不过<code>promise.all().then()</code>结果中数组的顺序和<code>Promise.all()</code>接收到的数组顺序一致</p><h2 id="generator-怎么使用"><a href="#generator-怎么使用" class="headerlink" title="generator 怎么使用"></a>generator 怎么使用</h2><ul><li>有一个*符号的标识符 在函数名称前</li><li>有一个关键字 yield 用于实现分段执行，当 generator 函数遇到 yield 的时候会暂停并抛出其之后的表达式</li><li>有一个关键字 next 表示归还代码的控制权（这一步非常重要，能否理解他决定能否做 async 和 await 的异步题</li></ul><p>手写 genertor</p><h2 id="js-事件循环是什么"><a href="#js-事件循环是什么" class="headerlink" title="js 事件循环是什么"></a>js 事件循环是什么</h2><p>js 的任务分为同步任务和异步任务，异步任务中分为宏任务和微任务。代码由上而下执行，遇到函数调用将函数压入执行栈，先执行同步任务，如果在同步任务中发现了异步事件，先将其挂起，继续执行执行栈中的其他任务。<br>当同步事件执行完之后，将异步事件的回调加入到异步的任务队列中等待执行。<br>异步任务队列分为，微任务队列和宏任务队列。<br>优先执行微任务队列，然后执行宏任务队列。<br>然后重复以上操作</p><h2 id="process-nextTick-是什么"><a href="#process-nextTick-是什么" class="headerlink" title="process.nextTick 是什么"></a>process.nextTick 是什么</h2><p>是 node 中的一个 api，他指定的异步任务总是发生于所有异步任务之前</p><h2 id="js-为什么是单线程"><a href="#js-为什么是单线程" class="headerlink" title="js 为什么是单线程"></a>js 为什么是单线程</h2><p>考虑到用户视角始终只有一个的原因，如果 js 是多线程的话。其中一个线程创建了 DOM 节点，另外一个线程销毁了 DOM 节点。此时浏览器的视图应该以什么为准呢？因为这样的原因，js 在一开始设计上就是单线程的。</p><h2 id="js-怎么开启多线程"><a href="#js-怎么开启多线程" class="headerlink" title="js 怎么开启多线程"></a>js 怎么开启多线程</h2><p>浏览器的线程主要包括 js 引擎，界面渲染线程，事件触发线程，http 请求线程。</p><p>对于 js 来说，他是单线程的，所以一旦有一个任务花费了大量的时间就会造成阻塞。为了解决这个问题，js 提供了一个 worker 类 。</p><p>使用这个 worker 类，会向浏览器申请一个新的线程，用于编写耗时代码。且主线程可以和子线程连线，这样就实现了线程之间数据的传递</p><p>不过需要注意的一点是，尽量只把耗时的操作交给 worker，其他的操作交给主线程，因为所有 js 里面集成的对象都在主线程中。worker 访问会报错</p><h2 id="对-async-和-await-的理解"><a href="#对-async-和-await-的理解" class="headerlink" title="对 async 和 await 的理解"></a>对 async 和 await 的理解</h2><p>本质是 generator 的语法糖，async 用于产生一个 promise，await 需要保证顶部是 async。</p><p>await 和 next 的作用是一样的，他会暂时返还代码的控制权，也就是会跳出当前任务到外面继续执行同步任务等。</p><p>他还会保留堆栈中的东西，假如在 await 这一步操作了变量，他会保留变量的值，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + (<span class="keyword">await</span> <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>, a); <span class="comment">// -&gt; &#x27;2&#x27; 10 //回到awiat之后的内容，保留了堆栈 所以a还是0，0+10= 10</span></span><br><span class="line">  a = (<span class="keyword">await</span> <span class="number">10</span>) + a;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;3&quot;</span>, a); <span class="comment">// -&gt; &#x27;3&#x27; 20</span></span><br><span class="line">&#125;;</span><br><span class="line">b(); <span class="comment">//执行b但是遇到await 跳出</span></span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span>, a); <span class="comment">// -&gt; &#x27;1&#x27; 1 //跳出后执行同步</span></span><br></pre></td></tr></table></figure><h2 id="async-await-对比-promise-的优势"><a href="#async-await-对比-promise-的优势" class="headerlink" title="async/await 对比 promise 的优势"></a>async/await 对比 promise 的优势</h2><p>优势在于处理 then 的链式调用，能更清晰的写出代码。<br>但是缺点在于 await 会阻塞线程，可能导致性能问题。</p><h2 id="async-await-如何捕获异常"><a href="#async-await-如何捕获异常" class="headerlink" title="async/await 如何捕获异常"></a>async/await 如何捕获异常</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最近流行的 await-to-js，这种方式可能更为优雅</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">5</span>) &#123;</span><br><span class="line">      resolve(<span class="string">&quot;small&quot;</span> + num);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      reject(<span class="string">&quot;big&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to函数来执行一下a()， to函数返回的是一个Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">to</span>(<span class="params">P</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> P.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="literal">null</span>, data];</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [err, <span class="literal">undefined</span>]; <span class="comment">// 因为没有主动抛出异常，所以后续.then是fullfilled的状态</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> b1 = <span class="keyword">await</span> to(a(<span class="number">8</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(b1); <span class="comment">// [ &#x27;big8&#x27;, undefined ]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> b2 = <span class="keyword">await</span> to(a(<span class="number">3</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(b2); <span class="comment">// [ null, &#x27;small3&#x27; ]</span></span><br><span class="line">&#125;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure><h2 id="setTimeout-和-setInterval-和-requestAnimationFrame-各有什么特点"><a href="#setTimeout-和-setInterval-和-requestAnimationFrame-各有什么特点" class="headerlink" title="setTimeout 和 setInterval 和 requestAnimationFrame 各有什么特点"></a>setTimeout 和 setInterval 和 requestAnimationFrame 各有什么特点</h2><p>正常的屏幕刷新率是 60hz，相当于 16.7ms 执行一次，我们为了达到这样的效果，要设置更新时间为 1000/60。但是 settimeout 和 setInterval 始终是基于 js 引擎的，也就不可避免遇到阻塞，就造成了并不是每一次循环都是相同的时间间隔</p><p>requestAnimationFrame 是基于 GUI 引擎的，他的刷新时间是和系统的刷新率同步的，如果是 60HZ 那么就是 16.7ms 执行一次。这样就能防止掉帧行为。且由于 setTimeout 实现的动画，在浏览器隐藏或者最小化的时候仍然在处于激活状态(虽然已经有浏览器对定时器做了优化)，而 requestAnimationFrame 在页面未激活的情况下会停止。节约了 CPU 开销</p><h2 id="什么是垃圾回收机制"><a href="#什么是垃圾回收机制" class="headerlink" title="什么是垃圾回收机制?"></a>什么是垃圾回收机制?</h2><h2 id="遍历对象有几种方法"><a href="#遍历对象有几种方法" class="headerlink" title="遍历对象有几种方法"></a>遍历对象有几种方法</h2><p>7 种<br>forin<br><code>Object.keys()、Object.values()、Object.entries()</code><br><code>Object.getOwnPropertyNames()</code><br><code>Object.getOwnPropertySymbols()</code><br><code>Reflect.ownKeys()</code></p><h2 id="什么方法只返回对象本身的属性"><a href="#什么方法只返回对象本身的属性" class="headerlink" title="什么方法只返回对象本身的属性"></a>什么方法只返回对象本身的属性</h2><p><code>Object.keys()、Object.values()、Object.entries()</code><br><code>Object.getOwnPropertyNames()</code><br><code>Object.getOwnPropertySymbols()</code><br><code>Reflect.ownKeys()</code></p><h2 id="什么方法能返回不可枚举的属性"><a href="#什么方法能返回不可枚举的属性" class="headerlink" title="什么方法能返回不可枚举的属性"></a>什么方法能返回不可枚举的属性</h2><p><code>Object.getOwnPropertySymbols()</code><br><code>Reflect.ownKeys()</code></p><h2 id="面向对象的思想包括"><a href="#面向对象的思想包括" class="headerlink" title="面向对象的思想包括"></a>面向对象的思想包括</h2><p>继承 封装 多态 抽象</p><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h2 id="JSON-parse-JSON-stringfy-有什么问题"><a href="#JSON-parse-JSON-stringfy-有什么问题" class="headerlink" title="JSON.parse(JSON.stringfy())有什么问题"></a>JSON.parse(JSON.stringfy())有什么问题</h2><p>缺点：不能拷贝<code>undefined function 正则 Error对象</code></p><h2 id="深拷贝实现细节-如何判断一个对象是正则对象"><a href="#深拷贝实现细节-如何判断一个对象是正则对象" class="headerlink" title="深拷贝实现细节 如何判断一个对象是正则对象"></a>深拷贝实现细节 如何判断一个对象是正则对象</h2><h2 id="深拷贝实现细节-如何判断一个对象是-Date-对象"><a href="#深拷贝实现细节-如何判断一个对象是-Date-对象" class="headerlink" title="深拷贝实现细节 如何判断一个对象是 Date 对象"></a>深拷贝实现细节 如何判断一个对象是 Date 对象</h2><h2 id="map-和-object-的区别"><a href="#map-和-object-的区别" class="headerlink" title="map 和 object 的区别"></a>map 和 object 的区别</h2><p>访问：map 通过 getkey 访问 object 直接点或者括号<br>赋值 map 通过 set 赋值 或者直接数组嵌套数组赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> showContents = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;标题&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;tags&quot;</span>, <span class="string">&quot;标签&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;categories&quot;</span>, <span class="string">&quot;目录&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;date&quot;</span>, <span class="string">&quot;创建日期&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;updateTime&quot;</span>, <span class="string">&quot;最后更新日期&quot;</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>删除 map 通过 delete 去删除 删成功 true 反之 false，不存在也是 false<br>但 obj 的话 删除不存在的属性也返回 true<br>大小：map 通过 size 访问元素个数，obj 需要通过<code>Object.keys</code>的转换才能将其转换为数组，再通过数组的<code>length</code>方法去获得或者使用<code>Reflect.ownKeys(obj)</code>也可以获取到 keys 的集合</p><p>迭代：map 有迭代器，可以直接遍历。obj 没有，但可以通过 forin 不过是无序的</p><h2 id="常用正则表达式有哪些"><a href="#常用正则表达式有哪些" class="headerlink" title="常用正则表达式有哪些"></a>常用正则表达式有哪些</h2><h2 id="对-json-的理解"><a href="#对-json-的理解" class="headerlink" title="对 json 的理解"></a>对 json 的理解</h2><p>JSON 是一种结构化数据，它是一种数据格式<br>json 必须用<code>&#123;&#125;</code>包裹，内部只能双引号。没有分号<br>方法：<br><code>JSON.stringify()</code>; 把 js 对象序列化为 json 字符串</p><p><code>JSON.parse()</code>; 把 json 字符串解析为原生 js 值</p><h2 id="js-脚本延迟加载的方式有哪些"><a href="#js-脚本延迟加载的方式有哪些" class="headerlink" title="js 脚本延迟加载的方式有哪些"></a>js 脚本延迟加载的方式有哪些</h2><p>1:defer 属性,async 属性<br>2:动态创建 DOM 方式<br>3:使用 jQuery 的 getScript 方法<br>4:使用 setTimeout 延迟方法<br>5:让 JS 最后加载 放到页面底部</p><h2 id="Unicode，UTF-8，UTF-16，UTF-32-的区别"><a href="#Unicode，UTF-8，UTF-16，UTF-32-的区别" class="headerlink" title="Unicode，UTF-8，UTF-16，UTF-32 的区别"></a>Unicode，UTF-8，UTF-16，UTF-32 的区别</h2><h2 id="常见位运算符及其运算规则"><a href="#常见位运算符及其运算规则" class="headerlink" title="常见位运算符及其运算规则"></a>常见位运算符及其运算规则</h2><h2 id="什么是-DOM-和-BOM"><a href="#什么是-DOM-和-BOM" class="headerlink" title="什么是 DOM 和 BOM"></a>什么是 DOM 和 BOM</h2><p>DOM (Document )，简称文档对象模型。通过创建树来表示文档，描述了处理网页内容的方法和接口。用 DOM API 可以轻松地删除、添加和替换节点。</p><p>BOM (browser object model)，简称浏览器对象模型。描述了与浏览器进行交互的方法和接口</p><p>BOM 的核心是 window，而 window 对象又具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都以 window 作为其 global 对象。</p><h2 id="那你知道有什么-dom-方法和-bom-方法吗"><a href="#那你知道有什么-dom-方法和-bom-方法吗" class="headerlink" title="那你知道有什么 dom 方法和 bom 方法吗"></a>那你知道有什么 dom 方法和 bom 方法吗</h2><p>dom：<br>访问节点：<br><code>document.getElementById( &quot;ID&quot; )</code> 通过指定的 ID 来返回元素<br><code>document.getElementByName( &quot;name&quot; )</code> 获取所有 name 特性等于指定值的元素<br><code>document.getElementsByTagName( &quot;p&quot; )</code> 使用指定的标签名返回所有的元素列表<br><code>document.documentElement 返回存在于 XML</code>以及 HTML 文档中的文档根节点</p><p>节点的操作：<br><code>creatElement(element)</code> 创建一个新的元素节点<br><code>appendChild()</code> 在节点列表后 添加一个新的子节点<br><code>removeChild()</code> 从一个给定元素中删除子节点</p><p>bom：<br><code>window.close();</code>//关闭窗口<br><code>window.alert( &quot;message&quot; );</code> //弹出一个具有 OK 按钮的系统消息框，显示指定的文本</p><h2 id="类数组如何转换成数组"><a href="#类数组如何转换成数组" class="headerlink" title="类数组如何转换成数组"></a>类数组如何转换成数组</h2><p>a. 使用 Array.from()<br>b. 使用 Array.prototype.slice.call()<br>c. 使用 Array.prototype.forEach()进行属性遍历并组成新的数组</p><h2 id="对-ajax-的理解-实现一个-ajax"><a href="#对-ajax-的理解-实现一个-ajax" class="headerlink" title="对 ajax 的理解 实现一个 ajax"></a>对 ajax 的理解 实现一个 ajax</h2><p>Ajax 的原理简单来说是在用户和服务器之间加了—个中间层(AJAX 引擎)，通过 XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 javascript 来操作 DOM 而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 1. 创建连接 **/</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line">xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">/** 2. 连接服务器 **/</span></span><br><span class="line">xhr.open(<span class="string">&quot;get&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">/** 3. 发送请求 **/</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">/** 4. 接受请求 **/</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">      success(xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/** false **/</span></span><br><span class="line">      fail &amp;&amp; fail(xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ajax 的优缺点<br>优点：</p><ul><li>通过异步模式，提升了用户体验.</li><li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.</li><li>Ajax 在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li><li>Ajax 可以实现动态不刷新（局部刷新）<br>缺点：</li><li>安全问题 AJAX 暴露了与服务器交互的细节。</li><li>对搜索引擎的支持比较弱。</li><li>不容易调试。</li></ul><h2 id="什么是尾调用，有什么好处"><a href="#什么是尾调用，有什么好处" class="headerlink" title="什么是尾调用，有什么好处"></a>什么是尾调用，有什么好处</h2><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是返回调用另一个函数的执行结果。</p><p>注意 结尾返回另外一个函数之后没别的操作才叫尾调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//情况2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//情况3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>情况一是调用函数 g 之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。<br>情况二也属于调用后还有操作，即使写在一行内。<br>情况三等价于 return undefined<br>属于尾调用的示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> g(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b(x)</span><br></pre></td></tr></table></figure><p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。上面代码中，函数 g 和 b 都属于尾调用，因为它们都是函数 f 的最后一步操作。</p><p>尾调用的情况下，执行栈中只有当前调用函数，取代了外层函数，这就是尾调用的优化。<br>链接:<a href="https://blog.csdn.net/weixin_45374451/article/details/106495588?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-106495588-blog-123396329.pc_relevant_multi_platform_whitelistv6&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-106495588-blog-123396329.pc_relevant_multi_platform_whitelistv6&amp;utm_relevant_index=2">尾调用</a></p><h2 id="CJS-ES"><a href="#CJS-ES" class="headerlink" title="CJS ES"></a>CJS ES</h2><p>这里的知识可以联系 bundless</p><p>cjs 是 node 的格式 es 是现代浏览器支持的格式<br>cjs 是运行时 因为他基于 node 传递的是值的拷贝<br>es 是编译时 传递的是值的引用</p><p>es 支持 tree shaking</p><p>bundless 的过程其实就是把 cjs 转 es 的过程</p><h2 id="动态类型语言和静态类型语言的区别"><a href="#动态类型语言和静态类型语言的区别" class="headerlink" title="动态类型语言和静态类型语言的区别"></a>动态类型语言和静态类型语言的区别</h2><p>通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。</p><p>动态类型语言：动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python 和 Ruby 就是一种典型的动态类型语言，其他的各种脚本语言如 VBScript 也多少属于动态类型语言。</p><p>静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有 C#、JAVA 等。</p><p>对于动态语言与静态语言的区分，套用一句流行的话就是：StaTIc typing when possible， dynamictyping when needed。</p><h2 id="强类型语言和弱类型语言的区别"><a href="#强类型语言和弱类型语言的区别" class="headerlink" title="强类型语言和弱类型语言的区别"></a>强类型语言和弱类型语言的区别</h2><p>强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量 a，那么程序根本不可能将 a 当作字符串类型处理。强类型定义语言是类型安全的语言。</p><p>弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反， 一个变量可以赋不同数据类型的值。</p><p>强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。另外，“这门语言是不是动态语言”与“这门语言是否类型安全”之间是完全没有联系的！</p><p>例如：Python 是动态语言，是强类型定义语言（类型安全的语言）; VBScript 是动态语言，是弱类型定义语言（类型不安全的语言）;JAVA 是静态语言，是强类型定义语言（类型安全的语言）。</p><h2 id="解释性语言和编译型语言的区别"><a href="#解释性语言和编译型语言的区别" class="headerlink" title="解释性语言和编译型语言的区别"></a>解释性语言和编译型语言的区别</h2><p>编译型语言：编译型语言在执行之前要先经过编译过程，编译成为一个可执行的机器语言的文件，比如 exe。因为翻译只做一遍，以后都不需要翻译，所以执行效率高。</p><p>解释型语言：解释性语言编写的程序不进行预先编译，以文本方式存储程序代码。执行时才翻译执行。程序每执行一次就要翻译一遍。</p><h2 id="fetch，实现一个-fetch"><a href="#fetch，实现一个-fetch" class="headerlink" title="fetch，实现一个 fetch"></a>fetch，实现一个 fetch</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;/some/url&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>, &#125;)</span><br><span class="line">    <span class="comment">// 第一个then  设置请求的格式</span></span><br><span class="line">        .then(<span class="function"><span class="params">e</span> =&gt;</span> e.json())</span><br><span class="line">        <span class="comment">// 第二个then 处理回调</span></span><br><span class="line">        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">         &lt;!-- data为真正数据 --&gt;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Oops, error&quot;</span>, e))</span><br></pre></td></tr></table></figure><h2 id="fetch-发送-2-次请求的原因"><a href="#fetch-发送-2-次请求的原因" class="headerlink" title="fetch 发送 2 次请求的原因"></a>fetch 发送 2 次请求的原因</h2><p>fetch 发送 post 请求的时候，总是发送 2 次，第一次状态码是 204，第二次才成功? 原因很简单，因为你用 fetch 的 post 请求的时候，导致 fetch 第一次发送了一个 Options 请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的 请求。</p><h2 id="escape，encodeURL，encodeURIComponent-的区别"><a href="#escape，encodeURL，encodeURIComponent-的区别" class="headerlink" title="escape，encodeURL，encodeURIComponent 的区别"></a>escape，encodeURL，encodeURIComponent 的区别</h2><h2 id="什么是同源-同域"><a href="#什么是同源-同域" class="headerlink" title="什么是同源/同域"></a>什么是同源/同域</h2><p>协议 域名 端口 三者相同才算同源<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220904085319.png" alt=""></p><h2 id="如何解决跨域"><a href="#如何解决跨域" class="headerlink" title="如何解决跨域"></a>如何解决跨域</h2><p>cors jsonp<br>服务端鱼服务端之间不存在跨域</p><h2 id="cookie跨域"><a href="#cookie跨域" class="headerlink" title="cookie跨域"></a>cookie跨域</h2><p>我们请求<a href="https://www.google.com/">https://www.google.com/</a>时，浏览器会自动把google.com的Cookie带过去给google的服务器，而不会把<a href="https://www.baidu.com/">https://www.baidu.com/</a>的Cookie带过去给google的服务器。</p><p>这就意味着，由于域名不同，用户向系统A登录后，系统A返回给浏览器的Cookie，用户再请求系统B的时候不会将系统A的Cookie带过去。</p><p>针对Cookie存在跨域问题，有几种解决方案：</p><ul><li>服务端将Cookie写到客户端后，客户端对Cookie进行解析，将Token解析出来，此后请求都把这个Token带上就行了</li><li>多个域名共享Cookie，在写到客户端的时候设置Cookie的domain。</li><li>将Token保存在SessionStroage中（不依赖Cookie就没有跨域的问题了）</li></ul><h2 id="实现数组去重"><a href="#实现数组去重" class="headerlink" title="实现数组去重"></a>实现数组去重</h2><p>见数组去重篇 一般是 reduce+includes，set</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="介绍一下-http1-3"><a href="#介绍一下-http1-3" class="headerlink" title="介绍一下 http1-3"></a>介绍一下 http1-3</h2><p>http1 是 0.9 的下一个版本，这个版本中他可以传输任何形式的内容不限于文本，还加入了 post 和 head 请求，且加入了更多标识信息的手段，比如 header 头部和响应码，以及对于资源提供了缓存。算是一个大更新，不过缺点也存在，也就是这个版本不支持断点续传，且没有传递主机名 hostname(大概是身份识别的一个影响)，最重要的是服务器发送完响应就关闭了 TCP 连接，导致每次请求都要重新建立连接,我们知道 TCP 三次握手的成本是比较高的，不过他有一个缓解的方法，就是设置<code>Connection:keep-alive</code>让服务端先不要关闭 TCP 连接。从而达到了类似 TCP 复用的目的(这里经常忘记断点续传，因为这个内容确实不熟悉)</p><p>在 1.1 的时候，引入了长连接，默认 TCP 不去关闭，可以被多个请求复用。且支持断点续传。这个版本还新增了并发连接，管道机制，增加了 PUTDELETEOPTIONSPATCH 等方法，允许响应数据分块，有利于传输大文件，强制要求 host 头，让主机托管成为可能。不过也因为引入了长连接，带来了跨越两个版本的问题，队头阻塞，而且 1.1 版本中越来越多的头字段也暴露了引入 header 的问题，无状态。以及明文传输导致的数据安全性问题。</p><p>在 2.0 之前有个叫 spdy 的协议，是改进版本的 1.1,提出了多路复用的方案，通过多个请求 stream 共享一个 TCP 连接的方式，解决了 http 队头阻塞的问题。还设置了请求优先级，重要的请求优先响应() 压缩了 header 并且加密传输和服务端推送</p><p>2.0 就是基于 spdy 协议的，通过多路复用和流解决了队头阻塞的问题，使用了 hpack 算法解决了头部过大的问题。2.0 协议的特点是二进制分针，头部压缩，多路复用和服务端推送，流。</p><p>不过 2.0 尚未解决 TCP 阻塞的问题，这个问题根本上是传输层的问题，要想改变这个历史已久的协议要同时改变其他硬件厂商和网络厂商的设备，是不太可能的。于是 3.0 面向 UDP 协议做了新的调整。也就是 QUIC 协议</p><p>3.0 的 QUIC 协议要求严格加密</p><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。<br>进行三次握手：</p><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SENT 状态。</p><p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。</p><p>在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p><p>确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p><p>在socket编程中，客户端执行connect()时，将触发三次握手。</p><h2 id="为什么-ConnectionKeepalive-不能根本解决问题"><a href="#为什么-ConnectionKeepalive-不能根本解决问题" class="headerlink" title="为什么 ConnectionKeepalive 不能根本解决问题"></a>为什么 ConnectionKeepalive 不能根本解决问题</h2><p>头部字段不是标准的，不同浏览器实现起来可能不一样，所以不能从根本上解决问题</p><h2 id="并发并行"><a href="#并发并行" class="headerlink" title="并发并行"></a>并发并行</h2><p>并发指的是多个事件在同一时间段执行<br>并行是指多个事件在同一时间点执行</p><h2 id="什么是主机托管"><a href="#什么是主机托管" class="headerlink" title="什么是主机托管"></a>什么是主机托管</h2><h2 id="什么是无状态"><a href="#什么是无状态" class="headerlink" title="什么是无状态"></a>什么是无状态</h2><p>无状态指的是对于请求头没有记忆能力。于是 2.0 提出的 hpack 解决了这个问题</p><h2 id="http1-之前还有别的版本吗"><a href="#http1-之前还有别的版本吗" class="headerlink" title="http1 之前还有别的版本吗"></a>http1 之前还有别的版本吗</h2><p>0.9 为了传输 HTML(文本)诞生，而且只能发 GET 请求，请求报文只有一行，没有标识信息，服务器发完就关闭了 TCP</p><h2 id="讲一下-HTTP-的请求报文"><a href="#讲一下-HTTP-的请求报文" class="headerlink" title="讲一下 HTTP 的请求报文"></a>讲一下 HTTP 的请求报文</h2><p>由三部分组成<br>请求行 请求头 请求体<br>请求行由请求方法 URL 协议版本组成<br>请求头<br>空行(注意)<br>请求体</p><h2 id="请求方法-什么是幂等-什么是不幂等"><a href="#请求方法-什么是幂等-什么是不幂等" class="headerlink" title="请求方法 什么是幂等 什么是不幂等"></a>请求方法 什么是幂等 什么是不幂等</h2><p>GET POST HEAD DELETE PATCH OPTION PUT</p><h2 id="常见的请求头？"><a href="#常见的请求头？" class="headerlink" title="常见的请求头？"></a>常见的请求头？</h2><p>Referer<br>Cookie<br>Connection<br>Content-Length<br>Accept-language<br>…</p><h2 id="怎么进行断点续传"><a href="#怎么进行断点续传" class="headerlink" title="怎么进行断点续传"></a>怎么进行断点续传</h2><h2 id="前端如何设置缓存"><a href="#前端如何设置缓存" class="headerlink" title="前端如何设置缓存"></a>前端如何设置缓存</h2><h2 id="缓存中的-Etag-和-Expires-是什么区别"><a href="#缓存中的-Etag-和-Expires-是什么区别" class="headerlink" title="缓存中的 Etag 和 Expires 是什么区别"></a>缓存中的 Etag 和 Expires 是什么区别</h2><h2 id="缓存新鲜度是怎么计算的"><a href="#缓存新鲜度是怎么计算的" class="headerlink" title="缓存新鲜度是怎么计算的"></a>缓存新鲜度是怎么计算的</h2><h2 id="有什么响应码"><a href="#有什么响应码" class="headerlink" title="有什么响应码"></a>有什么响应码</h2><p>100<br>101<br>200<br>201<br>202<br>203<br>300<br>301<br>302<br>304<br>400<br>404<br>500<br>504</p><h2 id="TCP-和-UDP-什么区别"><a href="#TCP-和-UDP-什么区别" class="headerlink" title="TCP 和 UDP 什么区别"></a>TCP 和 UDP 什么区别</h2><h2 id="TCP-连接的过程"><a href="#TCP-连接的过程" class="headerlink" title="TCP 连接的过程"></a>TCP 连接的过程</h2><h2 id="说一下-1-1-的管道机制"><a href="#说一下-1-1-的管道机制" class="headerlink" title="说一下 1.1 的管道机制"></a>说一下 1.1 的管道机制</h2><h2 id="如何进行大文件传输"><a href="#如何进行大文件传输" class="headerlink" title="如何进行大文件传输"></a>如何进行大文件传输</h2><p>前端：文件名转 md5，文件切片，上传完后合并</p><h2 id="为什么-1，1-强制要求-host-头"><a href="#为什么-1，1-强制要求-host-头" class="headerlink" title="为什么 1，1 强制要求 host 头"></a>为什么 1，1 强制要求 host 头</h2><h2 id="什么是-TCP-阻塞-什么是-HTTP-阻塞-怎么解决"><a href="#什么是-TCP-阻塞-什么是-HTTP-阻塞-怎么解决" class="headerlink" title="什么是 TCP 阻塞 什么是 HTTP 阻塞 怎么解决"></a>什么是 TCP 阻塞 什么是 HTTP 阻塞 怎么解决</h2><p>TCP 阻塞是指当一个 TCP 的分节丢失的时候，因为 TCP 本身是可靠传输，所以他的后续分节会一直被接收端保存，直到丢失的这一个分节传输到接收端为止。</p><p>这样的可靠传输能保证数据的完整性，但是却影响了后续分节的传输。比如发三个图片第一个图片的分节丢失，也影响到后面的两个图片数据传输。</p><p>HTTP 队头阻塞是指 1.1 协议中的管道传输，由于管道传输的性质是可以多个请求同时发送但是要求响应顺序一致，所以导致了 http 阻塞。</p><p>解决 HTTP 阻塞靠的是 2.0 中多路复用和流的概念，多路复用有点类似于管道，不过他使得同多个请求共享同一个 TCP 连接，在这个连接中他会将报文拆分成二进制帧发送，服务器接收到乱序的帧重新组合成为对应的报文，所以就不存在先后的问题，也就解决了 HTTP 的队头阻塞</p><p>解决 TCP 阻塞靠的是 QUIC 协议，因为 TCP 阻塞本质上是传输层的问题，在改变协议困难的情况下(现在绝大部分硬件厂商网络运营商都是这样的协议)为了解决这个问题，从另外一个协议下手，也就是 UDP。UDP 不管顺序，丢包方面也有 QUIC 对应的方法去处理(多路复用，有多个独立的逻辑数据流)从而解决 TCP 阻塞的问题</p><h2 id="http1-1-是怎么解决队头阻塞-实际上是缓解"><a href="#http1-1-是怎么解决队头阻塞-实际上是缓解" class="headerlink" title="http1.1 是怎么解决队头阻塞(实际上是缓解)"></a>http1.1 是怎么解决队头阻塞(实际上是缓解)</h2><p>使用了域名分片的技术<br>一个域名拥有 6 个 TCP 连接，有多级域名的时候能吧更多的资源分配出来。<br>引起别的问题：因为 TCP 连接要经过 dns，三次握手，慢启动等操作。所以对于服务器来说连接太多容易造成网络拥挤</p><h2 id="http2-0-有什么新特性"><a href="#http2-0-有什么新特性" class="headerlink" title="http2.0 有什么新特性"></a>http2.0 有什么新特性</h2><p>二进制分帧，多路复用，头部压缩，服务端推送，流</p><h2 id="Hpack-算法原理"><a href="#Hpack-算法原理" class="headerlink" title="Hpack 算法原理"></a>Hpack 算法原理</h2><p>哈希表 传索引 哈夫曼收集整数和</p><h2 id="2-0-之前是怎么分帧的"><a href="#2-0-之前是怎么分帧的" class="headerlink" title="2.0 之前是怎么分帧的"></a>2.0 之前是怎么分帧的</h2><h2 id="二进制分帧是怎么实现优先级和流量控制的"><a href="#二进制分帧是怎么实现优先级和流量控制的" class="headerlink" title="二进制分帧是怎么实现优先级和流量控制的"></a>二进制分帧是怎么实现优先级和流量控制的</h2><h2 id="什么是多路复用"><a href="#什么是多路复用" class="headerlink" title="什么是多路复用"></a>什么是多路复用</h2><h2 id="怎么进行服务端推送"><a href="#怎么进行服务端推送" class="headerlink" title="怎么进行服务端推送"></a>怎么进行服务端推送</h2><h2 id="2-0-有什么问题"><a href="#2-0-有什么问题" class="headerlink" title="2.0 有什么问题"></a>2.0 有什么问题</h2><h2 id="http3-0-有什么新特性"><a href="#http3-0-有什么新特性" class="headerlink" title="http3.0 有什么新特性"></a>http3.0 有什么新特性</h2><h2 id="QUIC-有安全问题吗"><a href="#QUIC-有安全问题吗" class="headerlink" title="QUIC 有安全问题吗"></a>QUIC 有安全问题吗</h2><h2 id="UDP-丢失数据包的问题在-QUIC-中是怎么解决的"><a href="#UDP-丢失数据包的问题在-QUIC-中是怎么解决的" class="headerlink" title="UDP 丢失数据包的问题在 QUIC 中是怎么解决的"></a>UDP 丢失数据包的问题在 QUIC 中是怎么解决的</h2><h2 id="说一下-TLS"><a href="#说一下-TLS" class="headerlink" title="说一下 TLS"></a>说一下 TLS</h2><h2 id="RTT-是什么意思"><a href="#RTT-是什么意思" class="headerlink" title="RTT 是什么意思"></a>RTT 是什么意思</h2><h2 id="TLS1-3-有什么问题吗"><a href="#TLS1-3-有什么问题吗" class="headerlink" title="TLS1.3 有什么问题吗"></a>TLS1.3 有什么问题吗</h2><h2 id="QUIC-是如何确立一个连接的"><a href="#QUIC-是如何确立一个连接的" class="headerlink" title="QUIC 是如何确立一个连接的"></a>QUIC 是如何确立一个连接的</h2><h2 id="说一下-HTTP1-3-分别使用了多少个-RTT"><a href="#说一下-HTTP1-3-分别使用了多少个-RTT" class="headerlink" title="说一下 HTTP1-3 分别使用了多少个 RTT"></a>说一下 HTTP1-3 分别使用了多少个 RTT</h2><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if v-show"></a>v-if v-show</h2><h2 id="vue2-为什么不能监听数组"><a href="#vue2-为什么不能监听数组" class="headerlink" title="vue2 为什么不能监听数组"></a>vue2 为什么不能监听数组</h2><p>其实是可以监听的，原因在于<code>Object.defineProperty</code>这个 api 上，他是可以暴力监听数组中的所有元素的，以 index 的形式。但是如果数组内部有百万个元素，每次监听都要发生改变，这样就会造成很大的性能问题了。所以选择不去监听。Vue3 中使用了 Proxy，直接劫持整个数组对象，就没这个问题了。</p><h2 id="使用过-Object-defineProperty-吗"><a href="#使用过-Object-defineProperty-吗" class="headerlink" title="使用过 Object.defineProperty 吗"></a>使用过 Object.defineProperty 吗</h2><p>参加手写篇</p><p>可以劫持对象的属性实现响应式 缺点是不支持增加和删除<br>且对于数组来说 性能问题 导致不采用劫持<br>另外要实现劫持 可以把value作为形参传递 避免return的时候无限递归<br>且注意是劫持新对象的属性的时候才是默认不可枚举不可修改不可删除，已有的对象不会有这个操作</p><h2 id="nextTick-的原理"><a href="#nextTick-的原理" class="headerlink" title="nextTick 的原理"></a>nextTick 的原理</h2><h2 id="vue3-在响应式上做了什么优化"><a href="#vue3-在响应式上做了什么优化" class="headerlink" title="vue3 在响应式上做了什么优化"></a>vue3 在响应式上做了什么优化</h2><p>使用了proxy进行一个懒处理，标识了依赖的状态是否重复收集，处理了很多特殊案例比如嵌套effect，多次reactive同个对象，以及同个响应式对象被多次分配，数组等</p><h2 id="为什么-Proxy-中需要-Reflect"><a href="#为什么-Proxy-中需要-Reflect" class="headerlink" title="为什么 Proxy 中需要 Reflect"></a>为什么 Proxy 中需要 Reflect</h2><p>Reflect的作用是为了修改对象的指向，比如说有个对象继承了另外一个响应式对象，访问对象本身的属性的时候，会被proxy劫持到返回继承对象的属性，如果此时get中传递了receiver，Reflect接收了receiver，那么他就能将其修改为正确的指向，访问对象本身的属性</p><h2 id="Proxy-的-get-的三个参数的意义-为什么需要-receiver"><a href="#Proxy-的-get-的三个参数的意义-为什么需要-receiver" class="headerlink" title="Proxy 的 get 的三个参数的意义/为什么需要 receiver"></a>Proxy 的 get 的三个参数的意义/为什么需要 receiver</h2><p>get 三个参数是target key receiver<br>target是指被劫持的对象 key是劫持对象的属性 receiver是代理对象</p><p>前两个没啥好说的 主要是receiver这个 他是为了传递正确的指向而产生的，见上面的例子</p><p>receiver不仅表示代理对象本身，还有可能表示继承于代理对象的对象</p><h2 id="MVC-和-MVVM-的区别"><a href="#MVC-和-MVVM-的区别" class="headerlink" title="MVC 和 MVVM 的区别"></a>MVC 和 MVVM 的区别</h2><h2 id="为什么-data-是一个函数"><a href="#为什么-data-是一个函数" class="headerlink" title="为什么 data 是一个函数"></a>为什么 data 是一个函数</h2><h2 id="Vue-组件通讯有那些方式？"><a href="#Vue-组件通讯有那些方式？" class="headerlink" title="Vue 组件通讯有那些方式？"></a>Vue 组件通讯有那些方式？</h2><h2 id="Vue-的生命周期方法有那些？在哪一步发送请求"><a href="#Vue-的生命周期方法有那些？在哪一步发送请求" class="headerlink" title="Vue 的生命周期方法有那些？在哪一步发送请求"></a>Vue 的生命周期方法有那些？在哪一步发送请求</h2><h2 id="说说-Vue-的内置指令。"><a href="#说说-Vue-的内置指令。" class="headerlink" title="说说 Vue 的内置指令。"></a>说说 Vue 的内置指令。</h2><h2 id="怎么理解-Vue-的单向数据流"><a href="#怎么理解-Vue-的单向数据流" class="headerlink" title="怎么理解 Vue 的单向数据流"></a>怎么理解 Vue 的单向数据流</h2><h2 id="computed-和-watch-的区别和运用的场景"><a href="#computed-和-watch-的区别和运用的场景" class="headerlink" title="computed 和 watch 的区别和运用的场景"></a>computed 和 watch 的区别和运用的场景</h2><h2 id="未被-template-使用的元素，computed-中的属性依赖的-data-发生改变了，computed-会重新计算吗"><a href="#未被-template-使用的元素，computed-中的属性依赖的-data-发生改变了，computed-会重新计算吗" class="headerlink" title="未被 template 使用的元素，computed 中的属性依赖的 data 发生改变了，computed 会重新计算吗"></a>未被 template 使用的元素，computed 中的属性依赖的 data 发生改变了，computed 会重新计算吗</h2><h2 id="v-if-和-v-for-为什么不建议一起使用。"><a href="#v-if-和-v-for-为什么不建议一起使用。" class="headerlink" title="v-if 和 v-for 为什么不建议一起使用。"></a>v-if 和 v-for 为什么不建议一起使用。</h2><h2 id="Vue-响应式数据的原理"><a href="#Vue-响应式数据的原理" class="headerlink" title="Vue 响应式数据的原理"></a>Vue 响应式数据的原理</h2><h2 id="vue3-0-用过吗-了解多少"><a href="#vue3-0-用过吗-了解多少" class="headerlink" title="vue3.0 用过吗 了解多少"></a>vue3.0 用过吗 了解多少</h2><h2 id="Vue-的父子组件生命周期钩子执行顺序"><a href="#Vue-的父子组件生命周期钩子执行顺序" class="headerlink" title="Vue 的父子组件生命周期钩子执行顺序"></a>Vue 的父子组件生命周期钩子执行顺序</h2><h2 id="虚拟-DOM-是什么-有什么优缺点"><a href="#虚拟-DOM-是什么-有什么优缺点" class="headerlink" title="虚拟 DOM 是什么 有什么优缺点"></a>虚拟 DOM 是什么 有什么优缺点</h2><h2 id="虚拟-DOM-原理"><a href="#虚拟-DOM-原理" class="headerlink" title="虚拟 DOM 原理"></a>虚拟 DOM 原理</h2><h2 id="v-model-的原理"><a href="#v-model-的原理" class="headerlink" title="v-model 的原理"></a>v-model 的原理</h2><h2 id="vue-事件绑定原理"><a href="#vue-事件绑定原理" class="headerlink" title="vue 事件绑定原理"></a>vue 事件绑定原理</h2><h2 id="v-for-为什么要加-key"><a href="#v-for-为什么要加-key" class="headerlink" title="v-for 为什么要加 key"></a>v-for 为什么要加 key</h2><h2 id="手写发布订阅"><a href="#手写发布订阅" class="headerlink" title="手写发布订阅"></a>手写发布订阅</h2><h2 id="vue-router-路由钩子函数是什么-执行顺序是什么"><a href="#vue-router-路由钩子函数是什么-执行顺序是什么" class="headerlink" title="vue-router 路由钩子函数是什么 执行顺序是什么"></a>vue-router 路由钩子函数是什么 执行顺序是什么</h2><h2 id="vue-router-原理"><a href="#vue-router-原理" class="headerlink" title="vue-router 原理"></a>vue-router 原理</h2><h2 id="vue-router-动态路由是什么？有什么问题"><a href="#vue-router-动态路由是什么？有什么问题" class="headerlink" title="vue-router 动态路由是什么？有什么问题"></a>vue-router 动态路由是什么？有什么问题</h2><h2 id="Vuex-的理解"><a href="#Vuex-的理解" class="headerlink" title="Vuex 的理解"></a>Vuex 的理解</h2><h2 id="Vuex-页面刷新数据丢失怎么解决"><a href="#Vuex-页面刷新数据丢失怎么解决" class="headerlink" title="Vuex 页面刷新数据丢失怎么解决"></a>Vuex 页面刷新数据丢失怎么解决</h2><h2 id="Vuex-为什么要分模块而且加命名空间"><a href="#Vuex-为什么要分模块而且加命名空间" class="headerlink" title="Vuex 为什么要分模块而且加命名空间"></a>Vuex 为什么要分模块而且加命名空间</h2><h2 id="使用过-Vue-SSR-吗？说一说-SSR"><a href="#使用过-Vue-SSR-吗？说一说-SSR" class="headerlink" title="使用过 Vue SSR 吗？说一说 SSR"></a>使用过 Vue SSR 吗？说一说 SSR</h2><h2 id="Vue-使用了哪些设计者模式"><a href="#Vue-使用了哪些设计者模式" class="headerlink" title="Vue 使用了哪些设计者模式"></a>Vue 使用了哪些设计者模式</h2><h2 id="你做过哪些-vue-的性能优化"><a href="#你做过哪些-vue-的性能优化" class="headerlink" title="你做过哪些 vue 的性能优化"></a>你做过哪些 vue 的性能优化</h2><h2 id="Vue-mixin-的使用场景和原理"><a href="#Vue-mixin-的使用场景和原理" class="headerlink" title="Vue.mixin 的使用场景和原理"></a>Vue.mixin 的使用场景和原理</h2><h2 id="keep-alive-使用场景"><a href="#keep-alive-使用场景" class="headerlink" title="keep-alive 使用场景"></a>keep-alive 使用场景</h2><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><h2 id="手撕-keep-alive"><a href="#手撕-keep-alive" class="headerlink" title="手撕 keep-alive"></a>手撕 keep-alive</h2><h2 id="Vue-set-方法原理"><a href="#Vue-set-方法原理" class="headerlink" title="Vue.set 方法原理"></a>Vue.set 方法原理</h2><h2 id="Vue-extend-原理"><a href="#Vue-extend-原理" class="headerlink" title="Vue.extend 原理"></a>Vue.extend 原理</h2><h2 id="写过自定义指令吗-原理是啥"><a href="#写过自定义指令吗-原理是啥" class="headerlink" title="写过自定义指令吗 原理是啥"></a>写过自定义指令吗 原理是啥</h2><h2 id="什么是-AST-语法树"><a href="#什么是-AST-语法树" class="headerlink" title="什么是 AST 语法树"></a>什么是 AST 语法树</h2><h2 id="Vue-修饰符有哪些"><a href="#Vue-修饰符有哪些" class="headerlink" title="Vue 修饰符有哪些"></a>Vue 修饰符有哪些</h2><h2 id="Vue-模板编译原理"><a href="#Vue-模板编译原理" class="headerlink" title="Vue 模板编译原理"></a>Vue 模板编译原理</h2><h2 id="生命周期钩子是如何实现的"><a href="#生命周期钩子是如何实现的" class="headerlink" title="生命周期钩子是如何实现的"></a>生命周期钩子是如何实现的</h2><h2 id="函数式组件使用场景和原理"><a href="#函数式组件使用场景和原理" class="headerlink" title="函数式组件使用场景和原理"></a>函数式组件使用场景和原理</h2><h2 id="diff-算法了解吗"><a href="#diff-算法了解吗" class="headerlink" title="diff 算法了解吗"></a>diff 算法了解吗</h2><h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="OSI-七层"><a href="#OSI-七层" class="headerlink" title="OSI 七层"></a>OSI 七层</h2><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="如何实现图片的懒加载"><a href="#如何实现图片的懒加载" class="headerlink" title="如何实现图片的懒加载"></a>如何实现图片的懒加载</h2><h2 id="行内-块-空元素"><a href="#行内-块-空元素" class="headerlink" title="行内 块 空元素"></a>行内 块 空元素</h2><p>行内元素有：<code>a</code> <code>b</code> <code>span</code> <code>img</code> <code>input</code> <code>select</code> <code>strong</code> <code>button</code> ；<br>块级元素有：<code>div</code> <code>ul</code> <code>ol</code> <code>li</code> <code>dl</code> <code>dt</code> <code>dd</code> <code>h1</code> <code>h2</code> <code>h3</code> <code>h4</code> <code>h5</code> <code>h6</code> <code>p</code><br>空元素，即没有内容的 HTML 元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：<br>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code></p><h2 id="link和import-的区别"><a href="#link和import-的区别" class="headerlink" title="link和import 的区别"></a><code>link</code>和<code>import</code> 的区别</h2><p>link 除了引用样式文件，还可以引用图片等资源文件，而 import 只引用样式文件<br>link 属于 html 范畴 import 属于 css 范畴</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;any&quot;</span> <span class="attr">mask</span> <span class="attr">href</span>=<span class="string">&quot;//www.baidu.com/img/baidu.svg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>兼容性不同，link 不存在兼容性的问题，import 在 IE5 以上支持，是 css2.1 新增的<br>在样式表文件可以使用 import 导入其它的样式表文件，而 link 不可以<br>link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。<br>link 支持使用 Javascript 控制 DOM 去改变样式；而@import 不支持。</p><h2 id="你了解的-video-标签"><a href="#你了解的-video-标签" class="headerlink" title="你了解的 video 标签"></a>你了解的 video 标签</h2><h2 id="h5-新特性有哪些"><a href="#h5-新特性有哪些" class="headerlink" title="h5 新特性有哪些"></a>h5 新特性有哪些</h2><h2 id="H5-离线存储"><a href="#H5-离线存储" class="headerlink" title="H5 离线存储"></a>H5 离线存储</h2><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p><p>原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p><p>使用方法： （1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">manifest</span>=<span class="string">&quot;index.manifest&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CopyErrorCopied<br>（2）在 cache.manifest 文件中编写需要离线存储的资源：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png</span><br><span class="line">FALLBACK: / /offline.html CopyErrorCopied</span><br></pre></td></tr></table></figure><p>CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。<br>NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。<br>FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。<br>（3）在离线状态时，操作 window.applicationCache 进行离线缓存的操作。</p><p>如何更新缓存：</p><p>（1）更新 manifest 文件</p><p>（2）通过 javascript 操作</p><p>（3）清除浏览器缓存</p><h2 id="dragAPI"><a href="#dragAPI" class="headerlink" title="dragAPI"></a>dragAPI</h2><p>一个典型的拖放操作是这样的：用户选中一个可拖拽的(draggable) 元素，并将其拖拽（鼠标不放开）到一个可放置的(droppable) 元素，然后释放鼠标。</p><p>在这个过程中，最重要的三个点是：</p><p>让元素可拖拽<br>让另一个元素支持可放置<br>可拖拽和可放置元素之间的数据传递<br>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。<br>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。<br>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。<br>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。<br>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。<br>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。<br>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</p><div class="note primary flat"><p>选中 —-&gt; 拖动 —-&gt; 释放</p></div><p>拖动事件：dragstart、drag、dragend</p><p>放置事件：dragenter、dragover、drop</p><p>拖拽事件流：当拖动一个元素放置到目标元素上的时候将会按照如下顺序依次触发 dragstart-&gt;drag-&gt;dragenter-&gt;dragover-&gt;drop-&gt;dragend</p><h2 id="meta-标签有哪些-有什么作用"><a href="#meta-标签有哪些-有什么作用" class="headerlink" title="meta 标签有哪些 有什么作用"></a>meta 标签有哪些 有什么作用</h2><p>meta 标签由 name 和 content 属性定义</p><p>用于描述网页文档的属性 比如 网页的作者 关键词 网站描述等。</p><p>以下是一些固定的 name 作为大家的共识</p><p>常用 meta 标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字符集 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 页面关键词 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;关键词&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 页面描述 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;页面描述内容&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 页面重定向和刷新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>适配移动端</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>其中，content 参数有以下几种：<br>width viewport ：宽度(数值/device-width)<br>height viewport ：高度(数值/device-height)<br>initial-scale ：初始缩放比例<br>maximum-scale ：最大缩放比例<br>minimum-scale ：最小缩放比例<br>user-scalable ：是否允许用户缩放(yes/no）</p><p>搜索引擎索引方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中，content 参数有以下几种：</p><p>all：文件将被检索，且页面上的链接可以被查询；<br>none：文件将不被检索，且页面上的链接不可以被查询；<br>index：文件将被检索；<br>follow：页面上的链接可以被查询；<br>noindex：文件将不被检索；<br>nofollow：页面上的链接不可以被查询。</p><h2 id="script-标签中-defer-和-async-的区别"><a href="#script-标签中-defer-和-async-的区别" class="headerlink" title="script 标签中 defer 和 async 的区别"></a>script 标签中 defer 和 async 的区别</h2><p>如果没有 defer 和 async 标签,浏览器就会立刻加载并执行对应的脚本 不会等待后续加载的文档元素,读到就开始加载<br>三者区别如下<br><a href="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220905102104.png">https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220905102104.png</a></p><p>蓝色表示 js 网络加载时间,红色表示 js 脚本执行时间,绿色表示 html 解析</p><p>defer 和 async 属性都是去异步的加载 js 脚本 所以不会阻塞页面的解析</p><p>区别在于:</p><ul><li>执行顺序: 多个带 async 的标签 不能保证执行顺序 多个带 defer 的标签 按序执行</li><li>脚本是否并行执行:<br>对于 async 来说,后续的文档加载与执行和 js 脚本加载与执行是并行的<br>对于 defer 来说,后续文档的加载和 js 脚本加载是并行的,但是执行需要等待文档元素解析完之后,在<code>DOMContentLoaded</code>事件之前执行.</li></ul><p>补充，DOMContentLoaded 事件</p><ul><li>是等 HTML 文档完全加载完和解析完之后运行的事件</li><li>在 load 事件之前。</li><li>不用等样式表、图像等完成加载</li></ul><h2 id="Doctype-作用"><a href="#Doctype-作用" class="headerlink" title="Doctype 作用"></a>Doctype 作用</h2><p>Doctype 是 html 的文档类型声明,告诉浏览器要以什么样的文档定义类型来解析文档,那么此时不同的渲染模式会影响 js 和 css 的解析</p><p>而且他必须声明在第一行,(不声明的话 就是 怪异模式)</p><p>目前有两种模式:</p><ol><li>标准模式: 告诉浏览器使用 W3C 的标准去解析渲染页面.</li><li>怪异模式: 告诉浏览器使用自己的怪异模式去解析渲染页面,在此模式中以一种向后兼容的方式进行</li></ol><p>获取模式:<code>document.compatMode</code></p><h2 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h2><p>都是用于请求相应的网络资源,但主要不同点在于</p><p>当浏览器解析到 src 所对应的资源的时候,会暂停其他资源的下载和处理,直到将该资源解析完毕,一般是用于标签内容的替换,比如 img</p><p>当浏览器解析到 href 的时候,会并行下载对应的资源,不会造成阻塞</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="BFC-的理解"><a href="#BFC-的理解" class="headerlink" title="BFC 的理解"></a>BFC 的理解</h2><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有 Block-level box 参与,<br>哪些情况会产生 BFC:<br>根元素<br>float 属性不为 none<br>position 为 absolute 或 fixed<br>display 为 inline-block, table-cell, table-caption, flex, inline-flex<br>overflow 不为 visible</p><h2 id="盒模型的理解"><a href="#盒模型的理解" class="headerlink" title="盒模型的理解"></a>盒模型的理解</h2><p>盒模型都是由四个部分组成的，分别是 margin，border，padding 和 content</p><p>标准盒模型和 IE 盒模型的区别在于设置 width 和 height 时，所对应的范围不同</p><p>标准盒模型的 width 和 height 属性只包括 content<br>ie 盒模型的 width 和 height 包括 border padding content</p><p>可以通过 box-sizing 来改变元素的盒模型<br>标准盒模型:content-box;<br>怪异盒模型:border-box;</p><h2 id="animation-属性"><a href="#animation-属性" class="headerlink" title="animation 属性"></a>animation 属性</h2><h2 id="img-和-backgroundimg-的区别"><a href="#img-和-backgroundimg-的区别" class="headerlink" title="img 和 backgroundimg 的区别"></a>img 和 backgroundimg 的区别</h2><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h2 id="margin-left-和-margin-top-自身宽度的一半和-transform-translate-50-50-，有什么区别"><a href="#margin-left-和-margin-top-自身宽度的一半和-transform-translate-50-50-，有什么区别" class="headerlink" title="margin-left 和 margin-top 自身宽度的一半和 transform:translate(-50%,-50%)，有什么区别"></a>margin-left 和 margin-top 自身宽度的一半和 transform:translate(-50%,-50%)，有什么区别</h2><h2 id="在对于没有设置高度，高度由内容撑起来的盒子上有什么区别，这种盒子可以使用什么方式垂直水平居中"><a href="#在对于没有设置高度，高度由内容撑起来的盒子上有什么区别，这种盒子可以使用什么方式垂直水平居中" class="headerlink" title="在对于没有设置高度，高度由内容撑起来的盒子上有什么区别，这种盒子可以使用什么方式垂直水平居中"></a>在对于没有设置高度，高度由内容撑起来的盒子上有什么区别，这种盒子可以使用什么方式垂直水平居中</h2><h2 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h2><p>1.通配符选择器和继承:权重为 0， 2.标签选择器:权重为 0001 3.类选择器:权重为 0010<br>4.id 选择器:权重为 0100 5.行内样式:权重为 1000<br>6.!important:权重为无穷大</p><h2 id="重绘和回流-为什么要减少回流-什么情况引起回流"><a href="#重绘和回流-为什么要减少回流-什么情况引起回流" class="headerlink" title="重绘和回流 为什么要减少回流 什么情况引起回流"></a>重绘和回流 为什么要减少回流 什么情况引起回流</h2><p>重绘简单来说就是重新绘画，当一个元素更换背景，更换颜色，虽然不会影响页面布局，但是颜色或者背景变了，就会重新渲染页面，这就是重绘</p><h2 id="flex1-代表什么"><a href="#flex1-代表什么" class="headerlink" title="flex1 代表什么"></a>flex1 代表什么</h2><h2 id="默认-1rem-是多少-px"><a href="#默认-1rem-是多少-px" class="headerlink" title="默认 1rem 是多少 px"></a>默认 1rem 是多少 px</h2><p>16</p><h2 id="chrome-最小字体是多少-px-怎么实现更小的字体"><a href="#chrome-最小字体是多少-px-怎么实现更小的字体" class="headerlink" title="chrome 最小字体是多少 px 怎么实现更小的字体"></a>chrome 最小字体是多少 px 怎么实现更小的字体</h2><p>最小 12px</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><h2 id="SVG-和-Canvas-区别"><a href="#SVG-和-Canvas-区别" class="headerlink" title="SVG 和 Canvas 区别"></a>SVG 和 Canvas 区别</h2><h2 id="外边距塌陷问题"><a href="#外边距塌陷问题" class="headerlink" title="外边距塌陷问题"></a>外边距塌陷问题</h2><p>当两个在标准流中相邻（兄弟或父子关系）的块级元素的外边距组合在一起的时候，垂直方向上会发生外边距塌陷的问题，计算方式：</p><ol><li>两个都为正，取最大</li><li>一正一负加起来</li><li>两个负 取绝对值最大</li></ol><h2 id="父类高度塌陷问题"><a href="#父类高度塌陷问题" class="headerlink" title="父类高度塌陷问题"></a>父类高度塌陷问题</h2><p>如果子元素都是浮动</p><ol><li>直接给父元素设置高度，在子元素改变的情况下，此方法使用起来比较繁杂。</li><li>给父元素直接设置 overflow:hidden;样式</li><li>父元结束标签之前加空 div，样式为 clear：both；</li><li>伪元素选择器,父元素加上 clearfix</li></ol><h2 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">伪类  :link  :hover         伪元素  ::before    ::after</span><br></pre></td></tr></table></figure><p>其中伪类和伪元素的根本区别在于：它们是否创造了新的元素,, 这个新创造的元素就叫 “伪无素” 。<br>伪元素/伪对象：不存在在 DOM 文档中，是虚拟的元素，是创建新元素。 这个新元素(伪元素) 是某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中.<br>伪类：存在 DOM 文档中，(无标签,找不到, 只有符合触发条件时才能看到 ), 逻辑上存在但在文档树中却无须标识的“幽灵”分类。</p><h2 id="css-继承"><a href="#css-继承" class="headerlink" title="css 继承"></a>css 继承</h2><p>只有颜色，文字，字体间距行高对齐方式，和列表的样式可以继承<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220225154948.png" alt=""></p><h2 id="cssinjs"><a href="#cssinjs" class="headerlink" title="cssinjs"></a>cssinjs</h2><h2 id="cssmodule"><a href="#cssmodule" class="headerlink" title="cssmodule"></a>cssmodule</h2><h2 id="为什么要使用-tailwind"><a href="#为什么要使用-tailwind" class="headerlink" title="为什么要使用 tailwind"></a>为什么要使用 tailwind</h2><h1 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h1><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><h2 id="GUI-线程和-JS-线程"><a href="#GUI-线程和-JS-线程" class="headerlink" title="GUI 线程和 JS 线程"></a>GUI 线程和 JS 线程</h2><h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2><h2 id="性能指标，怎么看"><a href="#性能指标，怎么看" class="headerlink" title="性能指标，怎么看"></a>性能指标，怎么看</h2><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h2 id="设计模式的原则是什么"><a href="#设计模式的原则是什么" class="headerlink" title="设计模式的原则是什么"></a>设计模式的原则是什么</h2><ol><li>开放封闭原则 对拓展开放 对修改关闭</li><li>单一职责原则 实现类要职责单一 </li><li>依赖倒转原则 面向接口编程</li><li>迪米特法则 降低耦合</li><li>接口隔离原则 设计接口的时候要精简单一 </li><li>合成/聚合复用原则</li><li>里氏代换原则 不要破坏继承体系</li></ol><h1 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h1><h2 id="node-和-java-有什么区别"><a href="#node-和-java-有什么区别" class="headerlink" title="node 和 java 有什么区别"></a>node 和 java 有什么区别</h2><h2 id="node-单线程相比-java-的优点"><a href="#node-单线程相比-java-的优点" class="headerlink" title="node 单线程相比 java 的优点"></a>node 单线程相比 java 的优点</h2><h2 id="node-怎么开启多线程"><a href="#node-怎么开启多线程" class="headerlink" title="node 怎么开启多线程"></a>node 怎么开启多线程</h2><h2 id="node-洋葱模型"><a href="#node-洋葱模型" class="headerlink" title="node 洋葱模型"></a>node 洋葱模型</h2><h2 id="BFF-的理解"><a href="#BFF-的理解" class="headerlink" title="BFF 的理解"></a>BFF 的理解</h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="二维码扫描多端登录设计思路"><a href="#二维码扫描多端登录设计思路" class="headerlink" title="二维码扫描多端登录设计思路"></a>二维码扫描多端登录设计思路</h2><h2 id="项目数据库设计"><a href="#项目数据库设计" class="headerlink" title="项目数据库设计"></a>项目数据库设计</h2><h2 id="原生设计一个-dialog，需要设计哪些部分"><a href="#原生设计一个-dialog，需要设计哪些部分" class="headerlink" title="原生设计一个 dialog，需要设计哪些部分"></a>原生设计一个 dialog，需要设计哪些部分</h2><h2 id="设计一个中间件"><a href="#设计一个中间件" class="headerlink" title="设计一个中间件"></a>设计一个中间件</h2><h2 id="pnpm-的优势"><a href="#pnpm-的优势" class="headerlink" title="pnpm 的优势"></a>pnpm 的优势</h2><h1 id="CICD"><a href="#CICD" class="headerlink" title="CICD"></a>CICD</h1><h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><h2 id="nginx-主要是做什么的"><a href="#nginx-主要是做什么的" class="headerlink" title="nginx 主要是做什么的"></a>nginx 主要是做什么的</h2><p>静态资源缓存 hash，gzip，负载均衡，超时连接</p><h2 id="nginx-怎么代理-websocket，有什么问题"><a href="#nginx-怎么代理-websocket，有什么问题" class="headerlink" title="nginx 怎么代理 websocket，有什么问题"></a>nginx 怎么代理 websocket，有什么问题</h2><h2 id="nginx-怎么开启-gzip"><a href="#nginx-怎么开启-gzip" class="headerlink" title="nginx 怎么开启 gzip"></a>nginx 怎么开启 gzip</h2><h2 id="nginx-真的解决了跨域吗"><a href="#nginx-真的解决了跨域吗" class="headerlink" title="nginx 真的解决了跨域吗"></a>nginx 真的解决了跨域吗</h2><p>服务端和服务端之间不存在跨域</p><h1 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h1><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="树的种类以及特性"><a href="#树的种类以及特性" class="headerlink" title="树的种类以及特性"></a>树的种类以及特性</h2><h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="面试指南" scheme="https://zlinni.github.io/categories/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Javascript——自检篇</title>
    <link href="https://zlinni.github.io/posts/2576354353/"/>
    <id>https://zlinni.github.io/posts/2576354353/</id>
    <published>2022-08-07T02:23:45.000Z</published>
    <updated>2022-09-10T02:22:04.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>记录 js 输出问题过程和知识点解答</p></div><h1 id="1-暂时性死区和变量提升"><a href="#1-暂时性死区和变量提升" class="headerlink" title="1 暂时性死区和变量提升"></a>1 暂时性死区和变量提升</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure><ul><li>A: Lydia 和 undefined</li><li>B: Lydia 和 ReferenceError</li><li>C: ReferenceError 和 21</li><li>D: undefined 和 ReferenceError</li></ul><details><summary>答案</summary>D let，const 声明前读取有暂时性死区，js 抛出`ReferenceError` 变量提升 `undefined`置顶</details><h1 id="2-作用域以及事件循环"><a href="#2-作用域以及事件循环" class="headerlink" title="2 作用域以及事件循环"></a>2 作用域以及事件循环</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A: 0 1 2 和 0 1 2</li><li>B: 0 1 2 和 3 3 3</li><li>C: 3 3 3 和 0 1 2</li></ul><details><summary>答案</summary>由于 js 的事件循环机制，settimeout 的内容是在循环结束才输出的，第一个 i 声明用的是 var 此时 i 是在全局作用域，也就是我们一直递增到 3 结束循环才输出 settimeout 的内容，也就是 333第二点由于下面是 let 声明的块级作用域，每次循环都会产生新值，所以 setimeout 的时候，i 拿到的是当前作用域里面的值，也就是 012</details><h1 id="3-箭头函数和常规函数的-this"><a href="#3-箭头函数和常规函数的-this" class="headerlink" title="3 箭头函数和常规函数的 this"></a>3 箭头函数和常规函数的 this</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shape = &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="function"><span class="title">diameter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.radius * <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">perimeter</span>: <span class="function">() =&gt;</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * <span class="built_in">this</span>.radius,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">shape.diameter();</span><br><span class="line">shape.perimeter();</span><br></pre></td></tr></table></figure><ul><li>A: 20 and 62.83185307179586</li><li>B: 20 and NaN</li><li>C: 20 and 63</li><li>D: NaN and 63</li></ul><details><summary>答案</summary>shape 调用了 diameter 常规函数，所以 this 指向 shape，读的到 radiusperimeter 是一个箭头函数，对于该函数的 this 指向的是它的周围作用域，也就是包含箭头函数的常规函数，如果没有，就是 window很明显此处没有常规函数包装它，于是指向 window，window 上没有这个属性，对于 undefined+数字输出的是 NaN</details><h1 id="4-值转换"><a href="#4-值转换" class="headerlink" title="4 值转换"></a>4 值转换</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+<span class="literal">true</span>;</span><br><span class="line">!<span class="string">&quot;Lydia&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>A: 1 and false</li><li>B: false and NaN</li><li>C: false and false</li></ul><details><summary>答案</summary>A 注意+还可以转换 string，相当于`Number()`的效果</details><h1 id="5-对象运算优先级"><a href="#5-对象运算优先级" class="headerlink" title="5 对象运算优先级"></a>5 对象运算优先级</h1><p>哪一个是无效的？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bird = &#123;</span><br><span class="line">  <span class="attr">size</span>: <span class="string">&quot;small&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mouse = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Mickey&quot;</span>,</span><br><span class="line">  <span class="attr">small</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>A: mouse.bird.size</li><li>B: mouse[bird.size]</li><li>C: mouse[bird[“size”]]</li><li>D: All of them are valid</li></ul><details><summary>答案</summary>A 先计算括号里面的，如果没有括号链式计算，显然 A 是没有 bird 的</details><h1 id="6-对象相等时地址相同"><a href="#6-对象相等时地址相同" class="headerlink" title="6 对象相等时地址相同"></a>6 对象相等时地址相同</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">greeting</span>: <span class="string">&quot;Hey!&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> d;</span><br><span class="line"></span><br><span class="line">d = c;</span><br><span class="line">c.greeting = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(d.greeting);</span><br></pre></td></tr></table></figure><ul><li>A: Hello</li><li>B: undefined</li><li>C: ReferenceError</li><li>D: TypeError</li></ul><details><summary>答案</summary>A 此时内存中的地址相同</details><h1 id="7-和-以及-new-对象"><a href="#7-和-以及-new-对象" class="headerlink" title="7 ==和===以及 new 对象"></a>7 <code>==</code>和<code>===</code>以及 new 对象</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == b);</span><br><span class="line"><span class="built_in">console</span>.log(a === b);</span><br><span class="line"><span class="built_in">console</span>.log(b === c);</span><br></pre></td></tr></table></figure><ul><li>A: true false true</li><li>B: false false true</li><li>C: true false false</li><li>D: false true true</li></ul><details><summary>答案</summary>C new Number()是新建了一个对象==的时候比较值 所以相同===的时候比较值和类型，所以对象不同于 number</details><h1 id="8-静态方法的调用"><a href="#8-静态方法的调用" class="headerlink" title="8 静态方法的调用"></a>8 静态方法的调用</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chameleon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">colorChange</span>(<span class="params">newColor</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.newColor = newColor;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.newColor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123; newColor = <span class="string">&quot;green&quot;</span> &#125; = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.newColor = newColor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> freddie = <span class="keyword">new</span> Chameleon(&#123; <span class="attr">newColor</span>: <span class="string">&quot;purple&quot;</span> &#125;);</span><br><span class="line">freddie.colorChange(<span class="string">&quot;orange&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>A: orange</li><li>B: purple</li><li>C: green</li><li>D: TypeError</li></ul><details><summary>答案</summary>静态方法只能被类调用，不能被实例调用</details><h1 id="9-不声明变量直接赋值"><a href="#9-不声明变量直接赋值" class="headerlink" title="9 不声明变量直接赋值"></a>9 不声明变量直接赋值</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting;</span><br><span class="line">greetign = &#123;&#125;; <span class="comment">// Typo!</span></span><br><span class="line"><span class="built_in">console</span>.log(greetign);</span><br></pre></td></tr></table></figure><ul><li>A: {}</li><li>B: ReferenceError: greetign is not defined</li><li>C: undefined</li></ul><details><summary>答案</summary>A 可以使用`use Strict`确保声明变量的时候必须赋值</details><h1 id="10-给函数添加属性"><a href="#10-给函数添加属性" class="headerlink" title="10 给函数添加属性"></a>10 给函数添加属性</h1><p>当我们这么做时，会发生什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bark</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bark.animal = <span class="string">&quot;dog&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>A: 正常运行!</li><li>B: SyntaxError. 你不能通过这种方式给函数增加属性。</li><li>C: undefined</li><li>D: ReferenceError</li></ul><details> <summary>答案</summary>A js 一切皆对象</details><h1 id="11-构造函数添加方法"><a href="#11-构造函数添加方法" class="headerlink" title="11 构造函数添加方法"></a>11 构造函数添加方法</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person(<span class="string">&quot;Lydia&quot;</span>, <span class="string">&quot;Hallie&quot;</span>);</span><br><span class="line">Person.getFullName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(member.getFullName());</span><br></pre></td></tr></table></figure><ul><li>A: TypeError</li><li>B: SyntaxError</li><li>C: Lydia Hallie</li><li>D: undefined undefined</li></ul><details><summary>答案</summary>A 不能像常规对象一样给构造函数添加属性，要想添加属性必须这样写<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>这样才能给所有的实例添加对应的属性。原因是：如果我们可以直接添加方法到构造函数中，那么所有的 Person 实例上都拥有这个方法，对于不需要这个方法的实例，会浪费大量的空间内存。如果添加到原型上面，实例只有在需要这个方法的时候，才会去原型上面找，不占据自身的空间。只在原型中占一个位置，但所有实例都可以访问。</details><h1 id="12-new-和不-new"><a href="#12-new-和不-new" class="headerlink" title="12 new 和不 new"></a>12 new 和不 new</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lydia = <span class="keyword">new</span> Person(<span class="string">&quot;Lydia&quot;</span>, <span class="string">&quot;Hallie&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> sarah = Person(<span class="string">&quot;Sarah&quot;</span>, <span class="string">&quot;Smith&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lydia);</span><br><span class="line"><span class="built_in">console</span>.log(sarah);</span><br></pre></td></tr></table></figure><ul><li>A: Person {firstName: “Lydia”, lastName: “Hallie”} and undefined</li><li>B: Person {firstName: “Lydia”, lastName: “Hallie”} and Person {firstName: “Sarah”, lastName: “Smith”}</li><li>C: Person {firstName: “Lydia”, lastName: “Hallie”} and {}</li><li>D: Person {firstName: “Lydia”, lastName: “Hallie”} and ReferenceError</li></ul><details><summary>答案</summary>new 的时候 this 默认引用我们创建的空对象不 new 的时候 this 默认引用 window，也就是实际上`window.firstName = Sarah`，但 sarah 还是 undefined</details><h1 id="13-事件传播的三个阶段是什么？"><a href="#13-事件传播的三个阶段是什么？" class="headerlink" title="13 事件传播的三个阶段是什么？"></a>13 事件传播的三个阶段是什么？</h1><ul><li>A: Target &gt; Capturing &gt; Bubbling</li><li>B: Bubbling &gt; Target &gt; Capturing</li><li>C: Target &gt; Bubbling &gt; Capturing</li><li>D: Capturing &gt; Target &gt; Bubbling</li></ul><details><summary>答案</summary>D 在捕获阶段中，事件从祖先元素向下传播到目标元素。当事件到达目标后，冒泡才开始</details><h1 id="14-所有对象都有原型？"><a href="#14-所有对象都有原型？" class="headerlink" title="14 所有对象都有原型？"></a>14 所有对象都有原型？</h1><ul><li>A: true</li><li>B: false</li></ul><details><summary>答案</summary>B 除了基本对象（base object），所有对象都有原型。基本对象可以访问一些方法和属性，比如 .toString。这就是为什么你可以使用内置的 JavaScript 方法！所有这些方法在原型上都是可用的。虽然 JavaScript 不能直接在对象上找到这些方法，但 JavaScript 会沿着原型链找到它们，以便于你使用。</details><h1 id="15-隐式类型转换"><a href="#15-隐式类型转换" class="headerlink" title="15 隐式类型转换"></a>15 隐式类型转换</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>A: NaN</li><li>B: TypeError</li><li>C: “12”</li><li>D: 3</li></ul><details><summary>答案</summary>C 隐式类型转换"12"</details><h1 id="16-运算符"><a href="#16-运算符" class="headerlink" title="16 运算符"></a>16 运算符</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(number++);</span><br><span class="line"><span class="built_in">console</span>.log(++number);</span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br></pre></td></tr></table></figure><ul><li>A: 1 1 2</li><li>B: 1 2 2</li><li>C: 0 2 2</li><li>D: 0 1 2<br><details><summary>答案</summary></li></ul><p>C</p><p>&lt;/details&gt;</p><h1 id="17-标记模板字面量"><a href="#17-标记模板字面量" class="headerlink" title="17 标记模板字面量"></a>17 标记模板字面量</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPersonInfo</span>(<span class="params">one, two, three</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(one);</span><br><span class="line">  <span class="built_in">console</span>.log(two);</span><br><span class="line">  <span class="built_in">console</span>.log(three);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">getPersonInfo<span class="string">`<span class="subst">$&#123;person&#125;</span> is <span class="subst">$&#123;age&#125;</span> years old`</span>;</span><br></pre></td></tr></table></figure><ul><li>A: “Lydia” 21 [“”, “ is “, “ years old”]</li><li>B: [“”, “ is “, “ years old”] “Lydia” 21</li><li>C: “Lydia” [“”, “ is “, “ years old”] 21</li></ul><details><summary>答案</summary>B 当函数调用的时候提供标记模板字面量，那么优先将模板的数组传入，随之传入的是其中的变量</details><h1 id="18-比较对象"><a href="#18-比较对象" class="headerlink" title="18 比较对象"></a>18 比较对象</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data === &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;You are an adult!&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data == &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;You are still an adult.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hmm.. You don&#x27;t have an age I guess`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkAge(&#123; <span class="attr">age</span>: <span class="number">18</span> &#125;);</span><br></pre></td></tr></table></figure><ul><li>A: You are an adult!</li><li>B: You are still an adult.</li><li>C: Hmm.. You don’t have an age I guess</li></ul><details><summary>答案</summary>C 对象不能直接比较相等性，需要对每层对象递归比较才行</details><h1 id="19-拓展运算符"><a href="#19-拓展运算符" class="headerlink" title="19 拓展运算符"></a>19 拓展运算符</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge(<span class="number">21</span>);</span><br></pre></td></tr></table></figure><ul><li>A: “number”</li><li>B: “array”</li><li>C: “object”</li><li>D: “NaN”</li></ul><details><summary>答案</summary>C 拓展运算符返回的是实参组成的数组，因此结果是object</details><h1 id="20-use-strict"><a href="#20-use-strict" class="headerlink" title="20 use strict"></a>20 use strict</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  age = <span class="number">21</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge();</span><br></pre></td></tr></table></figure><p>A: 21<br>B: undefined<br>C: ReferenceError<br>D: TypeError</p><details><summary>答案</summary>C use strict表明下面的变量必须在声明之后赋值，否则抛出指向异常</details><h1 id="21-eval"><a href="#21-eval" class="headerlink" title="21 eval"></a>21 eval</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="built_in">eval</span>(<span class="string">&quot;10*10+5&quot;</span>);</span><br></pre></td></tr></table></figure><p>A: 105<br>B: “105”<br>C: TypeError<br>D: “10*10+5”</p><details><summary>答案</summary>A 代码以字符串的形式传递进来，eval对其求值，如果它是一个表达式，就对表达式求值，返回结果number的105</details><h1 id="22-sessionStorage"><a href="#22-sessionStorage" class="headerlink" title="22 sessionStorage"></a>22 sessionStorage</h1><p>cool_secret 可访问多长时间？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">&quot;cool_secret&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>A: 永远，数据不会丢失。<br>B: 当用户关掉标签页时。<br>C: 当用户关掉整个浏览器，而不只是关掉标签页。<br>D: 当用户关闭电脑时。</p><details><summary>答案</summary>B</details><h1 id="23-var"><a href="#23-var" class="headerlink" title="23 var"></a>23 var</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><p>A: 8<br>B: 10<br>C: SyntaxError<br>D: ReferenceError</p><details><summary>答案</summary>B 新值覆盖旧值 但const let不行</details><h1 id="24-对象键和set集合"><a href="#24-对象键和set集合" class="headerlink" title="24 对象键和set集合"></a>24 对象键和set集合</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">1</span>: <span class="string">&quot;a&quot;</span>, <span class="number">2</span>: <span class="string">&quot;b&quot;</span>, <span class="number">3</span>: <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">obj.hasOwnProperty(<span class="number">1</span>);</span><br><span class="line">set.has(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">set.has(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>A: false true false true<br>B: false true true true<br>C: true true false true<br>D: true true true true</p><details><summary>答案</summary>C 对象的键始终是字符串。set集合是根据输入的参数决定</details><h1 id="25-同名的键"><a href="#25-同名的键" class="headerlink" title="25 同名的键"></a>25 同名的键</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;one&quot;</span>, <span class="attr">b</span>: <span class="string">&quot;two&quot;</span>, <span class="attr">a</span>: <span class="string">&quot;three&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>A: { a: “one”, b: “two” }<br>B: { b: “two”, a: “three” }<br>C: { a: “three”, b: “two” }<br>D: SyntaxError</p><details><summary>答案</summary>C 如果有两个同名的键，新值会替换旧值，但是键还是在原来的位置</details><h1 id="26-全局执行上下文"><a href="#26-全局执行上下文" class="headerlink" title="26 全局执行上下文"></a>26 全局执行上下文</h1><p>JavaScript 全局执行上下文为你做了两件事：全局对象和 this 关键字。</p><p>A: true<br>B: false<br>C: it depends</p><details><summary>答案</summary>A</details><h1 id="27-continue"><a href="#27-continue" class="headerlink" title="27 continue"></a>27 continue</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A: 1 2<br>B: 1 2 3<br>C: 1 2 4<br>D: 1 3 4</p><details><summary>答案</summary>C continue跳过本次迭代</details><h1 id="28-访问原型添加的方法"><a href="#28-访问原型添加的方法" class="headerlink" title="28 访问原型添加的方法"></a>28 访问原型添加的方法</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.giveLydiaPizza = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Just give Lydia pizza already!&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"></span><br><span class="line">name.giveLydiaPizza();</span><br></pre></td></tr></table></figure><p>A: “Just give Lydia pizza already!”<br>B: TypeError: not a function<br>C: SyntaxError<br>D: undefined</p><details><summary>答案</summary>A 我们向String的原型添加了一个方法，所以下面所属的string对象都可以访问该方法</details><h1 id="29-对象转字符串"><a href="#29-对象转字符串" class="headerlink" title="29 对象转字符串"></a>29 对象转字符串</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">key</span>: <span class="string">&quot;b&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">key</span>: <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">a[b] = <span class="number">123</span>;</span><br><span class="line">a[c] = <span class="number">456</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br></pre></td></tr></table></figure><p>A: 123<br>B: 456<br>C: undefined<br>D: ReferenceError</p><details><summary>答案</summary>B a在使用b这个键的时候，把b自动转为了字符串，也就是`[object object]`且这个值对应为123第二次转为456输出的时候 也就是456了考察的是对象转字符串</details><h1 id="30-事件循环"><a href="#30-事件循环" class="headerlink" title="30 事件循环"></a>30 事件循环</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;First&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bar = <span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Second&quot;</span>));</span><br><span class="line"><span class="keyword">const</span> baz = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Third&quot;</span>);</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line">foo();</span><br><span class="line">baz();</span><br></pre></td></tr></table></figure><p>A: First Second Third<br>B: First Third Second<br>C: Second First Third<br>D: Second Third First</p><details><summary>答案</summary>B 事件循环</details><h1 id="31-事件target"><a href="#31-事件target" class="headerlink" title="31 事件target"></a>31 事件target</h1><p>当点击按钮时，event.target 是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onclick=<span class="string">&quot;console.log(&#x27;first div&#x27;)&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;second div&#x27;)&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;button&#x27;)&quot;</span>&gt;</span>Click!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>A: Outer div<br>B: Inner div<br>C: button<br>D: 一个包含所有嵌套元素的数组。</p><details><summary>答案</summary>C 导致事件的最深嵌套元素是事件的target。可以通过`event.stopPropagation`来停止冒泡</details><h1 id="32-事件执行"><a href="#32-事件执行" class="headerlink" title="32 事件执行"></a>32 事件执行</h1><p>当您单击该段落时，日志输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onclick=<span class="string">&quot;console.log(&#x27;div&#x27;)&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;p&#x27;)&quot;</span>&gt;</span>Click here!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>A: p div<br>B: div p<br>C: p<br>D: div</p><details><summary>答案</summary>A 捕获 目标 冒泡默认情况下事件将在冒泡阶段执行除非设置`useCapture:true`</details><h1 id="33-call-和-bind"><a href="#33-call-和-bind" class="headerlink" title="33 call 和 bind"></a>33 call 和 bind</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is <span class="subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi.call(person, <span class="number">21</span>);</span><br><span class="line">sayHi.bind(person, <span class="number">21</span>);</span><br></pre></td></tr></table></figure><p>A: undefined is 21 Lydia is 21<br>B: function function<br>C: Lydia is 21 Lydia is 21<br>D: Lydia is 21 function</p><details><summary>答案</summary>C`.call`绑定的是立刻执行的`bind`返回的是一个函数 需要去执行该函数才可以</details><h1 id="34-typeof-IIFE"><a href="#34-typeof-IIFE" class="headerlink" title="34 typeof IIFE"></a>34 typeof IIFE</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function">() =&gt;</span> <span class="number">0</span>)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> sayHi();</span><br></pre></td></tr></table></figure><p>A: “object”<br>B: “number”<br>C: “function”<br>D: “undefined”</p><details><summary>答案</summary>B sayHi返回的是IIFE的返回值 具体是0 所以是number</details><h1 id="35-falsy"><a href="#35-falsy" class="headerlink" title="35 falsy"></a>35 falsy</h1><p>下面哪些值是 falsy?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>)</span><br><span class="line">(<span class="string">&quot;&quot;</span>)</span><br><span class="line">(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>A: 0, ‘’, undefined<br>B: 0, new Number(0), ‘’, new Boolean(false), undefined<br>C: 0, ‘’, new Boolean(false), undefined<br>D: All of them are falsy</p><details><summary>答案</summary>A new xxx是对象 是truthy，非空字符串也是truthy</details><h1 id="36-typeof-typeof"><a href="#36-typeof-typeof" class="headerlink" title="36 typeof typeof"></a>36 typeof typeof</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;number&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;string&quot;</span>;</span><br><span class="line">C: <span class="string">&quot;object&quot;</span>;</span><br><span class="line">D: <span class="string">&quot;undefined&quot;</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="37-设置数组值超过数组长度"><a href="#37-设置数组值超过数组长度" class="headerlink" title="37 设置数组值超过数组长度"></a>37 设置数组值超过数组长度</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">numbers[<span class="number">10</span>] = <span class="number">11</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers)</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span> x <span class="literal">null</span>, <span class="number">11</span>]</span><br><span class="line"><span class="attr">B</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">11</span>]</span><br><span class="line"><span class="attr">C</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span> x empty, <span class="number">11</span>]</span><br><span class="line"><span class="attr">D</span>: <span class="built_in">SyntaxError</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 当设置的数组值超过数组长度的时候，会自动生成一系列的undefined 这里也就是显示了七个空</details><h1 id="38-catch接收"><a href="#38-catch接收" class="headerlink" title="38 catch接收"></a>38 catch接收</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x, y</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (x) &#123;</span><br><span class="line">    (x = <span class="number">1</span>), (y = <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">  <span class="built_in">console</span>.log(y)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="number">1</span> <span class="literal">undefined</span> <span class="number">2</span></span><br><span class="line"><span class="attr">B</span>: <span class="literal">undefined</span> <span class="literal">undefined</span> <span class="literal">undefined</span></span><br><span class="line"><span class="attr">C</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="attr">D</span>: <span class="number">1</span> <span class="literal">undefined</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>catch接收的参数x不是实际的x。这个x是属于catch块级作用域的，然后把块级作用域的变量赋为1，同时也设置了y的值 所以输出1 然后下面的x没有赋值是undefined 然后是2</details><h1 id="39-JavaScript-中的一切都是？"><a href="#39-JavaScript-中的一切都是？" class="headerlink" title="39 JavaScript 中的一切都是？"></a>39 JavaScript 中的一切都是？</h1><p>JavaScript 中的一切都是？<br>A: 基本类型与对象<br>B: 函数与对象<br>C: 只有对象<br>D: 数字与对象</p><details><summary>答案</summary>A</details><h1 id="40-reduce"><a href="#40-reduce" class="headerlink" title="40 reduce"></a>40 reduce</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">].reduce(</span><br><span class="line">  <span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> acc.concat(cur);</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">A: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">B: [<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">C: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">D: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C</details><h1 id="41"><a href="#41" class="headerlink" title="41 !!"></a>41 !!</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="literal">null</span></span><br><span class="line">!!<span class="string">&#x27;&#x27;</span></span><br><span class="line">!!<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="literal">false</span> <span class="literal">true</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">B</span>: <span class="literal">false</span> <span class="literal">false</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">C</span>: <span class="literal">false</span> <span class="literal">true</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">D</span>: <span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="42-setInterval"><a href="#42-setInterval" class="headerlink" title="42 setInterval"></a>42 setInterval</h1><p>setInterval<br>方法的返回值是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">A: 一个唯一的id;</span><br><span class="line">B: 该方法指定的毫秒数;</span><br><span class="line">C: 传递的函数;</span><br><span class="line">D: <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A</details><h1 id="43-拓展运算符"><a href="#43-拓展运算符" class="headerlink" title="43 拓展运算符"></a>43 拓展运算符</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&quot;Lydia&quot;</span>];</span><br><span class="line"></span><br><span class="line">A: [<span class="string">&quot;L&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;a&quot;</span>];</span><br><span class="line">B: [<span class="string">&quot;Lydia&quot;</span>];</span><br><span class="line">C: [[], <span class="string">&quot;Lydia&quot;</span>];</span><br><span class="line">D: [[<span class="string">&quot;L&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;a&quot;</span>]];</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A string是可迭代的</details><h1 id="44-generator"><a href="#44-generator" class="headerlink" title="44 generator"></a>44 generator</h1><p>输出是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> i;</span><br><span class="line">  <span class="keyword">yield</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = generator(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"><span class="built_in">console</span>.log(gen.next().value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: [<span class="number">0</span>, <span class="number">10</span>], [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="attr">B</span>: <span class="number">20</span>, <span class="number">20</span></span><br><span class="line"><span class="attr">C</span>: <span class="number">10</span>, <span class="number">20</span></span><br><span class="line"><span class="attr">D</span>: <span class="number">0</span>, <span class="number">10</span> and <span class="number">10</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>C generator会停下，直到调用下一个next</details><h1 id="45-Promise-race"><a href="#45-Promise-race" class="headerlink" title="45 Promise.race"></a>45 <code>Promise.race</code></h1><p>返回值是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(res, <span class="number">500</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secondPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(res, <span class="number">100</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([firstPromise, secondPromise]).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;two&quot;</span></span><br><span class="line"><span class="attr">C</span>: <span class="string">&quot;two&quot;</span> <span class="string">&quot;one&quot;</span></span><br><span class="line"><span class="attr">D</span>: <span class="string">&quot;one&quot;</span> <span class="string">&quot;two&quot;</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>race中有一个状态优先改变就输出改变的那一个这里是two 因为他只用100ms另外any 是其中一个变成fulfilled就返回成功，全部都失败才返回失败all是全部成功才返回成功，一个失败就返回失败，相当于any的相反allSettled会等全部执行完，不会因为失败终止</details><h1 id="46-引用交互"><a href="#46-引用交互" class="headerlink" title="46 引用交互"></a>46 引用交互</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> members = [person];</span><br><span class="line">person = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(members);</span><br><span class="line"></span><br><span class="line">A: <span class="literal">null</span>;</span><br><span class="line">B: [<span class="literal">null</span>];</span><br><span class="line">C: [&#123;&#125;];</span><br><span class="line">D: [&#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;];</span><br></pre></td></tr></table></figure><details><summary>答案</summary>D members的第一个元素拷贝了person，但并不是保持着引用，所以最后即使person变了它还是不会变注意只有对象和对象之间才有引用交互</details><h1 id="47-forin"><a href="#47-forin" class="headerlink" title="47 forin"></a>47 forin</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span></span><br><span class="line"><span class="attr">C</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="number">21</span></span><br><span class="line"><span class="attr">D</span>: [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Lydia&quot;</span>], [<span class="string">&quot;age&quot;</span>, <span class="number">21</span>]</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="48-运算"><a href="#48-运算" class="headerlink" title="48 运算"></a>48 运算</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> + <span class="number">4</span> + <span class="string">&quot;5&quot;</span>);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;345&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;75&quot;</span>;</span><br><span class="line">C: <span class="number">12</span>;</span><br><span class="line">D: <span class="string">&quot;12&quot;</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="49-parseInt"><a href="#49-parseInt" class="headerlink" title="49 parseInt"></a>49 parseInt</h1><p>num 是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;7*6&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">A: <span class="number">42</span>;</span><br><span class="line">B: <span class="string">&quot;42&quot;</span>;</span><br><span class="line">C: <span class="number">7</span>;</span><br><span class="line">D: <span class="literal">NaN</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>parseInt两个参数，一个是解析的参数，另外一个是进制。这里设置了十进制。然后解析7*6由于*不合法，直接解析出7</details><h1 id="50-map"><a href="#50-map" class="headerlink" title="50 map"></a>50 map</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> num === <span class="string">&quot;number&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">A: []</span><br><span class="line"><span class="attr">B</span>: [<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>]</span><br><span class="line"><span class="attr">C</span>: [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>]</span><br><span class="line"><span class="attr">D</span>: [ <span class="number">3</span> x empty ]</span><br></pre></td></tr></table></figure><details><summary>答案</summary>map创建新的值返回给数组，由于数组全是数字所以第一个if永远成立，所以返回undefined</details><h1 id="51-值与引用"><a href="#51-值与引用" class="headerlink" title="51 值与引用"></a>51 值与引用</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">member, year</span>) </span>&#123;</span><br><span class="line">  member.name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line">  year = <span class="string">&quot;1998&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Sarah&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> birthYear = <span class="string">&quot;1997&quot;</span>;</span><br><span class="line"></span><br><span class="line">getInfo(person, birthYear);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person, birthYear);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;, <span class="string">&quot;1997&quot;</span></span><br><span class="line"><span class="attr">B</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Sarah&quot;</span> &#125;, <span class="string">&quot;1998&quot;</span></span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;, <span class="string">&quot;1998&quot;</span></span><br><span class="line"><span class="attr">D</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Sarah&quot;</span> &#125;, <span class="string">&quot;1997&quot;</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>A 对象传递是引用传递，普通参数都是值传递。值传递是一份拷贝birthYear是一个值，所以函数内部的形参怎么变都不会影响到外部的birthYearperson是一个对象，传递了引用关系，函数内部改变了它的引用，所以person也变化了</details><h1 id="52-throw"><a href="#52-throw" class="headerlink" title="52 throw"></a>52 throw</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = greeting();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;It worked!&quot;</span>, data);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Oh no an error!&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi();</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;It worked! Hello world!&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;Oh no an error: undefined</span></span><br><span class="line"><span class="string">C: SyntaxError: can only throw Error objects</span></span><br><span class="line"><span class="string">D: &quot;</span>Oh no an error: Hello world!</span><br></pre></td></tr></table></figure><details><summary>答案</summary>D throw可以自定义错误，异常可以是一个字符串，一个数字，一个布尔类型，或者是一个对象。本例子中是`Hello world`</details><h1 id="53-构造函数中的返回值"><a href="#53-构造函数中的返回值" class="headerlink" title="53 构造函数中的返回值"></a>53 构造函数中的返回值</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.make = <span class="string">&quot;Lamborghini&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">make</span>: <span class="string">&quot;Maserati&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myCar = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="built_in">console</span>.log(myCar.make);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;Lamborghini&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;Maserati&quot;</span>;</span><br><span class="line">C: <span class="built_in">ReferenceError</span>;</span><br><span class="line">D: <span class="built_in">TypeError</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="54-表达式执行顺序"><a href="#54-表达式执行顺序" class="headerlink" title="54 表达式执行顺序"></a>54 表达式执行顺序</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x = (y = <span class="number">10</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> y);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;undefined&quot;</span>, <span class="string">&quot;number&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;number&quot;</span>, <span class="string">&quot;number&quot;</span>;</span><br><span class="line">C: <span class="string">&quot;object&quot;</span>, <span class="string">&quot;number&quot;</span>;</span><br><span class="line">D: <span class="string">&quot;number&quot;</span>, <span class="string">&quot;undefined&quot;</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A</details><h1 id="55-删除原型上的方法"><a href="#55-删除原型上的方法" class="headerlink" title="55 删除原型上的方法"></a>55 删除原型上的方法</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Woof I am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pet = <span class="keyword">new</span> Dog(<span class="string">&quot;Mara&quot;</span>);</span><br><span class="line"></span><br><span class="line">pet.bark();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> Dog.prototype.bark;</span><br><span class="line"></span><br><span class="line">pet.bark();</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;Woof I am Mara&quot;</span>, <span class="built_in">TypeError</span>;</span><br><span class="line">B: <span class="string">&quot;Woof I am Mara&quot;</span>, <span class="string">&quot;Woof I am Mara&quot;</span>;</span><br><span class="line">C: <span class="string">&quot;Woof I am Mara&quot;</span>, <span class="literal">undefined</span>;</span><br><span class="line">D: <span class="built_in">TypeError</span>, <span class="built_in">TypeError</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A 当调用一个不存在的函数会抛出TypeError异常</details><h1 id="56-set返回值"><a href="#56-set返回值" class="headerlink" title="56 set返回值"></a>56 set返回值</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br><span class="line"></span><br><span class="line">A: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">B: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">C: &#123;</span><br><span class="line">  <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">D</span>: &#123;</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>D 返回Set(4) { 1, 2, 3, 4 }</details><h1 id="57-读取模块"><a href="#57-读取模块" class="headerlink" title="57 读取模块"></a>57 读取模块</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// counter.js</span></span><br><span class="line"><span class="keyword">let</span> counter = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> myCounter <span class="keyword">from</span> <span class="string">&quot;./counter&quot;</span>;</span><br><span class="line"></span><br><span class="line">myCounter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myCounter);</span><br><span class="line"></span><br><span class="line">A: <span class="number">10</span>;</span><br><span class="line">B: <span class="number">11</span>;</span><br><span class="line">C: <span class="built_in">Error</span>;</span><br><span class="line">D: <span class="literal">NaN</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 引入的模块是只读的。只有导出它们的模块才能修改其值</details><h1 id="58-delete"><a href="#58-delete" class="headerlink" title="58 delete"></a>58 delete</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line">age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> name);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> age);</span><br><span class="line"></span><br><span class="line">A: <span class="literal">false</span>, <span class="literal">true</span>;</span><br><span class="line">B: <span class="string">&quot;Lydia&quot;</span>, <span class="number">21</span>;</span><br><span class="line">C: <span class="literal">true</span>, <span class="literal">true</span>;</span><br><span class="line">D: <span class="literal">undefined</span>, <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A delete返回一个布尔值，true成功fals而失败，只能删除对象的值，所以第一个抛出false，第二个值挂载到了window上， 所以是true</details><h1 id="59-解构赋值"><a href="#59-解构赋值" class="headerlink" title="59 解构赋值"></a>59 解构赋值</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> [y] = numbers;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br><span class="line"></span><br><span class="line">A: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]];</span><br><span class="line">B: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">C: <span class="number">1</span>;</span><br><span class="line">D: [<span class="number">1</span>];</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 数组的解构赋值按顺序赋值 所以是1</details><h1 id="60-拓展运算符组合对象"><a href="#60-拓展运算符组合对象" class="headerlink" title="60 拓展运算符组合对象"></a>60 拓展运算符组合对象</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> admin = &#123; <span class="attr">admin</span>: <span class="literal">true</span>, ...user &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(admin);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: &#123; <span class="attr">admin</span>: <span class="literal">true</span>, <span class="attr">user</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125; &#125;</span><br><span class="line"><span class="attr">B</span>: &#123; <span class="attr">admin</span>: <span class="literal">true</span>, <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">admin</span>: <span class="literal">true</span>, <span class="attr">user</span>: [<span class="string">&quot;Lydia&quot;</span>, <span class="number">21</span>] &#125;</span><br><span class="line"><span class="attr">D</span>: &#123; <span class="attr">admin</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="61-Object-defineProperty"><a href="#61-Object-defineProperty" class="headerlink" title="61 Object.defineProperty"></a>61 <code>Object.defineProperty</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">&quot;age&quot;</span>, &#123; <span class="attr">value</span>: <span class="number">21</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;, [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>]</span><br><span class="line"><span class="attr">B</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;, [<span class="string">&quot;name&quot;</span>]</span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>&#125;, [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>]</span><br><span class="line"><span class="attr">D</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>&#125;, [<span class="string">&quot;age&quot;</span>]</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B `Object.defineProperty`给对象添加了一个属性，但是默认不可枚举不可修改。所以不会通过`Object.keys`显示出来</details><h1 id="62-JSON-stringfy"><a href="#62-JSON-stringfy" class="headerlink" title="62 JSON.stringfy"></a>62 <code>JSON.stringfy</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> settings = &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&quot;lydiahallie&quot;</span>,</span><br><span class="line">  <span class="attr">level</span>: <span class="number">19</span>,</span><br><span class="line">  <span class="attr">health</span>: <span class="number">90</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="built_in">JSON</span>.stringify(settings, [<span class="string">&quot;level&quot;</span>, <span class="string">&quot;health&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;&#123;&quot;</span>level<span class="string">&quot;:19, &quot;</span>health<span class="string">&quot;:90&#125;&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;&#123;&quot;</span>username<span class="string">&quot;: &quot;</span>lydiahallie<span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="attr">C</span>: <span class="string">&quot;[&quot;</span>level<span class="string">&quot;, &quot;</span>health<span class="string">&quot;]&quot;</span></span><br><span class="line"><span class="attr">D</span>: <span class="string">&quot;&#123;&quot;</span>username<span class="string">&quot;: &quot;</span>lydiahallie<span class="string">&quot;, &quot;</span>level<span class="string">&quot;:19, &quot;</span>health<span class="string">&quot;:90&#125;&quot;</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>A `JSON.stringfy`的第二个参数是replacer 它可以是一个数组也可以是一个函数如果是一个数组，那么 只取到数组中的属性如果是一个函数，那么会遍历全部的值，函数的返回值会成为这个属性的值</details><h1 id="63-操作"><a href="#63-操作" class="headerlink" title="63 ++操作"></a>63 ++操作</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increaseNumber = <span class="function">() =&gt;</span> num++;</span><br><span class="line"><span class="keyword">const</span> increasePassedNumber = <span class="function">(<span class="params">number</span>) =&gt;</span> number++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> num1 = increaseNumber();</span><br><span class="line"><span class="keyword">const</span> num2 = increasePassedNumber(num1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num1);</span><br><span class="line"><span class="built_in">console</span>.log(num2);</span><br><span class="line"></span><br><span class="line">A: <span class="number">10</span>, <span class="number">10</span>;</span><br><span class="line">B: <span class="number">10</span>, <span class="number">11</span>;</span><br><span class="line">C: <span class="number">11</span>, <span class="number">11</span>;</span><br><span class="line">D: <span class="number">11</span>, <span class="number">12</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A</details><h1 id="64-对象默认值与传递"><a href="#64-对象默认值与传递" class="headerlink" title="64 对象默认值与传递"></a>64 对象默认值与传递</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = &#123; <span class="attr">number</span>: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">x = &#123; ...value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log((x.number *= <span class="number">2</span>));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">multiply();</span><br><span class="line">multiply();</span><br><span class="line">multiply(value);</span><br><span class="line">multiply(value);</span><br><span class="line"></span><br><span class="line">A: <span class="number">20</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">160</span>;</span><br><span class="line">B: <span class="number">20</span>, <span class="number">40</span>, <span class="number">20</span>, <span class="number">40</span>;</span><br><span class="line">C: <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">40</span>;</span><br><span class="line">D: <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="number">20</span>, <span class="number">40</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 前面两次是形参默认值且解构，所以每次都是一样的`{number:10}` 因此都是20后面两次传递的是value 因为对象传递是引用 所以第一次20 第二次在第一次的基础上改 变40</details><h1 id="65-reduce"><a href="#65-reduce" class="headerlink" title="65 reduce"></a>65 reduce</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">console</span>.log(x, y));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: <span class="number">1</span> <span class="number">2</span> and <span class="number">3</span> <span class="number">3</span> and <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="attr">B</span>: <span class="number">1</span> <span class="number">2</span> and <span class="number">2</span> <span class="number">3</span> and <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="attr">C</span>: <span class="number">1</span> <span class="literal">undefined</span> and <span class="number">2</span> <span class="literal">undefined</span> and <span class="number">3</span> <span class="literal">undefined</span> and <span class="number">4</span> <span class="literal">undefined</span></span><br><span class="line"><span class="attr">D</span>: <span class="number">1</span> <span class="number">2</span> and <span class="literal">undefined</span> <span class="number">3</span> and <span class="literal">undefined</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>reduce有四个参数* acc 累加器* cur 当前值* idx 当前索引* src 源数组此时1是累加器 2是当前值 此时打印是console 所以默认返回undefined 下一次累加器则是undefined 所以 第二次 undefined 3第三次 undefined 4结束</details><h1 id="66-继承"><a href="#66-继承" class="headerlink" title="66 继承"></a>66 继承</h1><p>使用哪个构造函数可以成功继承 Dog 类?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Labrador</span> <span class="keyword">extends</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: <span class="number">1</span></span><br><span class="line"><span class="attr">B</span>: <span class="number">2</span></span><br><span class="line"><span class="attr">C</span>: <span class="number">3</span></span><br><span class="line"><span class="attr">D</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B super在使用之前不能访问this关键字 否则抛出ReferenceError错误。使用super 需要构造函数传递相应的参数给super。这里传递name</details><h1 id="67-import"><a href="#67-import" class="headerlink" title="67 import"></a>67 import</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;running index.js&#x27;</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./sum.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;running sum.js&#x27;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: running index.js, running sum.js, <span class="number">3</span></span><br><span class="line"><span class="attr">B</span>: running sum.js, running index.js, <span class="number">3</span></span><br><span class="line"><span class="attr">C</span>: running sum.js, <span class="number">3</span>, running index.js</span><br><span class="line"><span class="attr">D</span>: running index.js, <span class="literal">undefined</span>, running sum.js</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B import会在编译的阶段执行，意味着被导入的模块会先运行，导入模块的文件会后运行。和 require不同 require是在运行时执行的 所以它可以根据需要加载依赖</details><h1 id="68-Symbol"><a href="#68-Symbol" class="headerlink" title="68 Symbol"></a>68 Symbol</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="number">2</span>) === <span class="built_in">Number</span>(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">false</span>) === <span class="built_in">Boolean</span>(<span class="literal">false</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>) === <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line"></span><br><span class="line">A: <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>;</span><br><span class="line">B: <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>;</span><br><span class="line">C: <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>;</span><br><span class="line">D: <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A</details><h1 id="69-padStart"><a href="#69-padStart" class="headerlink" title="69 padStart"></a>69 padStart</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia Hallie&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.padStart(<span class="number">13</span>));</span><br><span class="line"><span class="built_in">console</span>.log(name.padStart(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;Lydia Hallie&quot;</span>, <span class="string">&quot;Lydia Hallie&quot;</span>;</span><br><span class="line">B: <span class="string">&quot; Lydia Hallie&quot;</span>,</span><br><span class="line">  <span class="string">&quot; Lydia Hallie&quot;</span>(</span><br><span class="line">    <span class="string">&quot;[13x whitespace]Lydia Hallie&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[2x whitespace]Lydia Hallie&quot;</span></span><br><span class="line">  );</span><br><span class="line">C: <span class="string">&quot; Lydia Hallie&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Lydia Hallie&quot;</span>(<span class="string">&quot;[1x whitespace]Lydia Hallie&quot;</span>, <span class="string">&quot;Lydia Hallie&quot;</span>);</span><br><span class="line">D: <span class="string">&quot;Lydia Hallie&quot;</span>, <span class="string">&quot;Lyd&quot;</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C padStart api给字符串的前面添加空格，这个字符串的长度是12 现在输入13则添加一个空格 如果输入的小于它的长度则不添加</details><h1 id="70-emoji"><a href="#70-emoji" class="headerlink" title="70 emoji"></a>70 emoji</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;🥑&quot;</span> + <span class="string">&quot;💻&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;🥑💻&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="number">257548</span></span><br><span class="line"><span class="attr">C</span>: A string containing their code points</span><br><span class="line"><span class="attr">D</span>: <span class="built_in">Error</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>A</details><h1 id="71-generator"><a href="#71-generator" class="headerlink" title="71 generator"></a>71 generator</h1><p>如何能打印出<br>console.log<br>语句后注释掉的值？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">startGame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> answer = <span class="keyword">yield</span> <span class="string">&quot;Do you love JavaScript?&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (answer !== <span class="string">&quot;Yes&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Oh wow... Guess we&#x27;re gone here&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;JavaScript loves you back ❤️&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> game = startGame();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="comment">/* 1 */</span>); <span class="comment">// Do you love JavaScript?</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="comment">/* 2 */</span>); <span class="comment">// JavaScript loves you back ❤️</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: game.next(<span class="string">&quot;Yes&quot;</span>).value and game.next().value</span><br><span class="line"><span class="attr">B</span>: game.next.value(<span class="string">&quot;Yes&quot;</span>) and game.next.value()</span><br><span class="line"><span class="attr">C</span>: game.next().value and game.next(<span class="string">&quot;Yes&quot;</span>).value</span><br><span class="line"><span class="attr">D</span>: game.next.value() and game.next.value(<span class="string">&quot;Yes&quot;</span>)</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C</details><h1 id="72-String-raw"><a href="#72-String-raw" class="headerlink" title="72 String.raw"></a>72 <code>String.raw</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.raw<span class="string">`Hello\nworld`</span>);</span><br><span class="line"></span><br><span class="line">A: Hello world!</span><br><span class="line">B: Hello</span><br><span class="line">world</span><br><span class="line"><span class="attr">C</span>: Hello\nworld</span><br><span class="line"><span class="attr">D</span>: Hello\n</span><br><span class="line">world</span><br></pre></td></tr></table></figure><details><summary>答案</summary>`String.raw`函数用来获取模板字符串的原始字符串，它返回一个字符串忽略了转义符,不过反斜杠可能有问题<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">`C:\Documents\Projects\table.html`</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`<span class="subst">$&#123;path&#125;</span>`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>这将导致：`"C:DocumentsProjects able.html"`直接使用`String.raw`<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`C:\Documents\Projects\table.html`</span></span><br></pre></td></tr></table></figure>它会忽略转义字符并打印：`C:\Documents\Projects\table.html`</details><h1 id="73-Promise"><a href="#73-Promise" class="headerlink" title="73 Promise"></a>73 Promise</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;I made it!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = getData();</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;I made it!&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="built_in">Promise</span> &#123;&lt;resolved&gt;: <span class="string">&quot;I made it!&quot;</span>&#125;</span><br><span class="line"><span class="attr">C</span>: <span class="built_in">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line"><span class="attr">D</span>: <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 异步函数始终返回一个promise 要想获取值 使用`data.then((res)=>console.log(res))`</details><h1 id="74-push"><a href="#74-push" class="headerlink" title="74 push"></a>74 push</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addToList</span>(<span class="params">item, list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> list.push(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = addToList(<span class="string">&quot;apple&quot;</span>, [<span class="string">&quot;banana&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line">A: [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>];</span><br><span class="line">B: <span class="number">2</span>;</span><br><span class="line">C: <span class="literal">true</span>;</span><br><span class="line">D: <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B push方法返回新数组的长度</details><h1 id="75-Object-freeze"><a href="#75-Object-freeze" class="headerlink" title="75 Object.freeze"></a>75 <code>Object.freeze</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> box = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(box);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shape = box;</span><br><span class="line">shape.x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(shape)</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="attr">B</span>: &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">x</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="attr">D</span>: <span class="built_in">ReferenceError</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B 声明一个冻结对象，shape赋值的时候，也指向的是那个冻结对象，所以也是没办法改变值的`Object.isFrozen`判断一个对象是否冻结</details><h1 id="76-变量重命名"><a href="#76-变量重命名" class="headerlink" title="76 变量重命名"></a>76 变量重命名</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: myName &#125; = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;myName&quot;</span>;</span><br><span class="line">C: <span class="literal">undefined</span>;</span><br><span class="line">D: <span class="built_in">ReferenceError</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>D 此时已经重命名为myName了，也就是原先的变量不存在了</details><h1 id="77-纯函数"><a href="#77-纯函数" class="headerlink" title="77 纯函数"></a>77 纯函数</h1><p>以下是个纯函数么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: Yes;</span><br><span class="line">B: No;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A 没有副作用</details><h1 id="78-记忆函数"><a href="#78-记忆函数" class="headerlink" title="78 记忆函数"></a>78 记忆函数</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num <span class="keyword">in</span> cache) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`From cache! <span class="subst">$&#123;cache[num]&#125;</span>`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = num + <span class="number">10</span>;</span><br><span class="line">      cache[num] = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`Calculated! <span class="subst">$&#123;result&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addFunction = add();</span><br><span class="line"><span class="built_in">console</span>.log(addFunction(<span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(addFunction(<span class="number">10</span>));</span><br><span class="line"><span class="built_in">console</span>.log(addFunction(<span class="number">5</span> * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">A: Calculated! <span class="number">20</span> Calculated! <span class="number">20</span> Calculated! <span class="number">20</span></span><br><span class="line"><span class="attr">B</span>: Calculated! <span class="number">20</span> From cache! <span class="number">20</span> Calculated! <span class="number">20</span></span><br><span class="line"><span class="attr">C</span>: Calculated! <span class="number">20</span> From cache! <span class="number">20</span> From cache! <span class="number">20</span></span><br><span class="line"><span class="attr">D</span>: Calculated! <span class="number">20</span> From cache! <span class="number">20</span> <span class="built_in">Error</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 记忆化缓存</details><h1 id="79-forin"><a href="#79-forin" class="headerlink" title="79 forin"></a>79 forin</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myLifeSummedUp = [<span class="string">&quot;☕&quot;</span>, <span class="string">&quot;💻&quot;</span>, <span class="string">&quot;🍷&quot;</span>, <span class="string">&quot;🍫&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">in</span> myLifeSummedUp) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> myLifeSummedUp) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> and <span class="string">&quot;☕&quot;</span> <span class="string">&quot;💻&quot;</span> <span class="string">&quot;🍷&quot;</span> <span class="string">&quot;🍫&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;☕&quot;</span> <span class="string">&quot;💻&quot;</span> <span class="string">&quot;🍷&quot;</span> <span class="string">&quot;🍫&quot;</span> and <span class="string">&quot;☕&quot;</span> <span class="string">&quot;💻&quot;</span> <span class="string">&quot;🍷&quot;</span> <span class="string">&quot;🍫&quot;</span></span><br><span class="line"><span class="attr">C</span>: <span class="string">&quot;☕&quot;</span> <span class="string">&quot;💻&quot;</span> <span class="string">&quot;🍷&quot;</span> <span class="string">&quot;🍫&quot;</span> and <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="attr">D</span>: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> and &#123;<span class="number">0</span>: <span class="string">&quot;☕&quot;</span>, <span class="number">1</span>: <span class="string">&quot;💻&quot;</span>, <span class="number">2</span>: <span class="string">&quot;🍷&quot;</span>, <span class="number">3</span>: <span class="string">&quot;🍫&quot;</span>&#125;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A forin我们可以遍历一个对象自有的、继承的、可枚举的、非Symbol的属性遍历数组取到的是数组的键也就是索引</details><h1 id="80-数组元素"><a href="#80-数组元素" class="headerlink" title="80 数组元素"></a>80 数组元素</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span> + <span class="number">2</span>, <span class="number">1</span> * <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(list);</span><br><span class="line"></span><br><span class="line">A: [<span class="string">&quot;1 + 2&quot;</span>, <span class="string">&quot;1 * 2&quot;</span>, <span class="string">&quot;1 / 2&quot;</span>];</span><br><span class="line">B: [<span class="string">&quot;12&quot;</span>, <span class="number">2</span>, <span class="number">0.5</span>];</span><br><span class="line">C: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">0.5</span>];</span><br><span class="line">D: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 数组里面可以放表达式 但是最后返回的结果是解析吼的结果</details><h1 id="81-不传形参"><a href="#81-不传形参" class="headerlink" title="81 不传形参"></a>81 不传形参</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hi there, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sayHi())</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: Hi there,</span><br><span class="line"><span class="attr">B</span>: Hi there, <span class="literal">undefined</span></span><br><span class="line"><span class="attr">C</span>: Hi there, <span class="literal">null</span></span><br><span class="line"><span class="attr">D</span>: <span class="built_in">ReferenceError</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B</details><h1 id="82-this"><a href="#82-this" class="headerlink" title="82 this"></a>82 this</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> status = <span class="string">&quot;😎&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> status = <span class="string">&quot;😍&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="string">&quot;🥑&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">getStatus</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.status</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(data.getStatus())</span><br><span class="line">  <span class="built_in">console</span>.log(data.getStatus.call(<span class="built_in">this</span>))</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="string">&quot;🥑&quot;</span> and <span class="string">&quot;😍&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;🥑&quot;</span> and <span class="string">&quot;😎&quot;</span></span><br><span class="line"><span class="attr">C</span>: <span class="string">&quot;😍&quot;</span> and <span class="string">&quot;😎&quot;</span></span><br><span class="line"><span class="attr">D</span>: <span class="string">&quot;😎&quot;</span> and <span class="string">&quot;😎&quot;</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B 第一个this来自于调用者data 第二个的this来自于window</details><h1 id="83-修改不存在的对象属性"><a href="#83-修改不存在的对象属性" class="headerlink" title="83 修改不存在的对象属性"></a>83 修改不存在的对象属性</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> city = person.city</span><br><span class="line">city = <span class="string">&quot;Amsterdam&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="attr">B</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">city</span>: <span class="string">&quot;Amsterdam&quot;</span> &#125;</span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">city</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line"><span class="attr">D</span>: <span class="string">&quot;Amsterdam&quot;</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>A 一开始是person上面没有city 此时赋值给的是undefined，后面修改city 因为先前给的不是person的引用，只是对象中的属性，所以person不变</details><h1 id="84-块级作用域外使用声明的const-let变量"><a href="#84-块级作用域外使用声明的const-let变量" class="headerlink" title="84 块级作用域外使用声明的const/let变量"></a>84 块级作用域外使用声明的const/let变量</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">&quot;Sorry, you&#x27;re too young.&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="string">&quot;Yay! You&#x27;re old enough!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(checkAge(<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;Sorry, you&#x27;re too young.&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;Yay! You&#x27;re old enough!&quot;</span>;</span><br><span class="line">C: <span class="built_in">ReferenceError</span>;</span><br><span class="line">D: <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 在块级作用域外面使用const或者let声明的变量抛出异常ReferenceError</details><h1 id="85-promise链式调用"><a href="#85-promise链式调用" class="headerlink" title="85 promise链式调用"></a>85 promise链式调用</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;https://www.website.com/api/user/1&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: fetch方法的结果</span><br><span class="line"><span class="attr">B</span>: 第二次调用fetch方法的结果</span><br><span class="line"><span class="attr">C</span>: 前一个.then()中回调方法返回的结果</span><br><span class="line"><span class="attr">D</span>: 总是<span class="literal">undefined</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>C</details><h1 id="86"><a href="#86" class="headerlink" title="86 !!"></a>86 !!</h1><p>哪个选项是将hasName设置为true的方法，前提是不能将true作为参数传递?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hasName = <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: !!name</span><br><span class="line"><span class="attr">B</span>: name</span><br><span class="line"><span class="attr">C</span>: <span class="keyword">new</span> <span class="built_in">Boolean</span>(name)</span><br><span class="line"><span class="attr">D</span>: name.length</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A</details><h1 id="87-数组可迭代"><a href="#87-数组可迭代" class="headerlink" title="87 数组可迭代"></a>87 数组可迭代</h1><p>输出是什么?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;I want pizza&quot;</span>[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">B: &quot;</span>I<span class="string">&quot;</span></span><br><span class="line"><span class="string">C: SyntaxError</span></span><br><span class="line"><span class="string">D: undefined</span></span><br></pre></td></tr></table></figure></p><details><summary>答案</summary>B</details><h1 id="88-默认参数"><a href="#88-默认参数" class="headerlink" title="88 默认参数"></a>88 默认参数</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2 = num1</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">A: <span class="literal">NaN</span>;</span><br><span class="line">B: <span class="number">20</span>;</span><br><span class="line">C: <span class="built_in">ReferenceError</span>;</span><br><span class="line">D: <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B 交换则不行</details><h1 id="89-import-as-xxx-from-xxx"><a href="#89-import-as-xxx-from-xxx" class="headerlink" title="89 import * as xxx from xxx"></a>89 <code>import * as xxx from xxx</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> data <span class="keyword">from</span> <span class="string">&quot;./module&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: &#123; <span class="attr">default</span>: <span class="function"><span class="keyword">function</span> <span class="title">default</span>(<span class="params"></span>), <span class="title">name</span>: &quot;<span class="title">Lydia</span>&quot; &#125;</span></span><br><span class="line"><span class="function"><span class="title">B</span>: </span>&#123; <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> <span class="title">default</span>(<span class="params"></span>) &#125;</span></span><br><span class="line"><span class="function"><span class="title">C</span>: </span>&#123; <span class="keyword">default</span>: <span class="string">&quot;Hello world&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span> &#125;</span><br><span class="line"><span class="attr">D</span>: Global object <span class="keyword">of</span> <span class="built_in">module</span>.js</span><br></pre></td></tr></table></figure><details><summary>答案</summary>A 使用`import *`得到默认导出和具名导出，其中默认导出是一个函数</details><h1 id="90-类和构造函数"><a href="#90-类和构造函数" class="headerlink" title="90 类和构造函数"></a>90 类和构造函数</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> member);</span><br><span class="line"></span><br><span class="line">A: <span class="string">&quot;class&quot;</span>;</span><br><span class="line">B: <span class="string">&quot;function&quot;</span>;</span><br><span class="line">C: <span class="string">&quot;object&quot;</span>;</span><br><span class="line">D: <span class="string">&quot;string&quot;</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 实例就是一个对象</details><h1 id="91-push"><a href="#91-push" class="headerlink" title="91 push"></a>91 push</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newList.push(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">A: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">B: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">C: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">D: <span class="built_in">Error</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>D push返回数组长度 此时newList是4 不能对string使用push</details><h1 id="92-箭头函数和原型对象"><a href="#92-箭头函数和原型对象" class="headerlink" title="92 箭头函数和原型对象"></a>92 箭头函数和原型对象</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">giveLydiaPizza</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Here is pizza!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> giveLydiaChocolate = <span class="function">() =&gt;</span> <span class="string">&quot;Here&#x27;s chocolate... now go hit the gym already.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(giveLydiaPizza.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(giveLydiaChocolate.prototype)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: &#123; <span class="attr">constructor</span>: ...&#125; &#123; <span class="attr">constructor</span>: ...&#125;</span><br><span class="line"><span class="attr">B</span>: &#123;&#125; &#123; <span class="attr">constructor</span>: ...&#125;</span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">constructor</span>: ...&#125; &#123;&#125;</span><br><span class="line"><span class="attr">D</span>: &#123; <span class="attr">constructor</span>: ...&#125; <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>D 箭头函数没有原型对象</details><h1 id="93-Object-entries"><a href="#93-Object-entries" class="headerlink" title="93 Object.entries"></a>93 <code>Object.entries</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [x, y] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(person)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: name Lydia and age <span class="number">21</span></span><br><span class="line"><span class="attr">B</span>: [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Lydia&quot;</span>] and [<span class="string">&quot;age&quot;</span>, <span class="number">21</span>]</span><br><span class="line"><span class="attr">C</span>: [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>] and <span class="literal">undefined</span></span><br><span class="line"><span class="attr">D</span>: <span class="built_in">Error</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>A `Object.entries`返回一个键值对构成的数组如：`[['name','Lydia'],['age',21]]`</details><h1 id="94-剩余参数的位置"><a href="#94-剩余参数的位置" class="headerlink" title="94 剩余参数的位置"></a>94 剩余参数的位置</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItems</span>(<span class="params">fruitList, ...args, favoriteFruit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...fruitList, ...args, favoriteFruit]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getItems([<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>], <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br><span class="line"><span class="attr">B</span>: [[<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>], <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br><span class="line"><span class="attr">C</span>: [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, [<span class="string">&quot;pear&quot;</span>], <span class="string">&quot;orange&quot;</span>]</span><br><span class="line"><span class="attr">D</span>: <span class="built_in">SyntaxError</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>D `...args`只能放在参数的最后面，否则抛出语法错误`SyntaxError`</details><h1 id="95-return后新行"><a href="#95-return后新行" class="headerlink" title="95 return后新行"></a>95 return后新行</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nums</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span></span><br><span class="line">  (a &gt; b)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a is bigger&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b is bigger&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nums(<span class="number">4</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(nums(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: a is bigger, <span class="number">6</span> and b is bigger, <span class="number">3</span></span><br><span class="line"><span class="attr">B</span>: a is bigger, <span class="literal">undefined</span> and b is bigger, <span class="literal">undefined</span></span><br><span class="line"><span class="attr">C</span>: <span class="literal">undefined</span> and <span class="literal">undefined</span></span><br><span class="line"><span class="attr">D</span>: <span class="built_in">SyntaxError</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B 此时的return js无法判断它下一个值是否是需要的值，自动加了分号，所以结束了</details><h1 id="96-类"><a href="#96-类" class="headerlink" title="96 类"></a>96 类</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;Lydia&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person = <span class="class"><span class="keyword">class</span> <span class="title">AnotherPerson</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;Sarah&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(member.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="string">&quot;Lydia&quot;</span></span><br><span class="line"><span class="attr">B</span>: <span class="string">&quot;Sarah&quot;</span></span><br><span class="line"><span class="attr">C</span>: <span class="built_in">Error</span>: cannot redeclare Person</span><br><span class="line"><span class="attr">D</span>: <span class="built_in">SyntaxError</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>B 我们可以将类设置为等于其他类/函数构造函数。 在这种情况下，我们将Person设置为AnotherPerson。 这个构造函数的名字是Sarah，所以新的Person实例member上的name属性是Sarah。</details><h1 id="97-Symbol"><a href="#97-Symbol" class="headerlink" title="97 Symbol"></a>97 Symbol</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>)]: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(info)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(info))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: &#123;<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>): <span class="string">&#x27;b&#x27;</span>&#125; and [<span class="string">&quot;&#123;Symbol(&#x27;a&#x27;)&quot;</span>]</span><br><span class="line"><span class="attr">B</span>: &#123;&#125; and []</span><br><span class="line"><span class="attr">C</span>: &#123; <span class="attr">a</span>: <span class="string">&quot;b&quot;</span> &#125; and [<span class="string">&quot;a&quot;</span>]</span><br><span class="line"><span class="attr">D</span>: &#123;<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>): <span class="string">&#x27;b&#x27;</span>&#125; and []</span><br></pre></td></tr></table></figure><details><summary>答案</summary>D symbol类型不可枚举，所以`Object.keys`的时候没有返回</details><h1 id="98-剩余参数和箭头函数返回对象"><a href="#98-剩余参数和箭头函数返回对象" class="headerlink" title="98 剩余参数和箭头函数返回对象"></a>98 剩余参数和箭头函数返回对象</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getList = <span class="function">(<span class="params">[x, ...y]</span>) =&gt;</span> [x, y]</span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function"><span class="params">user</span> =&gt;</span> (&#123; <span class="attr">name</span>: user.name, <span class="attr">age</span>: user.age &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getList(list))</span><br><span class="line"><span class="built_in">console</span>.log(getUser(user))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]] and <span class="literal">undefined</span></span><br><span class="line"><span class="attr">B</span>: [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]] and &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="attr">C</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] and &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="attr">D</span>: <span class="built_in">Error</span> and &#123; <span class="attr">name</span>: <span class="string">&quot;Lydia&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B `...y` 此时y是一个数组包含剩余参数，对于箭头函数 如果要返回一个对象，需要使用圆括号包裹</details><h1 id="99-抛出错误"><a href="#99-抛出错误" class="headerlink" title="99 抛出错误"></a>99 抛出错误</h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Lydia&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name());</span><br><span class="line"></span><br><span class="line">A: <span class="built_in">SyntaxError</span>;</span><br><span class="line">B: <span class="built_in">ReferenceError</span>;</span><br><span class="line">C: <span class="built_in">TypeError</span>;</span><br><span class="line">D: <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><details><summary>答案</summary>C 当值不是预期类型时，会抛出TypeErrors。 JavaScript期望name是一个函数，因为我们试图调用它。 但它是一个字符串，因此抛出TypeError：name is not a function当你编写了一些非有效的JavaScript时，会抛出语法错误，例如当你把return这个词写成retrun时。 当JavaScript无法找到您尝试访问的值的引用时，抛出ReferenceErrors。</details><h1 id="100-amp-amp"><a href="#100-amp-amp" class="headerlink" title="100 &amp;&amp;"></a>100 <code>&amp;&amp;</code></h1><p>输出是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 🎉✨ This is my 100th question! ✨🎉</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = <span class="string">`<span class="subst">$&#123;[] &amp;&amp; <span class="string">&#x27;Im&#x27;</span>&#125;</span>possible!</span></span><br><span class="line"><span class="string">You should<span class="subst">$&#123;<span class="string">&#x27;&#x27;</span> &amp;&amp; <span class="string">`n&#x27;t`</span>&#125;</span> see a therapist after so much JavaScript lol`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: possible! You should see a therapist after so much JavaScript lol</span><br><span class="line"><span class="attr">B</span>: Impossible! You should see a therapist after so much JavaScript lol</span><br><span class="line"><span class="attr">C</span>: possible! You shouldn<span class="string">&#x27;t see a therapist after so much JavaScript lol</span></span><br><span class="line"><span class="string">D: Impossible! You shouldn&#x27;</span>t see a therapist after so much JavaScript lol</span><br></pre></td></tr></table></figure><details><summary>答案</summary>B `[]`是一个真值 在`&&`中会返回后面那个值 `''`是一个假值 直接不返回了</details><h1 id="101-判断真假"><a href="#101-判断真假" class="headerlink" title="101 判断真假"></a>101 判断真假</h1><p>输出是什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = (<span class="literal">false</span> || &#123;&#125; || <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> two = (<span class="literal">null</span> || <span class="literal">false</span> || <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> three = ([] || <span class="number">0</span> || <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(one, two, three)</span><br><span class="line"></span><br><span class="line"><span class="attr">A</span>: <span class="literal">false</span> <span class="literal">null</span> []</span><br><span class="line"><span class="attr">B</span>: <span class="literal">null</span> <span class="string">&quot;&quot;</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">C</span>: &#123;&#125; <span class="string">&quot;&quot;</span> []</span><br><span class="line"><span class="attr">D</span>: <span class="literal">null</span> <span class="literal">null</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><details><summary>答案</summary>C</details>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="javascript" scheme="https://zlinni.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vite官方文档浓缩</title>
    <link href="https://zlinni.github.io/posts/559196830/"/>
    <id>https://zlinni.github.io/posts/559196830/</id>
    <published>2022-08-03T00:33:05.000Z</published>
    <updated>2022-08-07T02:22:12.040Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>这一篇为什么要叫 vite 官方文档浓缩呢？一方面是自己不太了解 vite，想通过官方文档进行 vite 的学习。一方面是靠自己的理解处理一下文档的细节。话不多说，开刷</p><p>前置知识：CJS/ESM，HMR，ESM 的引入方式，FOUC</p></div><h1 id="为什么选-Vite"><a href="#为什么选-Vite" class="headerlink" title="为什么选 Vite"></a>为什么选 Vite</h1><p>Vite 诞生的背景是大型应用中 webpack 构建速度变慢，需要很久才能开启服务器，即使通过 HMR 也需要很久浏览器才能反馈出内容。以上都是基于打包的学说，而 Vite 诞生的原因则是浏览器开始逐步支持 JS 模块，他使用非打包的方式构建，以冷启动的方式启动，因此构建速度上面极大快于前者。</p><h1 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h1><p>Vite 先将应用中的模块分为依赖和源码两类，改进服务器启动时间。</p><ul><li>依赖：依赖大多数为开发不会变动的纯 js。一些比较大的依赖(比如组件库)处理的成本也很高，依赖通常有多种模块化的格式(eg:CJS/ESM)</li></ul><p>Vite 在依赖处理这方面使用的是 esbuild，由 go 语言编写，比 js 编写的打包器预构建快 10-100 倍</p><ul><li>源码：源码通常包含一些非 js 文件，比如 css，jsx 或者 vue/svelte 组件，特点是时常会被编辑。同时不是所有的源码都需要同时被加载(比如基于路由拆分的代码模块)</li></ul><p>Vite 以原生 ESM 的方式提供源码。相当于让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码的时候才去转换并提供源码。根据情景动态导入源码，大部分是当前屏幕中有的操作才会被处理。</p><p>以下是常规打包构建和非打包预构建的示例图<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803085603.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803085618.png" alt=""></p><p>看图可以发现 Vite 应该是只构建了当前视图中路由和与该路由相关的模块</p><h1 id="缓慢更新"><a href="#缓慢更新" class="headerlink" title="缓慢更新"></a>缓慢更新</h1><p>当你更新应用的时候，常规的打包器使用 HMR，让一个模块热替换自己，而不会影响页面的其他部分，大大的改善了开发体验。不过当应用程序越来越大的时候，这种方式也显得捉襟见肘。</p><h2 id="边界链失活"><a href="#边界链失活" class="headerlink" title="边界链失活"></a>边界链失活</h2><p>Vite 中，HMR 是在原生 ESM 上面执行的。当编辑一个文件的时候，vite 只需要对已编辑的模块与其最近的 HMR 边界的链失活（不需要全部重构建）使得无论应用大小如何，HMR 始终保持快速更新</p><h2 id="加速页面重载"><a href="#加速页面重载" class="headerlink" title="加速页面重载"></a>加速页面重载</h2><p>Vite 使用 HTTP 请求头来使得页面快速重载，对于依赖使用的是<code>Cache-Control: max-age=31536000,immutable</code>进行强缓存，源码模块通过 304 进行协商缓存。</p><h1 id="仍需要打包的生产环境"><a href="#仍需要打包的生产环境" class="headerlink" title="仍需要打包的生产环境"></a>仍需要打包的生产环境</h1><p>上面的 Bundless 只是基于开发环境的，正式上线还是需要进行打包。原因很简单：</p><p>嵌套打包会导致额外的网络往返，即使使用了 HTTP2 也是效率低下</p><p>所以为了在生产环境中获得更好的加载性能，最好还是对代码进行 tree-shaking，懒加载和 chunk 分割（webpack 那套）</p><h2 id="为什么不用-esbuild-打包？"><a href="#为什么不用-esbuild-打包？" class="headerlink" title="为什么不用 esbuild 打包？"></a>为什么不用 esbuild 打包？</h2><p>esbuild 很快，但是还不够完善，尤其是在 css 和代码分割方面。目前采用的是比较稳定的 rollup</p><h1 id="NPM-依赖解析和预构建"><a href="#NPM-依赖解析和预构建" class="headerlink" title="NPM 依赖解析和预构建"></a>NPM 依赖解析和预构建</h1><p>我们知道 esm 是不支持裸导入的，想要将 es 模块在浏览器中使用，有三种方式</p><ol><li>import from URL</li><li>importmap</li><li>assertion</li></ol><p>其中第二种方式使得后续的裸导入成为可能。</p><p>但是 vite 的思路是这样的，检测所有裸导入的模块，对其进行以下操作：</p><ol><li>使用 esbuild 预构建依赖，将 cjs 和 umd 转换为 esm。</li><li>重写导入为合法的 URL(利用第一种方式)，eg:<code>/node_modules/.vite/deps/my-dep.js?v=f3sf2ebd</code>让浏览器能够识别它们</li></ol><h1 id="更快的-Typescript-转译"><a href="#更快的-Typescript-转译" class="headerlink" title="更快的 Typescript 转译"></a>更快的 Typescript 转译</h1><p>vite 使用 esbuild 转 ts 到 js，比 tsc 速度快 20-30 倍。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803093125.png" alt=""></p><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><p>导入 css 文件将会把内容插入到 style 标签中，同时也带有 HMR 支持。也能以字符串的形式检索处理后的，作为其模块默认导出的 css</p><h2 id="import-内联和变基"><a href="#import-内联和变基" class="headerlink" title="@import 内联和变基"></a>@import 内联和变基</h2><p>Vite 通过 <code>postcss-import</code> 预配置支持了 css 的 <code>@import</code> 内联，意味着所有 css 的 <code>url</code> 引用，即使导入的文件在不同的目录内，也总是自动变基</p><h2 id="postcss"><a href="#postcss" class="headerlink" title="postcss"></a>postcss</h2><p>如果项目包含有效的 PostCSS 配置 (任何受 <code>postcss-load-config</code> 支持的格式，例如 <code>postcss.config.js</code>)，它将会自动应用于所有已导入的 CSS。</p><h2 id="cssmodule"><a href="#cssmodule" class="headerlink" title="cssmodule"></a>cssmodule</h2><p>任何以 <code>.module.css</code> 为后缀名的 CSS 文件都被认为是一个 CSS modules 文件。导入这样的文件会返回一个相应的模块对象：<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803094958.png" alt=""></p><h2 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h2><p>vite 提供了对<code>.scss, .sass, .less, .styl</code> 和 <code>.stylus</code> 文件的内置支持。没必要安装特定的 vite 插件，但需要安装相应的预处理器依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .scss and .sass</span></span><br><span class="line">npm add -D sass</span><br><span class="line"></span><br><span class="line"><span class="comment"># .less</span></span><br><span class="line">npm add -D less</span><br><span class="line"></span><br><span class="line"><span class="comment"># .styl and .stylus</span></span><br><span class="line">npm add -D stylus</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="构建性能优化"><a href="#构建性能优化" class="headerlink" title="构建性能优化"></a>构建性能优化</h1><div class="note primary flat"><p>下面所罗列的功能会自动应用为构建过程的一部分，除非你想禁用它们，否则没有必要显式配置。</p></div><h2 id="css-代码分割"><a href="#css-代码分割" class="headerlink" title="css 代码分割"></a>css 代码分割</h2><p>vite 会自动的将一个异步的 chunk 模块中使用到的 css 代码抽离出来并为其生成一个单独的文件。这个 css 文件将在异步 chunk 加载完成的时候自动通过一个 link 标签载入，该异步 chunk 会保证只在 css 加载完成后执行，避免发生 FOUC</p><p>不过也可以单独抽离所有的 css 到一个文件中，通过设置：build.cssCodeSplit 为 false 来禁用 css 代码分割。</p><h2 id="预加载指令生成"><a href="#预加载指令生成" class="headerlink" title="预加载指令生成"></a>预加载指令生成</h2><p>vite 会为入口 chunk 和它们打包出的 html 中直接引入自动生成<code>&lt;link ref = &#39;modulepreload&#39;&gt;</code>指令。</p><h2 id="异步-chunk-加载优化"><a href="#异步-chunk-加载优化" class="headerlink" title="异步 chunk 加载优化"></a>异步 chunk 加载优化</h2><p>实际项目中，rollup 通常会生成共用 chunk—-被两个或者两个以上的其他 chunk 共享的 chunk。与动态导入相结合，很容易出现下面的情况<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803102110.png" alt=""></p><p>在无优化的情况下，当异步 chunkA 被加载的时候，浏览器必须先解析 A 才知道 A 和 C 的共用关系，这会导致额外的网络往返。</p><p>Vite 使用一个预加载步骤自动重写代码，来分割动态导入调用，以实现当 A 被请求时，C 也将同时被请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Entry) =&gt; A + C;</span><br></pre></td></tr></table></figure><p>C 里面还可能有更多的嵌套共用内容，所以这种预加载处理是很重要的？</p><p>Vite 具体是这么操作的？预加载的原理？</p><h1 id="Vite-使用插件"><a href="#Vite-使用插件" class="headerlink" title="Vite 使用插件"></a>Vite 使用插件</h1><p>Vite 的插件是基于 Rollup 系统的，并且添加了自己额外的选项</p><p>具体如果想要添加一个插件，需要添加到项目的<code>devDependencies</code>中，并在 vite.config.js 配置文件中的 plugins 数组里面引入他。例如，想要为传统浏览器提供支持可以使用<code>@vitejs/plugin-legacy</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm add -D @vitejs/plugin-legacy</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> legacy <span class="keyword">from</span> <span class="string">&quot;@vitejs/plugin-legacy&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    legacy(&#123;</span><br><span class="line">      <span class="attr">targets</span>: [<span class="string">&quot;defaults&quot;</span>, <span class="string">&quot;not IE 11&quot;</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>plugin 可以接收多个插件并且会在里面自动扁平化这个数组。</p><p>获取方式<br>Vite 插件：<a href="https://www.npmjs.com/search?q=vite-plugin&amp;ranking=popularity">传送门</a><br>Rollup 插件：<a href="https://www.npmjs.com/search?q=rollup-plugin&amp;ranking=popularity">传送门</a></p><h2 id="强制插件排序"><a href="#强制插件排序" class="headerlink" title="强制插件排序"></a>强制插件排序</h2><p>Vite 的插件可能和 Rollup 的插件冲突，需要修改插件的执行顺序或者只在构建的时候使用。使用修饰符 enforce 来完成这件事</p><ul><li>pre：在 vite 插件之前</li><li>默认/post：在 vite 插件之后</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> image <span class="keyword">from</span> <span class="string">&quot;@rollup/plugin-image&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...image(),</span><br><span class="line">      <span class="attr">enforce</span>: <span class="string">&quot;pre&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>查看兼容性<a href="https://vite-rollup-plugins.patak.dev/">传送门</a></p><h2 id="按需应用"><a href="#按需应用" class="headerlink" title="按需应用"></a>按需应用</h2><p>指定插件在开发(serve)还是生产(build)中使用:apply 修饰符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vite.config.js</span></span><br><span class="line"><span class="keyword">import</span> typescript2 <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-typescript2&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&quot;vite&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      ...typescript2(),</span><br><span class="line">      <span class="attr">apply</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="依赖预构建"><a href="#依赖预构建" class="headerlink" title="依赖预构建"></a>依赖预构建</h1><p>首次启动 vite 会打印相关信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pre-bundling dependencies: （正在预构建依赖：）</span><br><span class="line">  react</span><br><span class="line">  react-dom</span><br><span class="line">(this will be run only when your dependencies or config have changed)（这将只会在你的依赖或配置发生变化时执行）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为此时 vite 正在执行预构建，且每次有新的插件加进来，都会重新预构建。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>vite 的依赖预构建有两个原因</p><ol><li>CJS 和 UMD 兼容性：开发阶段，vite 要将所有的 cjs 模块转化成为 esm，vite 会智能分析所有的 cjs 或者 umd 依赖然后生成对应 esm（关于怎么转 esm 的一些细节在 webpack 的 bundless 章节已经讲述过）</li><li>性能：除了对 cjs，umd 处理之外，vite 还对有许多内部模块的 esm 依赖关系转为单个模块，举个例子，执行 loadash 的时候，会发送六百多个请求，在浏览器端会造成很大的压力，导致页面的加载速度变慢。</li></ol><p>通过预构建 loadash-es 成为一个模块，那么只需要发送一个请求即可。</p><p>注意：开发环境使用的是 esbuild 转化 esm 模块，生产环境使用的是<code>@rollup/plugin-commonjs</code></p><h2 id="自动依赖搜寻"><a href="#自动依赖搜寻" class="headerlink" title="自动依赖搜寻"></a>自动依赖搜寻</h2><p>如果 vite 没有找到你的缓存，也就是没有 304 协商缓存，也没有强缓存，那么 vite 会自动抓取你的源码，找到引入的依赖项，比如裸导入的模块，并将这些依赖项作为预构建包的入口点，预构建通过 esbuild 进行，所以很快。</p><p>在服务器启动之后，如果发现一个新的依赖项进来，且他没有在缓存中，vite 会重新执行依赖构建过程并重载浏览器。</p><h2 id="Monorepo-和链接依赖"><a href="#Monorepo-和链接依赖" class="headerlink" title="Monorepo 和链接依赖"></a>Monorepo 和链接依赖</h2><p>在一个 Monorepo 启动中，该仓库的某个依赖可能会成为另一个包的依赖，vite 会自动侦测没有从 nodemodules 里面解析的依赖项，并将链接的依赖视为源码，他不会尝试打包被链接的依赖，而是会分析被链接依赖的依赖列表。</p><p>不过这需要被链接的依赖被导出为 esm 格式。如果不是，那么你可以在配置中将此依赖添加到 optimizeDeps.include 和 build.commonjsOptions.include 这两项中。<code>optimizeDeps.include</code> 和 <code>build.commonjsOptions.include</code> 这两项中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="attr">optimizeDeps</span>: &#123;</span><br><span class="line">    <span class="attr">include</span>: [<span class="string">&quot;linked-dep&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">commonjsOptions</span>: &#123;</span><br><span class="line">      <span class="attr">include</span>: [<span class="regexp">/linked-dep/</span>, <span class="regexp">/node_modules/</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当这个被链接的依赖发生变更后，在重启开发服务器时在命令中带上 <code>--force</code> 选项让所有更改生效。</p><p>重复删除</p><p>由于对链接依赖的解析方式不同，传递性的依赖项可能会不正确地进行重复数据删除，而造成运行时的问题。如果你偶然发现了这个问题，请使用 npm pack 来修复它。</p><h2 id="自定义行为"><a href="#自定义行为" class="headerlink" title="自定义行为"></a>自定义行为</h2><p>默认的依赖项为启发式可能并不总是可取的，可以使用 optimizeDeps 配置项：include 和 exclude 去配置你想要寻找的依赖或者排除依赖。</p><p>建议：如果依赖项很大（有很多内部模块）或者是 CJS，你应该包含他让 vite 自动去处理，如果依赖项很小并且已经是 esm，那么可以排除他，让浏览器自动加载他。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>包含文件系统缓存和浏览器缓存<br>vite 会将预构建的依赖缓存到<code>node_modules/.vite</code>.它根据几个源来决定是否重新执行预构建</p><ol><li>packgejson 中的 dependencies 列表</li><li>包管理器的 lockfile</li><li>在 vite.config.js 中相关字段配置过的（比如刚刚说的 optimize:inclde/exclude）</li></ol><p>如果想要 vite 强制依赖预构建，需要使用<code>--force</code>来启动开发服务器，或者手动删除<code>node_modules/.vite</code></p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>解析后的依赖请求会以 http 头<code>max-age:31536000 immutable</code>进行强缓存，用来提高开发时的页面性能。一旦被缓存，这些请求将永远不会到达开发服务器。如果安装了不同版本的则附加的版本 query 会自动使他们失效(保证只能有一个版本)。如果要调试依赖，可以使用：</p><ol><li>通过浏览器调试工具的 Network 选项卡暂用缓存</li><li>重启 vite dev server 并<code>--force</code>命令以重新进行依赖预构建。</li><li>重载页面</li></ol><h1 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h1><h2 id="将资源引入为-URL"><a href="#将资源引入为-URL" class="headerlink" title="将资源引入为 URL"></a>将资源引入为 URL</h2><p>服务时，引入一个静态资源会返回解析后的公共路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> imgUrl <span class="keyword">from</span> <span class="string">&quot;./img.png&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;hero-img&quot;</span>).src = imgUrl;</span><br></pre></td></tr></table></figure><p>比如 imgURL 在开发时会是<code>/img.png</code>，生产构建后会是<code>/assets/img.2d8efhg.png</code></p><p>这个类似于 webpack 的 file-loader，但是不一样的点在于既可以引入绝对公共路径，也可以引入相对路径</p><ul><li><code>url()</code>在 css 中的引用会以同样方式进行处理。</li><li>如果 <code>vite</code> 引用了 <code>vue</code> 插件，<code>vue sfc</code> 模板中的资源都将自动转换为导入</li><li>常见的图像，媒体，和字体文件类型将被自动检测。可以使用 <code>assetsInclude</code> 选项拓展内部列表。</li><li>引用的资源作为构建资源图的一部分包括在内，将生成散列文件名，并可由插件处理优化。</li><li>较小的资源体积与 <code>assetsInlineLimit</code> 选项值将会被内联为 <code>base64URL</code></li></ul><h2 id="显式-URL-引入"><a href="#显式-URL-引入" class="headerlink" title="显式 URL 引入"></a>显式 URL 引入</h2><p>未被包含在内部列表或 <code>assetsInclude</code> 中的资源，可以使用<code>?url</code>后缀显式导入为一个 URL。比如导入<code>Houdini Paint Worklets</code> 时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> workletURL <span class="keyword">from</span> <span class="string">&quot;extra-scalloped-border/worklet.js?url&quot;</span>;</span><br><span class="line">CSS.paintWorklet.addModule(workletURL);</span><br></pre></td></tr></table></figure><h2 id="将资源引入为字符串"><a href="#将资源引入为字符串" class="headerlink" title="将资源引入为字符串"></a>将资源引入为字符串</h2><p>资源可以使用 ?raw 后缀声明作为字符串引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shaderString <span class="keyword">from</span> <span class="string">&quot;./shader.glsl?raw&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="导入脚本作为-Worker"><a href="#导入脚本作为-Worker" class="headerlink" title="导入脚本作为 Worker"></a>导入脚本作为 Worker</h2><p>脚本可以通过 <code>?worker</code> 或 <code>?sharedworker</code> 后缀导入为 web worker。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在生产构建中将会分离出 chunk</span></span><br><span class="line"><span class="keyword">import</span> Worker <span class="keyword">from</span> <span class="string">&quot;./shader.js?worker&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line"><span class="comment">// sharedworker</span></span><br><span class="line"><span class="keyword">import</span> SharedWorker <span class="keyword">from</span> <span class="string">&quot;./shader.js?sharedworker&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> sharedWorker = <span class="keyword">new</span> SharedWorker();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联为 base64 字符串</span></span><br><span class="line"><span class="keyword">import</span> InlineWorker <span class="keyword">from</span> <span class="string">&quot;./shader.js?worker&amp;inline&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="public-目录"><a href="#public-目录" class="headerlink" title="public 目录"></a>public 目录</h2><p>特点：</p><ol><li>不会被源码引用（js 文件）</li><li>必须保持源文件名称(不被 hash)</li><li>或者只想要得到它的 URL</li></ol><p>上述资源放入 public 最好。可以通过<code>/</code>在开发的时候直接访问到比如<code>public/icon.png =&gt; /icon.png</code></p><p>默认目录：<code>&lt;root&gt;/public</code>,但可以通过<code>publicDir</code>配置</p><h2 id="new-URL-url-import-meta-url"><a href="#new-URL-url-import-meta-url" class="headerlink" title="new URL(url, import.meta.url)"></a><code>new URL(url, import.meta.url)</code></h2><p><code>import.meta.url</code>是 esm 的原生功能，可以暴露当前模块的 url，在 js 模块中可以通过相对路径获得一个完整的静态资源 url。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> imgUrl = <span class="keyword">new</span> URL(<span class="string">&quot;./img.png&quot;</span>, <span class="keyword">import</span>.meta.url).href;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;hero-img&quot;</span>).src = imgUrl;</span><br></pre></td></tr></table></figure><p>这在现代浏览器中能够原生使用 - 实际上，Vite 并不需要在开发阶段处理这些代码！</p><p>这个模式同样还可以通过字符串模板支持动态 URL：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImageUrl</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> URL(<span class="string">`./dir/<span class="subst">$&#123;name&#125;</span>.png`</span>, <span class="keyword">import</span>.meta.url).href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生产构建时，Vite 才会进行必要的转换保证 URL 在打包和资源哈希后仍指向正确的地址。</p><p>注意无法在 ssr 中使用，因为这个是 esm 的方法，也就意味着在 node 和浏览器有不同的语义，服务器也没办法预先确定客户端主机 url</p><h1 id="构建生产版本"><a href="#构建生产版本" class="headerlink" title="构建生产版本"></a>构建生产版本</h1><p>命令：<code>vite build</code>默认情况使用<code>&lt;root&gt;/index.html</code>作为构建入口。</p><h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><p>vite 的目标是支持 esm 的浏览器，按照条件进行 browerslist 查询的浏览器</p><p>也可以手动通过<code>build.target</code>配置项构建指定目标。最低支持 es2015</p><p>默认情况下 vite 不包含任何 polyfill，只负责转义，要使用相关的服务进行 polyfill 生成，<code>Polyfill.io</code></p><p>传统浏览器需要插件<code>@vitejs/plugin-legacy</code>的支持，它将会自动生成传统版本的 chunk 与其对应 es 方面语言的 polyfill。</p><h2 id="公共基础路径"><a href="#公共基础路径" class="headerlink" title="公共基础路径"></a>公共基础路径</h2><p>配置 base 项所有的资源会按此路径重写，也可以通过命令行：<code>vite build --base=/my/public/path/</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/vite官方文档浓缩.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Webpack系列" scheme="https://zlinni.github.io/categories/Webpack%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Webpack" scheme="https://zlinni.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化③Bundless基础设施建设</title>
    <link href="https://zlinni.github.io/posts/351158764/"/>
    <id>https://zlinni.github.io/posts/351158764/</id>
    <published>2022-08-02T06:14:30.000Z</published>
    <updated>2022-08-02T08:26:26.799Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>本文将简述前端通过不打包的方式将代码运行在浏览器上的几种方式</p></div><h1 id="原理与浏览器中的-ESM"><a href="#原理与浏览器中的-ESM" class="headerlink" title="原理与浏览器中的 ESM"></a>原理与浏览器中的 ESM</h1><p>当下，主流浏览器已经逐步支持 js 原生模块的导入，出现了很多 bundless 的构建方案，比如 vite，snowpack 等。原理就是利用浏览器对于原生 esm 的支持，进行代码的开发和部署。</p><h2 id="Native-Import-import-from-URL"><a href="#Native-Import-import-from-URL" class="headerlink" title="Native Import: import from URL"></a>Native Import: import from URL</h2><p>通过<code>script[type=module]</code>，可以直接在浏览器中使用原生 ESM，使得前端不打包成为可能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> lodash <span class="keyword">from</span> <span class="string">&quot;http://cdn.skypack.dev/lodash&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于前端运行在浏览器中，所以他也只能从 URL 中引入 package</p><ol><li>绝对路径：<code>http://cdn.skypack.dev/lodash</code></li><li>相对路径：<code>./lib.js</code></li></ol><p>现在打开浏览器控制台，把下面的代码粘贴在控制台中，就可以调试 loadash 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; lodash = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;https://cdn.skypack.dev/lodash&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&gt; lodash.get(&#123; <span class="attr">a</span>: <span class="number">3</span> &#125;, <span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Import-Map"><a href="#Import-Map" class="headerlink" title="Import Map"></a>Import Map</h2><p>不过 http Import 每次都要导入完全的 URL，这个肯定是不太合理的，相比以前的裸导入，很不方便,如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lodash <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br></pre></td></tr></table></figure><p>他不同于 nodejs 依赖系统文件系统，层层寻找<code>node_modules</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/app/packages/project-a/node_modules/lodash/index.js</span><br><span class="line">/home/app/packages/node_modules/lodash/index.js</span><br><span class="line">/home/app/node_modules/lodash/index.js</span><br><span class="line">/home/node_modules/lodash/index.js</span><br></pre></td></tr></table></figure><p>在 esm 中，可以通过 ImportMap 使得裸导入成为可正常工作</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;importmap&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#123;</span></span><br><span class="line"><span class="javascript">    <span class="string">&quot;imports&quot;</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;lodash&quot;</span>: <span class="string">&quot;http://cdn.skypack.dev/lodash&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;ms&quot;</span>: <span class="string">&quot;https://cdn.skypack.dev/ms&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时可以与以前同样的方式进行模块导入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> loadash <span class="keyword">from</span> <span class="string">&#x27;loadash&#x27;</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;loadash&#x27;</span>).then(<span class="function"><span class="params">_</span>=&gt;</span>...)</span><br></pre></td></tr></table></figure><p>那么通过裸导入如何导入子路径呢？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;importmap&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  &#123;</span></span><br><span class="line"><span class="javascript">    <span class="string">&quot;imports&quot;</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;lodash&quot;</span>: <span class="string">&quot;https://cdn.skypack.dev/lodash&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;lodash/&quot;</span>: <span class="string">&quot;https://cdn.skypack.dev/lodash/&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> get <span class="keyword">from</span> <span class="string">&quot;lodash/get.js&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Import-Assertion"><a href="#Import-Assertion" class="headerlink" title="Import Assertion"></a>Import Assertion</h2><p>通过<code>script[type=module]</code>，不仅可以引入 js 资源，甚至可以引入 json/css 资源，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">&quot;./xxx.json&quot;</span> assert &#123; <span class="attr">type</span>: <span class="string">&quot;json&quot;</span> &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="如何将-CJS-转化为-ESM"><a href="#如何将-CJS-转化为-ESM" class="headerlink" title="如何将 CJS 转化为 ESM"></a>如何将 CJS 转化为 ESM</h1><p>Bundless 的兴起，要求所有的模块都是 ESM 模块格式。</p><p>目前社区有一部分模块同时支持 ESM 和 CJS，但仍有许多模块仅支持 CJS/UMD,因此将 CJS 转为 ESM 是全部模块 ESM 化的过度阶段</p><h2 id="ESM-与-CJS-的导入导出不同"><a href="#ESM-与-CJS-的导入导出不同" class="headerlink" title="ESM 与 CJS 的导入导出不同"></a>ESM 与 CJS 的导入导出不同</h2><p>在 ESM 中，导入导出有两种方式</p><ol><li>具名导出导入</li><li>默认导出导入</li></ol><p>eg</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具名导入导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125;;</span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&quot;sum&quot;</span>;</span><br><span class="line"><span class="comment">// 默认导入导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum;</span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">&quot;sum&quot;</span>;</span><br></pre></td></tr></table></figure><p>而在 CJS 中,导入导出的方法只有一种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = sum;</span><br></pre></td></tr></table></figure><p>而所谓的 exports 仅仅是 module.exports 的引用而已</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span> = <span class="built_in">module</span>.exports;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两个等价</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.a = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>下列举两个例子,来验证他俩的区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">module</span>.exports.b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="built_in">require</span>(<span class="string">&quot;./hello&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hello);</span><br><span class="line"><span class="comment">// 输出是&#123;a:3,b:4&#125;</span></span><br></pre></td></tr></table></figure><p>第二</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="built_in">require</span>(<span class="string">&quot;./hello&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hello);</span><br><span class="line"><span class="comment">// 输出是&#123;b:4&#125;</span></span><br></pre></td></tr></table></figure><p>正因为它们两者的不同,所以在两者转换的时候有一些兼容问题需要去解决.</p><h2 id="exports-的转化"><a href="#exports-的转化" class="headerlink" title="exports 的转化"></a>exports 的转化</h2><p>正因为两者不同,所以当 exports 转化的时候,既要转换为<code>exports&#123;&#125;</code>又要转化为<code>export default&#123;&#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; a &#125;;</span><br></pre></td></tr></table></figure><p>如果只转化为具名导出不转化为默认导出会发生什么?<br>eg</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Input: CJS</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">3</span>; <span class="comment">// index.cjs =&gt;提供&#123;a:3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = <span class="built_in">require</span>(<span class="string">&quot;.&quot;</span>); <span class="comment">// foo.cjs</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// foo.cjs 输出3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: ESM</span></span><br><span class="line"><span class="comment">// 这是有问题的错误转换示例:</span></span><br><span class="line"><span class="comment">// 此处 a 应该再 export default &#123; a &#125; 一次</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">3</span>; <span class="comment">// index.mjs 提供3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> o <span class="keyword">from</span> <span class="string">&quot;.&quot;</span>; <span class="comment">// foo.mjs 获得3</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// foo.mjs 出大问题 3不是对象</span></span><br></pre></td></tr></table></figure><h2 id="module-exports转化"><a href="#module-exports转化" class="headerlink" title="module.exports转化"></a><code>module.exports</code>转化</h2><p>对于<code>module.exports</code>,我们可以遍历其中的 key,通过 ast,将 key 转化为具名导出,将<code>module.exports</code>转化为默认导出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>如果<code>module.exports</code>导出的是函数该如何处理? 特别是<code>exports</code>和<code>module.exports</code>的程序逻辑混合在一起?</p><p>以下是一个正确的转化结果:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">()=&gt;</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">export</span>.a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span>.b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">()=&gt;</span>&#123;&#125;;</span><br><span class="line">sum.a = <span class="number">3</span>;</span><br><span class="line">sum.b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> = sum;</span><br></pre></td></tr></table></figure></p><p>也可以这么处理:将<code>module.exports</code>与<code>exports</code>的代码使用函数包裹起来,此时我们无需关心其中的逻辑细节.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> esm$<span class="number">1</span> = &#123; <span class="attr">export</span>:&#123;&#125; &#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>,<span class="built_in">exports</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="function">()=&gt;</span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">exports</span>.a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">exports</span>.b = <span class="number">4</span>;</span><br><span class="line">&#125;)(esm$<span class="number">1</span>,esm$<span class="number">1.</span><span class="built_in">exports</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> esm = esm$<span class="number">1.</span><span class="built_in">exports</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; esm <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="一些复杂的转换"><a href="#一些复杂的转换" class="headerlink" title="一些复杂的转换"></a>一些复杂的转换</h2><p>ESM与CJS不仅仅是语法层次上的不同,本身的思维逻辑就完全不一样.所以有一些较为复杂的转换,不做讨论.<br>比如:</p><ol><li>如何处理<code>_dirname</code>;</li><li>如何处理<code>require(dynamicString)</code>;</li><li>如何处理cjs的编程逻辑</li></ol><p>以下代码涉及到编程逻辑,由于<code>exports</code>是一个动态的js对象,而他自然可以使用两次,那应该如何正确的被编为esm呢?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input: index.cjs</span></span><br><span class="line"><span class="built_in">exports</span>.sum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">exports</span>.sum = <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>以下是一种不会出现问题的转换结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _default = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> sum = (_default.sum = <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    sum = _default.sum = <span class="number">100</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> _default;</span><br><span class="line"><span class="keyword">export</span> &#123;sum&#125;</span><br></pre></td></tr></table></figure></p><h2 id="CJS-to-ESM的构建工具"><a href="#CJS-to-ESM的构建工具" class="headerlink" title="CJS to ESM的构建工具"></a>CJS to ESM的构建工具</h2><p>CJS向ESM转换,自然有构建工具的参与.比如:<br><code>@rollup/plugin-commonjs</code></p><p>甚至把一些 CommonJS 库转化为 ESM，并且置于 CDN 中，使得我们可以直接使用，而无需构建工具参与</p><ul><li><code>https://cdn.skypack.dev/(opens new window)</code></li><li><code>https://jspm.org/</code></li></ul><h1 id="Bundless的优势与不足"><a href="#Bundless的优势与不足" class="headerlink" title="Bundless的优势与不足"></a>Bundless的优势与不足</h1><p>优势在于 不需要处理打包的问题,直接放到浏览器上面使用.<br>不足在于 现在还有很多模块没有支持esm,所以转换cjs到esm是个问题</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/Bundless基础设施建设.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Webpack系列" scheme="https://zlinni.github.io/categories/Webpack%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Webpack" scheme="https://zlinni.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化②打包体积优化</title>
    <link href="https://zlinni.github.io/posts/1572391089/"/>
    <id>https://zlinni.github.io/posts/1572391089/</id>
    <published>2022-08-02T02:42:19.000Z</published>
    <updated>2022-08-02T08:26:26.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>本篇讲述 webpack 打包体积优化的思路和方向</p></div><h1 id="如何分析打包体积"><a href="#如何分析打包体积" class="headerlink" title="如何分析打包体积"></a>如何分析打包体积</h1><p>做过第三方依赖 CDN 引入的话，应该都了解到需要使用<code>webpack-bundle-analyzer</code>分析打包后的体积。</p><p>原理就是 webpack 打包后 Stats 数据进行分析。在 webpack compiler 的 done hook 进行处理。见源码；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler.hooks.done.tapAsync(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>, <span class="function">(<span class="params">stats</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>stats数据：一个json文件，包含了模块的统计信息，用cli命令生成<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802134913.png" alt=""></p><p>在默认配置下，<code>webpack-bundle-analyzer</code>(opens new window)将会启动服务打开一个各个 chunk 下各个 module 占用体积的可视化图。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802104855.png" alt=""></p><p>可以通过他找到在打包体积中最大的模块并进行优化。</p><p>在查看页面有三个选项：</p><ol><li>stat：每个模块的原始体积。</li><li>parsed：每个模块经过 webpack 打包处理后的体积，比如 terser 等做了压缩，就会显示在上面。</li><li>gzip:经过 gzip 压缩后的体积。</li></ol><h2 id="analyze"><a href="#analyze" class="headerlink" title="analyze"></a>analyze</h2><p>在实际项目中，往往通过环境变量 analyze 配置该插件，code 如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> BundleAnalyzerPlugin =</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&quot;webpack-bundle-analyzer&quot;</span>).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. BundleAnalyzerPlugin是如何工作的?</span></span><br><span class="line"><span class="comment">// 2. stat parsed gzip分别是何意义</span></span><br><span class="line"><span class="comment">// 3. terserPlugin 对此结果有影响吗</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> webpack(&#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;./index.js&quot;</span>,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [process.env.ANALYZE &amp;&amp; <span class="keyword">new</span> BundleAnalyzerPlugin()],</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1().run(<span class="function">(<span class="params">err, stat</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>在打包时，通过制定环境变量即可分析打包体积。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE=<span class="literal">true</span> npm run build</span><br></pre></td></tr></table></figure><h1 id="js-压缩"><a href="#js-压缩" class="headerlink" title="js 压缩"></a>js 压缩</h1><p>通过 ast 分析，根据选项配置一些策略，来生成一颗颗粒更小体积的 AST 并生成代码</p><p>目前前端工程化中使用 terser 和 swc 进行 js 代码压缩，它们拥有相同的 api</p><p>常见的压缩 ast 的几种方案如下：</p><h2 id="去除多余字符，空格，换行以及注释"><a href="#去除多余字符，空格，换行以及注释" class="headerlink" title="去除多余字符，空格，换行以及注释"></a>去除多余字符，空格，换行以及注释</h2><p>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时这个文件大小是 62kb，一般来说中文会占用更多的空间。</p><p>多余的空白字符会占用大量的体积，如空格，换行符，另外注释也会占用文件体积。当我们把所有空白和注释都去掉之后，代码体积减小到 30kb，如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过替换掉多余的字符会有什么影响呢？</p><p>其实有影响的，比如代码压缩到一行的时候要注意行尾的分号。</p><h2 id="压缩变量名，函数名，以及属性名"><a href="#压缩变量名，函数名，以及属性名" class="headerlink" title="压缩变量名，函数名，以及属性名"></a>压缩变量名，函数名，以及属性名</h2><p>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们可以很明显的知道这两个变量只在 sum 的作用域产生影响，所以他们的变量名其实可以更短。</p><p>不仅如此，如果 sum 函数还是在一个 module 中不被导出，那么 sum 这个函数名也可以更短。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩: 缩短变量名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再压缩: 去除空余字符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上的示例中，当代码完成压缩的时候，其实代码的混淆也顺带完成。但此时缩短变量的命名需要在 ast 中支持，不至于在作用域中造成命名冲突。</p><h2 id="解析程序逻辑，合并声明以及布尔值简化"><a href="#解析程序逻辑，合并声明以及布尔值简化" class="headerlink" title="解析程序逻辑，合并声明以及布尔值简化"></a>解析程序逻辑，合并声明以及布尔值简化</h2><p>合并声明的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后=&gt;</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;jojo&quot;</span>,</span><br><span class="line">  age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>布尔值简化的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!b &amp;&amp; !c &amp;&amp; !d &amp;&amp; !e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后=&gt;</span></span><br><span class="line">!(b || c || d || e);</span><br></pre></td></tr></table></figure><h2 id="解析程序逻辑：编译预运算"><a href="#解析程序逻辑：编译预运算" class="headerlink" title="解析程序逻辑：编译预运算"></a>解析程序逻辑：编译预运算</h2><p>在编译期进行运算，减少运行时的计算量，如下示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">const</span> ONE_YEAR = <span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">const</span> ONE_YAAR = <span class="number">31536000</span>;</span><br></pre></td></tr></table></figure><p>以及一个更复杂的例子，简直是杀手锏级别的优化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;hello, world&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h1><p>介绍：<br>Tree Shaking 指的是基于 ES Module 进行静态分析，通过 AST 将用不到的函数进行移除，从而减小打包体积。</p><p>例子：by rollup</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&quot;./math.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>mathjs</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于sub函数没有被引用到所以最终不会对他进行打包</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包后的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maths.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TREE-SHAKING */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">5</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><h2 id="import"><a href="#import" class="headerlink" title="import *"></a><code>import *</code></h2><p>当使用<code>import *</code>的时候，treeshaking 仍然有效.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> \* <span class="keyword">as</span> maths <span class="keyword">from</span> <span class="string">&quot;./maths&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tree Shaking 依然生效</span></span><br><span class="line">maths.sum(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">maths[<span class="string">&quot;sum&quot;</span>](<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><code>import * as maths</code>，其中 <code>maths</code> 的数据结构是固定的，无复杂数据，通过 AST 分析可查知其引用关系。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maths = &#123;</span><br><span class="line">  <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">sub</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="JSON-TreeShaking"><a href="#JSON-TreeShaking" class="headerlink" title="JSON TreeShaking"></a>JSON TreeShaking</h2><p>tree shaking甚至可以对json进行优化，原理是因为json格式简单，通过ast容易预测结果，不像js对象有复杂的类型与副作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;a&quot;</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;b&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">&quot;./main.json&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.b 由于未使用到，仍旧不会被打包</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a);</span><br></pre></td></tr></table></figure><h2 id="引入支持-Tree-Shaking-的-Package"><a href="#引入支持-Tree-Shaking-的-Package" class="headerlink" title="引入支持 Tree Shaking 的 Package"></a>引入支持 Tree Shaking 的 Package</h2><p>在<a href="https://npm.devtool.tech/lodash-es">npm.devtool.tech</a>中我们可以很清楚的看到每个包是否支持treeshaking。我们最好是引入支持treeshaking的包来减小生产环境的体积。</p><h1 id="corejs-polyfill"><a href="#corejs-polyfill" class="headerlink" title="corejs polyfill"></a>corejs polyfill</h1><p>corejs是关于ES标准最出名的polyfill。polyfill指的是当浏览器不支持某个最新api的时候，他帮你实现，中文名称叫做垫片。</p><p>由于垫片的存在，打包后的体积便会增加，所支持的浏览器版本越高，需要的垫片越少，打包体积越小。</p><p>相应的如果要向下兼容，那么垫片就越多，打包体积就越大。</p><p>看一个<code>Array.from</code>的垫片代码,有了他的存在，任意浏览器都能使用这个api<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Production steps of ECMA-262, Edition 6, 22.1.2.1</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.from) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.from = <span class="function">() =&gt;</span> &#123; <span class="comment">// 省略若干代码 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而Corejs的厉害之处就是他包含了所有的es6+的polyfill，并且集成在babel等编译工具之中。</p><p>曾经我们试过使用<code>?.</code>可选链操作符，babel会我们对应添加支持。但是如果是新的api就不是了，就需要corejs做polyfill帮助我们能够使用。目前他已经集成了，所以不用考虑这个问题。</p><h1 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h1><p>我们知道corejs能帮助我们给向下的浏览器兼容新的api，也知道了他的缺点是兼容的越多，需要的polyfill越多，体积越大。相应的就诞生了垫片体积控制工具browserslist</p><p>他用特定的语句来查询浏览器列表，如： <code>last 2 Chrome versions</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npx browserslist <span class="string">&quot;last 2 Chrome versions&quot;</span></span><br><span class="line">chrome <span class="number">100</span></span><br><span class="line">chrome <span class="number">99</span></span><br></pre></td></tr></table></figure><p>细说起来，他是现代前端工程化必不可缺的一种工具。无论是处理js的babel，还是处理css的postcss，凡是与垫片有关的，它们背后都有browserslist的身影。</p><ul><li><code>babel</code>，在 <code>@babel/preset-env</code> 中使用 <code>core-js</code> 作为垫片</li><li><code>postcss</code> 使用 <code>autoprefixer</code> 作为垫片</li></ul><p>刚刚也说了垫片体积和浏览器版本直接挂钩，所以如果项目只需要支持最新的两个谷歌浏览器，那么关于browserslist的查询，可以写作<code>last 2 Chrome versions</code></p><p>随着时间的推移，该查询语句会返回更新的浏览器，垫片的体积就会减小。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>browserslist的原理实际上就是根据正则解析查询语句。对浏览器版本数据库<code>caniuse-lite</code>进行查询，返回所得到的浏览器版本列表。</p><p>因为browserslist并不维护数据库，因此他会经常提醒你去更新<code>caniuse-lite</code>这个库，由于lock文件的存在，需要使用以下的命令去手动更新数据库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx browserslist@last --update-db</span><br></pre></td></tr></table></figure><p>该命令将会对<code>caniuse-lite</code>进行升级，可以体现在lock文件中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">     <span class="string">&quot;caniuse-lite&quot;</span>: &#123;</span><br><span class="line">-      <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.30001265&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;resolved&quot;</span>: <span class="string">&quot;https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001265.tgz&quot;</span>,</span><br><span class="line">-      <span class="string">&quot;integrity&quot;</span>: <span class="string">&quot;sha512-YzBnspggWV5hep1m9Z6sZVLOt7vrju8xWooFAgN6BA5qvy98qPAPb7vNUzypFaoh2pb3vlfzbDO8tB57UPGbtw==&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.30001332&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;resolved&quot;</span>: <span class="string">&quot;https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001332.tgz&quot;</span>,</span><br><span class="line">+      <span class="string">&quot;integrity&quot;</span>: <span class="string">&quot;sha512-10T30NYOEQtN6C11YGg411yebhvpnC6Z102+B95eAsN0oB6KUs01ivE8u+G6FMIRtIrVlYXhL+LUwQ3/hXwDWw==&quot;</span>,</span><br><span class="line">       <span class="string">&quot;dev&quot;</span>: <span class="literal">true</span></span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><h2 id="一些常用的查询语法"><a href="#一些常用的查询语法" class="headerlink" title="一些常用的查询语法"></a>一些常用的查询语法</h2><p>如下：</p><h3 id="根据用户份额"><a href="#根据用户份额" class="headerlink" title="根据用户份额"></a>根据用户份额</h3><blockquote><p>5%: 在全球用户份额大于 5% 的浏览器<br>5% in CN: 在中国用户份额大于 5% 的浏览器</p></blockquote><h3 id="根据最新浏览器版本"><a href="#根据最新浏览器版本" class="headerlink" title="根据最新浏览器版本"></a>根据最新浏览器版本</h3><ul><li>last 2 versions: 所有浏览器的最新两个版本</li><li>last 2 Chrome versions: Chrome 浏览器的最新两个版本</li></ul><h3 id="不再维护的浏览器"><a href="#不再维护的浏览器" class="headerlink" title="不再维护的浏览器"></a>不再维护的浏览器</h3><ul><li>dead: 官方不在维护已过两年，比如 IE10</li></ul><h3 id="浏览器版本号"><a href="#浏览器版本号" class="headerlink" title="浏览器版本号"></a>浏览器版本号</h3><ul><li>Chrome &gt; 90: Chrome 大于 90 版本号的浏览器</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/打包体积优化.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Webpack系列" scheme="https://zlinni.github.io/categories/Webpack%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Webpack" scheme="https://zlinni.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>CodeTop0-100</title>
    <link href="https://zlinni.github.io/posts/3103992604/"/>
    <id>https://zlinni.github.io/posts/3103992604/</id>
    <published>2022-08-01T02:41:13.000Z</published>
    <updated>2022-09-04T08:13:12.461Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>codetop 前一百题，review and review</p></div><h1 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3. 无重复字符的最长字串"></a>3. 无重复字符的最长字串</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p>老题新做<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802084740.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>利用 includes api 的特性以及循环弹出顶层的特性，将每个元素 push 进来后下一轮比对是否存在，存在则弹出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> str <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.includes(str)) &#123;</span><br><span class="line">      arr.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    arr.push(str);</span><br><span class="line">    <span class="keyword">if</span> (max &lt; arr.length) max = arr.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802085418.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路：从后往前对比插入，大的数字优先插入末尾。但需要注意的是某一方提前结束的情况发生，此时如果一方提前结束了，终止判断直接用后一方直到后一方数字完全用完(j&lt;0)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = m - <span class="number">1</span>,</span><br><span class="line">    j = n - <span class="number">1</span>,</span><br><span class="line">    len = m + n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    nums1[len--] = i &gt;= <span class="number">0</span> &amp;&amp; nums1[i] &gt;= nums2[j] ? nums1[i--] : nums2[j--];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a>165. 比较版本号</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802090214.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路是分割<code>.</code>并遍历最长的 length（因为要同时比较），相等跳过，不等判断返回结果。</p><p>注意 前导 0 的情况可以用<code>~~</code>或者 <code>parseInt</code> 去解决，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compareVersion = <span class="function"><span class="keyword">function</span> (<span class="params">version1, version2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> v1arr = version1.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> v2arr = version2.split(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> maxLen = <span class="built_in">Math</span>.max(v1arr.length, v2arr.length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> v1 = v1arr[i] || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> v2 = v2arr[i] || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v1 === v2) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (~~v1 &lt; ~~v2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (~~v1 &gt; ~~v2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802092739.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路：从后往前累加到一个数组内，因为是字符串要转数字使用+ 最后从数组还原使用<code>join(&#39;&#39;)</code><br>小技巧，从后往前读可以使用新的 api <code>Array.at(-1)</code> 注意余数和进位数字的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addStrings = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> last = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> maxLen = <span class="built_in">Math</span>.max(num1.length, num2.length);</span><br><span class="line">  <span class="keyword">let</span> newAdd = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">while</span> (maxLen--) &#123;</span><br><span class="line">    <span class="keyword">let</span> c1 = num1.at(last) ? +num1.at(last) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> c2 = num2.at(last) ? +num2.at(last) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> count = c1 + c2 + newAdd;</span><br><span class="line">    res.unshift((count % <span class="number">10</span>) + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    newAdd = <span class="built_in">Math</span>.floor(count / <span class="number">10</span>);</span><br><span class="line">    last--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newAdd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    res.unshift(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802093916.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路：设置匹配规则，遍历的 s 的时候如果元素满足左括号就把规则中的右括号 push 进数组，如果元素是右括号，说明此时弹出的括号要和右括号匹配 否则返回 false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> rule = &#123;</span><br><span class="line">    <span class="string">&quot;(&quot;</span>: <span class="string">&quot;)&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[&quot;</span>: <span class="string">&quot;]&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&#123;&quot;</span>: <span class="string">&quot;&#125;&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> str <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str === <span class="string">&quot;(&quot;</span> || str === <span class="string">&quot;[&quot;</span> || str === <span class="string">&quot;&#123;&quot;</span>) &#123;</span><br><span class="line">      arr.push(rule[str]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr.pop() !== str) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !arr.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802101606.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(nums[i])) &#123;</span><br><span class="line">      <span class="keyword">let</span> less = map.get(nums[i]);</span><br><span class="line">      <span class="keyword">return</span> [less, i];</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(target - nums[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802102816.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>入门回溯，使用 used 记录已经使用过的元素，终止条件是 path 长度等于数组长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> used = <span class="keyword">new</span> <span class="built_in">Array</span>(nums.length).fill(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length === nums.length) &#123;</span><br><span class="line">      res.push([...path]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">      path.push(nums[i]);</span><br><span class="line">      used[i] = <span class="literal">true</span>;</span><br><span class="line">      dfs(path);</span><br><span class="line">      path.pop();</span><br><span class="line">      used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs([]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803191326.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>dfs 注意第一次进去的是 root 的 val</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span> (<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">n, sum</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n.left &amp;&amp; !n.right &amp;&amp; sum === targetSum) &#123;</span><br><span class="line">      res = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n.left) dfs(n.left, sum + n.left.val);</span><br><span class="line">    <span class="keyword">if</span> (n.right) dfs(n.right, sum + n.right.val);</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(root, root.val);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803192042.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>时刻牢记：层序遍历有两层循环，外层退出条件是队列为空，因为队列为空了，意味着已经走到最后一步结束了。内层循环是为了让孩子进队列并弹出队头元素，弹出有两个目的，一是清空当前队列，二是保留当前队头元素；让孩子进队列是为了下一次层序。</p><p>容易犯错的点：退出当前循环的条件是队列为空,且因为弹出会影响数组长度，所以要保存数组长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> queue = [root];</span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = queue.length;</span><br><span class="line">    <span class="keyword">const</span> temp = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> n = queue.shift();</span><br><span class="line">      temp.push(n.val);</span><br><span class="line">      <span class="keyword">if</span> (n.left) queue.push(n.left);</span><br><span class="line">      <span class="keyword">if</span> (n.right) queue.push(n.right);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(temp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803194353.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>斐波那契:思路，把每个问题分割成子问题，去逐步处理子问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fun = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = [];</span><br><span class="line">  fn[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  fn[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    fn[i] = fn[i - <span class="number">1</span>] + fn[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803194839.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路：比较每次的和和当前项的关系，大的替换。因为我们每次只需要保留两数之间的最大值，然后有个流程上面的最大值，用于比较每次的最大值，找到最大的最大值返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> max = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    sum = <span class="built_in">Math</span>.max(nums[i], sum + nums[i]);</span><br><span class="line">    max = <span class="built_in">Math</span>.max(sum, max);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803200529.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>三指针，注意满足条件就剪枝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  nums = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">let</span> mid = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> last = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mid &lt; last) &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = nums[i] + nums[mid] + nums[last];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        res.push([nums[i], nums[mid], nums[last]]);</span><br><span class="line">        mid++;</span><br><span class="line">        <span class="keyword">while</span> (nums[mid] === nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">          mid++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        mid++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803202441.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>反转链表的流程其实就是<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803202542.png" alt=""></p><p>稍微理解一下这个图就可以了。并且注意最后 cur 已经走完，但是 pre 构建完了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = (head)&#123;</span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">    [cur.next,pre,cur] = [pre,cur,cur.next]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220803202756.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>快指针每次都比慢指针多走一步，如果有环，必定会重合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> slow = head;</span><br><span class="line">  <span class="keyword">let</span> fast = head;</span><br><span class="line">  <span class="keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast.next) &#123;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    <span class="keyword">if</span> (slow === fast) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220804165959.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>基本思路是，使用后一次和前一次做差加初始的值进行判断，如果持续收益大于 0 说明本次是正收益，保留，否则置为 0.最后比较得到 max</p><p>注意 因为是比较前后，最后一位要省去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">prices</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    last = <span class="built_in">Math</span>.max(<span class="number">0</span>, last + prices[i + <span class="number">1</span>] - prices[i]);</span><br><span class="line">    max = <span class="built_in">Math</span>.max(max, last);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="215-数组中的第-K-个最大元素"><a href="#215-数组中的第-K-个最大元素" class="headerlink" title="215. 数组中的第 K 个最大元素"></a>215. 数组中的第 K 个最大元素</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220804170410.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">nums, k</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220804170654.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = s.length;</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">  <span class="keyword">let</span> res = s[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.charAt(i) !== s.charAt(j)) <span class="keyword">continue</span>;</span><br><span class="line">      dp[i][j] = j - i &lt;= <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; res.length) &#123;</span><br><span class="line">        res = s.slice(i, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a>912. 排序数组</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220804171859.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>手撕快速排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> left = [];</span><br><span class="line">  <span class="keyword">let</span> right = [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="129-根到叶子节点数字之和"><a href="#129-根到叶子节点数字之和" class="headerlink" title="129. 根到叶子节点数字之和"></a>129. 根到叶子节点数字之和</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220805231049.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code dfs</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">n, sum</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n.left &amp;&amp; !n.right) &#123;</span><br><span class="line">      res += +[...sum].join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n.left) &#123;</span><br><span class="line">      sum.push(n.left.val);</span><br><span class="line">      dfs(n.left, sum);</span><br><span class="line">      sum.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n.right) &#123;</span><br><span class="line">      sum.push(n.right.val);</span><br><span class="line">      dfs(n.right, sum);</span><br><span class="line">      sum.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(root, [root.val]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220807163006.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>思路：<br>dfs 判断是否处于二位平面，且是否为 1，满足条件沉没陆地，判断下个格子并 dfs</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">grid</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!grid) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> xLen = grid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">let</span> yLen = grid.length;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> d = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> inArea = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; yLen &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt;= xLen;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">i, j, grid</span>) =&gt;</span> &#123;</span><br><span class="line">    grid[i][j] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">      <span class="keyword">let</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">let</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">      inArea(x, y) &amp;&amp; grid[x][y] === <span class="string">&quot;1&quot;</span> &amp;&amp; dfs(x, y, grid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; yLen; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; xLen; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        dfs(i, j, grid);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h1><h1 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h1><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><h1 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220805225849.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="comment">// 技巧 变量都要带进递归</span></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">l, r, path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length === <span class="number">2</span> * n) &#123;</span><br><span class="line">      res.push([...path].join(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      path.push(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">      dfs(l - <span class="number">1</span>, r, path);</span><br><span class="line">      path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意是左括号的数量小于右括号才能让右括号进栈</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">      path.push(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">      dfs(l, r - <span class="number">1</span>, path);</span><br><span class="line">      path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(n, n, []);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220807164321.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>注意条件<code>!n 和 !n.right&amp;&amp;!n.left</code>的不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">n, depth</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!n.left &amp;&amp; !n.right) &#123;</span><br><span class="line">      max = <span class="built_in">Math</span>.max(depth, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n.left) dfs(n.left, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n.right) dfs(n.right, depth + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(root, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220807171332.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>分解问题再合并问题<br>求 1 就是求 0 的次数和求 1 的次数的最小值比较<br>求 2 其实就是求 1 的次数和求 2 的次数的最小值比较<br>因此推到出状态转移方程为：<br><code>dp[i] = Math.min(dp[i],dp[i-coin]+1)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">coins, amount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(amount + <span class="number">1</span>).fill(<span class="literal">Infinity</span>); <span class="comment">//考虑0</span></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">      <span class="keyword">if</span> (coin &gt; i) <span class="keyword">continue</span>; <span class="comment">//如果当前硬币值大于当前所求额度则不能组合 跳过</span></span><br><span class="line">      dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[amount] === <span class="literal">Infinity</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220808193614.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>走四个方向为一次 dfs，如果中间没有 length 就直接返回。</p><p>走右边相当于 i 为 0 的情况，就直接把整个数组开头 shift 然后解构过来</p><p>走下面相当于 i 大于 0 且小于数组长度的情况，就一直获取前面每个子数组里面 pop 的内容，(因为第一个被 shift 了 长度-1)</p><p>走左边相当于 i 为最后一个的时候，直接把数组最后的元素 pop 然后反转</p><p>注意这个过程中，如果只走了一圈 比如<br>左右下 xxx 左上 xxx 右的情况 出现了很多空子数组，但整个数组还是有长度的</p><p>就会 push 很多 undefined 进去，要阻止他，就得使用<code>if (arr[i] &amp;&amp; !arr[i].length) return; //防止只走一圈就结束的情况</code></p><p>接着我们要完成往上的操作，往上的操作相当于倒着读取数组，然后把子数组的最前面一项拿出来</p><p>注意这个过程也需要判断子数组是否为空</p><p>最后没结束就继续递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">matrix</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length; <span class="comment">//保存length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &amp;&amp; !arr[i].length) <span class="keyword">return</span>; <span class="comment">//防止只走一圈就结束的情况</span></span><br><span class="line">      <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">        res.push(...arr.shift());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i === len - <span class="number">1</span>) &#123;</span><br><span class="line">        res.push(...arr.pop().reverse());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.push(arr[i - <span class="number">1</span>].pop());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!arr[i].length) <span class="keyword">return</span>;</span><br><span class="line">      res.push(arr[i].shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span>;</span><br><span class="line">    dfs(arr);</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(matrix);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220807204102.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span>;</span><br><span class="line">    dfs(n.left);</span><br><span class="line">    res.push(n.val);</span><br><span class="line">    dfs(n.right);</span><br><span class="line">  &#125;;</span><br><span class="line">  dfs(root);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="146-LRU-缓存机制"><a href="#146-LRU-缓存机制" class="headerlink" title="146. LRU 缓存机制"></a>146. LRU 缓存机制</h1><h1 id="剑指-Offer-22-链表中倒数第-k-个节点"><a href="#剑指-Offer-22-链表中倒数第-k-个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第 k 个节点"></a>剑指 Offer 22. 链表中倒数第 k 个节点</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220808224105.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>注意使用 dummy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getKthFromEnd = <span class="function"><span class="keyword">function</span> (<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> slow = dummy;</span><br><span class="line">  <span class="keyword">let</span> fast = dummy;</span><br><span class="line">  <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (fast.next) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slow.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h1><h1 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220809185822.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a>695. 岛屿的最大面积</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220809190153.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>在求岛屿数量的基础上增加个 count 和 max 即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="function"><span class="keyword">function</span> (<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> xLen = grid[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> yLen = grid.length;</span><br><span class="line">  <span class="keyword">const</span> d = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">const</span> inArea = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; yLen &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; xLen;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">i, j, grid</span>) =&gt;</span> &#123;</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">      <span class="keyword">const</span> x = i + d[k][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">const</span> y = j + d[k][<span class="number">1</span>];</span><br><span class="line">      inArea(x, y) &amp;&amp; grid[x][y] &amp;&amp; dfs(x, y, grid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; yLen; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; xLen; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (grid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">        dfs(i, j, grid);</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, count);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="103-二叉树的锯齿型层序遍历"><a href="#103-二叉树的锯齿型层序遍历" class="headerlink" title="103. 二叉树的锯齿型层序遍历"></a>103. 二叉树的锯齿型层序遍历</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220809200416.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>code</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zigzagLevelOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">  <span class="keyword">const</span> q = [root];</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> isTran = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (q.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> temp = [];</span><br><span class="line">    <span class="keyword">const</span> len = q.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> n = q.shift();</span><br><span class="line">      temp.push(n.val);</span><br><span class="line">      <span class="keyword">if</span> (n.left) q.push(n.left);</span><br><span class="line">      <span class="keyword">if</span> (n.right) q.push(n.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isTran) &#123;</span><br><span class="line">      res.push(temp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.push(temp.reverse());</span><br><span class="line">    &#125;</span><br><span class="line">    isTran = !isTran;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h1><div class="tabs" id="test"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test-1">主要介绍</button></li><li class="tab"><button type="button" data-href="#test-2">基本语法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test-1"><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220809203702.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test-2"><p>因为是正整数数组，所以每次都是递增的<br>使用滑动窗口<br>当右指针移动扩大窗口的时候，判断是否满足 target，如果满足则右指针减左指针得到窗口长度和当前的最小长度比较。然后左指针移动，缩小窗口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">target, nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> l = (r = sum = <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">while</span> (r &lt; nums.length) &#123;</span><br><span class="line">    sum += nums[r++]; <span class="comment">//扩大窗口</span></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">      res = <span class="built_in">Math</span>.min(res, r - l); <span class="comment">//r-l代表满足条件的窗口长度</span></span><br><span class="line">      sum -= nums[l++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res === <span class="literal">Infinity</span> ? <span class="number">0</span> : res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="算法指南" scheme="https://zlinni.github.io/categories/%E7%AE%97%E6%B3%95%E6%8C%87%E5%8D%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试" scheme="https://zlinni.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化①打包器的资源处理</title>
    <link href="https://zlinni.github.io/posts/3551608196/"/>
    <id>https://zlinni.github.io/posts/3551608196/</id>
    <published>2022-07-30T08:30:58.000Z</published>
    <updated>2022-08-01T15:03:10.057Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>在前端工程化这块，打包肯定是大家初次入门的时候会接触到的玩意，最常见的一个例子就是第三方资源 CDN 外部引入。在网上各路教程中都说明他是减少了项目体积，实则不然，下面详细讲述前端打包的方案</p></div><h1 id="模块化方案"><a href="#模块化方案" class="headerlink" title="模块化方案"></a>模块化方案</h1><div class="note primary flat"><p>对于模块化，cjs，es，umd 模块你知道吗？</p></div><h2 id="cjs"><a href="#cjs" class="headerlink" title="cjs"></a>cjs</h2><p>首先是 cjs，全称 <code>Commonjs</code>，是 node 中的模块规范，通过 <code>require</code> 及 <code>export</code> 进行导入导出，进一步延申的化，<code>module.export</code>属于 <code>commonjs2</code>.</p><p>因为他属于 node 的模块，也就是意味着他只能在 node 环境中，也就是不能直接用在浏览器之上。如果你的前端项目需要用到以 cjs 规范写的模块，那么就会出问题(比如 cdn 加载)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="built_in">exports</span>.sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; sum &#125; = <span class="built_in">require</span>(<span class="string">&quot;./sum.js&quot;</span>);</span><br></pre></td></tr></table></figure><p>解决方法是 <code>webpack</code> 的 <code>enhanced-resolve</code>，webpack 是通过引入这个库来解析模块的，他相当于增强版的<code>require.resolve</code>。他会将 require 或者 import 语句中的资源，解析为引入文件的绝对路径，然后通过文件读取加载资源。具体参见这篇文章<a href="https://juejin.cn/post/7004267670832955423#heading-1">【webpack 系列】3. webpack 是如何解析模块的</a></p><p>关键字：<code>cjs</code>，<code>node</code>，<code>require</code> 和 <code>export</code></p><h2 id="esm"><a href="#esm" class="headerlink" title="esm"></a>esm</h2><p>全称<code>es module</code>。是 <code>tc39</code> 对于 <code>ESMAScript</code> 的模块化规范，因为他是规范，所以能用在 node 和浏览器环境下，使用<code>import/export</code>进行模块的导入导出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&quot;./sum&quot;</span>;</span><br></pre></td></tr></table></figure><p>esm 为静态导入，正因为如此，可以在编译的时期进行 tree shaking，减小 js 体积。(判断一个模块是否支持 tree shaking 就要看他发包内容有没有 es，而不是看源码是不是 esm 写的)<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220730171548.png" alt=""></p><p>如果需要动态导入，tc39 为动态加载模块定义了 API: import(module) 。可将以下代码粘贴到控制台执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ms = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&quot;https://cdn.skypack.dev/ms@latest&quot;</span>);</span><br><span class="line"></span><br><span class="line">ms.default(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>esm 是未来的趋势，目前一些 cdn 厂商和前端构建工具都致力于 cjs 模块像 esm 的转化，比如 <code>skypack</code>、 <code>snowpack</code>、<code>vite</code> 等。</p><p>目前浏览器和 node 均支持 esm</p><p>cjs 和 esm 的区别</p><ul><li>cjs 模块输出的是一个值的拷贝，esm 输出的是值的引用</li><li>cjs 是运行时加载，esm 是编译时加载。</li></ul><p>怎么理解这句话呢，实际上可以直接拿 cdn 的 esm 模块来使用，<a href="https://cdn.jsdelivr.net/npm/array-uniq/index.js">array-uniq</a>，就会发现我们并没有使用到他，但是他已经加载出来了。相应的 cjs 模块就不行。源于 nodejs 是 js 的一个解析引擎，是运行时的。<br><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220730165648.png" alt=""></p><h2 id="umd"><a href="#umd" class="headerlink" title="umd"></a>umd</h2><p>umd 是一种兼容 cjs 和 amd 的模块，既可以在 node/webpack 环境中被 require 使用，也可以在浏览器中直接用 cdn 以<code>script.src</code>引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    <span class="comment">// AMD</span></span><br><span class="line">    define([<span class="string">&quot;jquery&quot;</span>], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// CommonJS (如果有exports关键字就是cjs)</span></span><br><span class="line">    <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">&quot;jquery&quot;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 全局变量</span></span><br><span class="line">    root.returnExports = factory(root.jQuery);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看出 umd 的本质就是一个 IIFE。</p><p>这三种模块方案大致如此，部分 npm package 也会被同时打包出 commonjs/esm/umd 三种模块，以供不同的需求的业务使用。比如 antd</p><h1 id="AST-抽象语法树"><a href="#AST-抽象语法树" class="headerlink" title="AST 抽象语法树"></a>AST 抽象语法树</h1><p>AST 全称 Abstract Syntax Tree，抽象语法树，涉及到工程化的诸多环节的应用，比如：</p><ol><li>如何将 ts 转换为 js</li><li>如何将 sass/less 转化为 css</li><li>如何将 es6 转化为 es5(babel)</li><li>如何将 js 代码格式化 prettier/eslint</li><li>如何识别 jsx</li><li>graphQL，MDX，Vue SFC 等等</li></ol><p>这种语言转换的过程实际就是对其 AST，核心步骤是</p><ol><li>code -&gt; ast(parse)</li><li>ast -&gt; ast(transform)</li><li>ast -&gt; code(generate)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AST</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Program&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;end&quot;</span>: <span class="number">11</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclaration&quot;</span>,</span><br><span class="line">      <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">&quot;end&quot;</span>: <span class="number">11</span>,</span><br><span class="line">      <span class="string">&quot;declarations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclarator&quot;</span>,</span><br><span class="line">          <span class="string">&quot;start&quot;</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="string">&quot;end&quot;</span>: <span class="number">11</span>,</span><br><span class="line">          <span class="string">&quot;id&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">            <span class="string">&quot;start&quot;</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="string">&quot;end&quot;</span>: <span class="number">7</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;init&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">            <span class="string">&quot;start&quot;</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">&quot;end&quot;</span>: <span class="number">11</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="string">&quot;raw&quot;</span>: <span class="string">&quot;4&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;const&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 vue 的环节中也讲到了如何解析模板语法为 ast，就是生成类似的对象。对于不同语言有不同的解析器，js 的解析器和 css 的解析器就完全不一样。相同的语言也有不同的解析器，比如 babel 和 espree</p><h2 id="AST-的生成"><a href="#AST-的生成" class="headerlink" title="AST 的生成"></a>AST 的生成</h2><p>这一步称之为解析 parse，这个步骤有两个阶段，一是词法分析，二是语法分析。</p><p>词法分析是将代码转化为 token 数组，我们常见的 mdeditor 和 eslint，hightlight,模板语法等就是利用了这个步骤去判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Token</span></span><br><span class="line">[</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">start</span>: <span class="number">0</span>, <span class="attr">end</span>: <span class="number">1</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">&quot;=&quot;</span>, <span class="attr">start</span>: <span class="number">2</span>, <span class="attr">end</span>: <span class="number">3</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: &#123; ... &#125;, <span class="attr">value</span>: <span class="string">&quot;3&quot;</span>, <span class="attr">start</span>: <span class="number">4</span>, <span class="attr">end</span>: <span class="number">5</span>, <span class="attr">loc</span>: &#123; ... &#125; &#125;,</span><br><span class="line">  ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>语法分析是将 token 流转化为结构化的 ast，方便操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Program&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;end&quot;</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;ExpressionStatement&quot;</span>,</span><br><span class="line">      <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">&quot;end&quot;</span>: <span class="number">5</span>,</span><br><span class="line">      <span class="string">&quot;expression&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;AssignmentExpression&quot;</span>,</span><br><span class="line">        <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;end&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&quot;operator&quot;</span>: <span class="string">&quot;=&quot;</span>,</span><br><span class="line">        <span class="string">&quot;left&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">          <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="string">&quot;end&quot;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;right&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">          <span class="string">&quot;start&quot;</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="string">&quot;end&quot;</span>: <span class="number">5</span>,</span><br><span class="line">          <span class="string">&quot;value&quot;</span>: <span class="number">3</span>,</span><br><span class="line">          <span class="string">&quot;raw&quot;</span>: <span class="string">&quot;3&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>可通过自己写一个解析器，将语言 DSL 解析为 AST 进行练手，以下两个示例是不错的选择</p><ol><li>解析简单的 HTML 为 AST</li><li>解析 Marktodwn List 为 AST</li></ol><p>或可参考一个最简编译器的实现 the super tiny compiler</p><h1 id="原理与运行时分析"><a href="#原理与运行时分析" class="headerlink" title="原理与运行时分析"></a>原理与运行时分析</h1><h2 id="webpack-runtime"><a href="#webpack-runtime" class="headerlink" title="webpack runtime"></a>webpack runtime</h2><p>webpack 的 runtime，也就是 webpack 最后生成的代码，做了以下三件事：</p><ol><li><code>_webpack_modules_</code>:维护一个所有模块的数组。将入口模块解析为 ast，根据 ast 深度优先搜索出所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数<code>(module, module.exports, __webpack_require__)</code>对模块进行包裹而成。</li><li><code>__webpack_require__(moduleId)</code>手动实现加载一个模块。对已经加载过的模块进行缓存，对未加载的模块，执行 id 定位到<code>__webpack_modules__</code>中的包裹函数，执行并返回 module.exports 并缓存</li><li><code>__webpack_require__(0)</code>: 运行第一个模块，即运行入口模块</li></ol><p>另外，当涉及到多个 chunk 的打包方式中，比如 code spliting，webpack 会有 jsonp 加载 chunk 的运行时代码</p><p>以下是 <code>webpack runtime</code> 的最简代码，配置示例可见 <code>node-examples</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> __webpack_modules__ = [</span><br><span class="line">  ,</span><br><span class="line">  <span class="comment">/* 0 */</span> <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="comment">/***/</span> <span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="function">(<span class="params">...args</span>) =&gt;</span> args.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// The module cache</span></span><br><span class="line"><span class="comment">/******/</span> <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/******/</span> <span class="comment">// The require function</span></span><br><span class="line"><span class="comment">/******/</span> <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Check if module is in cache</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">var</span> cachedModule = __webpack_module_cache__[moduleId];</span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">if</span> (cachedModule !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="comment">/******/</span> <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">var</span> <span class="built_in">module</span> = (__webpack_module_cache__[moduleId] = &#123;</span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">// no module.id needed</span></span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">// no module.loaded needed</span></span><br><span class="line">    <span class="comment">/******/</span> <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Execute the module function</span></span><br><span class="line">  <span class="comment">/******/</span> __webpack_modules__[moduleId](</span><br><span class="line">    <span class="built_in">module</span>,</span><br><span class="line">    <span class="built_in">module</span>.exports,</span><br><span class="line">    __webpack_require__</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">// Return the exports of the module</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/******/</span></span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="keyword">var</span> __webpack_exports__ = &#123;&#125;;</span><br><span class="line"><span class="comment">// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.</span></span><br><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sum = __webpack_require__(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  sum(<span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>对 webpack runtime 做进一步的精简，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> __webpack_modules__ = [<span class="function">()=&gt;</span>&#123;&#125;];</span><br><span class="line"><span class="keyword">const</span> __webpack_require__ = <span class="function">(<span class="params">id</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    <span class="attr">exports</span>:&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> m = __webpack_modules__[id](<span class="built_in">module</span>,_webpack_require__)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line">__webpack_require__(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h2><p>在 rollup 中，并不会将所有模块置于 modules 中使用 Module Wrapper 进行维护，他仅仅将所有模块铺平展开。</p><p>举例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">&quot;./name&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//name.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包后</span></span><br><span class="line"><span class="comment">// output.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure><p>对于他的这种方案要是遇到变量冲突如何解决，如下：直接重新命名</p><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220801134201.png" alt=""></p><h1 id="运行时-chunk-加载分析"><a href="#运行时-chunk-加载分析" class="headerlink" title="运行时 chunk 加载分析"></a>运行时 chunk 加载分析</h1><p>问：webpack 的 code spliting 是如何动态加载 chunk 的?</p><p>一个 webpack 运行时，包括最重要的两个数据结构：</p><ol><li><code>__webpack_modules__</code>维护一个所有模块的数组。将入口模块解析为 ast，根据 ast 深度优先搜索所有的模块，并构建出这个模块数组。每个模块都由一个包裹函数<code>(module, module.exports, __webpack_require__)</code>对模块进行包裹而成。</li><li><code>__webpack_require__(moduleId)</code>手动实现加载一个模块。对已经加载过的模块进行缓存，对未加载的模块，根据 id 定位到<code>__webpack_modules__</code>中的包裹函数，执行并返回<code>module.exports</code>并缓存。</li></ol><h2 id="code-spliting"><a href="#code-spliting" class="headerlink" title="code spliting"></a>code spliting</h2><p>在 webpack 中通过 import 可以实现 code spliting。假设有以下文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./sum&quot;</span>).then(<span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">  m.default(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum;</span><br></pre></td></tr></table></figure><p>使用下面的 webpack 配置进行打包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">entry</span>:<span class="string">&#x27;./index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">mode</span>:<span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>:&#123;</span><br><span class="line">    <span class="attr">filename</span>:<span class="string">&#x27;[name].[contenthash].js&#x27;</span>,</span><br><span class="line">    <span class="attr">chunkFilename</span>:<span class="string">&#x27;chunk.[name].[id].[contenthash].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:path.resolve(_dirname,<span class="string">&#x27;dist/deterministic&#x27;</span>),</span><br><span class="line">    <span class="attr">clean</span>:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">optimization</span>:&#123;</span><br><span class="line">    <span class="attr">moduleIds</span>:<span class="string">&#x27;deterministic&#x27;</span>,</span><br><span class="line">    <span class="attr">chunkIds</span>:<span class="string">&#x27;deterministic&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行时解析"><a href="#运行时解析" class="headerlink" title="运行时解析"></a>运行时解析</h2><p>观测打包后的文件<code>dist/deterministic/main.xxxxxx.js</code>,可以发现：使用<code>import()</code>加载数据时，以上代码将被编译为以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__</span><br><span class="line">  .e(<span class="comment">/* import() | sum */</span> <span class="number">644</span>)</span><br><span class="line">  .then(__webpack_require__.bind(__webpack_require__, <span class="number">709</span>))</span><br><span class="line">  .then(<span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</span><br><span class="line">    m.default(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>此时 644 为 chunkId，观测<code>chunk.sum.xxx.js</code>文件，以下为 sum 函数所构建的 chunk</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">(self[<span class="string">&quot;webpackChunk&quot;</span>] = self[<span class="string">&quot;webpackChunk&quot;</span>] || []).push([</span><br><span class="line">  [<span class="number">644</span>],</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/***/</span> <span class="number">709</span>: <span class="comment">/***/</span> <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">      __unused_webpack_module,</span></span></span><br><span class="line"><span class="params"><span class="function">      __webpack_exports__,</span></span></span><br><span class="line"><span class="params"><span class="function">      __webpack_require__</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) =&gt;</span> &#123;</span><br><span class="line">      __webpack_require__.r(__webpack_exports__);</span><br><span class="line">      <span class="comment">/* harmony export */</span> __webpack_require__.d(__webpack_exports__, &#123;</span><br><span class="line">        <span class="comment">/* harmony export */</span> <span class="keyword">default</span>: <span class="function">() =&gt;</span> __WEBPACK_DEFAULT_EXPORT__,</span><br><span class="line">        <span class="comment">/* harmony export */</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* harmony default export */</span> <span class="keyword">const</span> __WEBPACK_DEFAULT_EXPORT__ = sum;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/***/</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>以下两个数据结构是加载 chunk 的关键：</p><ol><li><code>__webpack_require__.e</code>：加载 chunk。该函数使用<code>document.createElement(&#39;script&#39;)</code>异步加载 chunk 并封装为 promise。</li><li><code>self[&quot;webpackChunk&quot;].push</code>:JSONP callback，收集 modules 至<code>__webpack_modules__</code>并将<code>__webpack_require__.e</code>的 promise 进行 resolve</li></ol><p>实际上在 webpack 中可以配置<code>output.chunkLoading</code>来选择加载 chunk 的方式，比如选择通过<code>import()</code>的方式来加载。（由于在生产环境中要考虑 import 的兼容性，目前 JSONP 的方案比较多）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;main.[contenthash].js&#x27;</span>,</span><br><span class="line">    <span class="attr">chunkFilename</span>: <span class="string">&#x27;[name].chunk.[chunkhash].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist/import&#x27;</span>),</span><br><span class="line">    <span class="attr">clean</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 默认为 `jsonp`</span></span><br><span class="line">    <span class="attr">chunkLoading</span>: <span class="string">&#x27;import&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="打包器-webpack-rollup-如何加载-json，image-等非-js-资源"><a href="#打包器-webpack-rollup-如何加载-json，image-等非-js-资源" class="headerlink" title="打包器(webpack/rollup)如何加载 json，image 等非 js 资源"></a>打包器(webpack/rollup)如何加载 json，image 等非 js 资源</h1><p>我们知道在 webpack 中一切都是模块，所以加载 json 等非 js 资源的时候，就需要模块加载器，也就是俗称的 loader。将他们转化为模块。</p><h2 id="加载-json"><a href="#加载-json" class="headerlink" title="加载 json"></a>加载 json</h2><p>以 json 为例子</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user.json 中内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">10086</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jojo&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在现代前端中，我们把他视为 module 时，使用 import 引入资源。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> user <span class="keyword">from</span> <span class="string">&quot;./user.json&quot;</span>;</span><br></pre></td></tr></table></figure><p>而我们的打包器，如 webpack 与 rollup，将通过以下的方式来加载 json 资源</p><p>这样将被视为普通的 js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际上会被编译为以下内容</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">10086</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;jojo&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 webpack 中通过 loader 处理此类资源，示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> json = <span class="keyword">typeof</span> source === <span class="string">&quot;string&quot;</span> ? source : <span class="built_in">JSON</span>.stringfy(source);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`module.exports = <span class="subst">$&#123;json&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><p>那图片是如何处理的呢？</p><p>更简单，他将替换成自身的路径。示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">`$PUBLIC_URL/assets/image/main.png`</span>;</span><br></pre></td></tr></table></figure><p>而我们在<code>import image</code>的时候，其实是图片自身的路径，将他置于<code>src</code>属性即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mainImage <span class="keyword">from</span> <span class="string">&#x27;main.jpg&#x27;</span>;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;mainImage&#125;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="加载-css"><a href="#加载-css" class="headerlink" title="加载 css"></a>加载 css</h2><p>在 webpack 中处理 css 比较费劲。需要借用两个 loader 来做这件事。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>css-loader</code>处理 css 中 <code>url</code> 与<code>@import</code>,并将其视为模块引入，此处是通过 postcss 来解析处理。postcss 对于工程化中 css 的处理可见一斑。</li><li><code>style-loader</code>将样式注入到 DOM 中。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(./basic.css);</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bg</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">./shanyue.png</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>cssloader 的原理就是 postcss，借用<code>postcss-value-parser</code>解析 css 为 ast。并将 css 中的<code>url()</code>与<code>@import</code>解析为模块。</p><p>styleloader 将 css 注入到 dom，原理为使用 DOM API 手动创建 style 标签，并将 css 内容注入到 style 中。</p><p>源码实现中借用了许多运行时代码。而最简单的实现仅需几行代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">  function injectCSS(css)&#123;</span></span><br><span class="line"><span class="string">    const style = document.createElement(&#x27;style&#x27;);</span></span><br><span class="line"><span class="string">    style.appendChild(document.createTextNode(css))</span></span><br><span class="line"><span class="string">    document.head.appendChild(style)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  injectCSS(\`<span class="subst">$&#123;source&#125;</span>`</span>\)</span><br><span class="line">  <span class="string">`</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>使用 DOM API 加载 CSS 资源，由于 CSS 需要在 JS 资源加载完后通过 DOM API 进行控制加载，容易出现页面抖动，在线上低效且性能低下。且对于 SSR 极其不友好。</p><p>由于性能需要，在线上通常单独加载 css，这就要求打包器能够将 css 打包，此时需要借助于<code>mini-css-extract-plugin</code>将 css 单独抽离出来。</p><h2 id="注入-js-到-html"><a href="#注入-js-到-html" class="headerlink" title="注入 js 到 html"></a>注入 js 到 html</h2><p>如果最终打包的 mainjs 既没有做 code spliting，也没有做 hash 化路径。大可以通过在<code>index.html</code>中手动控制 js 资源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">defer</span> /&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure><p>不过往往事与愿违：</p><ol><li>mainjs 即我们最后生成的文件带有 hash 值。</li><li>由于长期缓存的需要，入口文件不仅只有一个，还包括第三方模块打包而成的 vendorjs，同样带有 hash</li><li>脚本地址同时需要注入 publicPath，而在生产环境与测试环境的 publicPath 并不一致。</li></ol><p>因此需要一个插件做这件事情，在 webpack 中叫<code>html-webpack-plugin</code>在 rollup 的世界里叫<code>@rollup/plugin-html</code></p><p>而注入的原理为当打包器已生成 <code>entryPoint</code> 文件资源后，获得其文件名以及 <code>publicPath</code>，并将其注入到 <code>html</code> 中</p><p>以 <code>html-webpack-plugin</code> 为例，它在 <code>compilation</code> 处理资源的 <code>processAssets</code> 获得其打包生成的资源。伪代码如下，可在 <code>mini-node:html-webpack-plugin (opens new window)</code>获得源码并运行示例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HtmlWebpackPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options || &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> webpack = compiler.webpack;</span><br><span class="line"></span><br><span class="line">    compiler.hooks.thisCompilation.tap(<span class="string">&quot;HtmlWebpackPlugin&quot;</span>, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// compilation 是 webpack 中最重要的对象，文档见 [compilation-object](https://webpack.js.org/api/compilation-object/#compilation-object-methods)</span></span><br><span class="line"></span><br><span class="line">      compilation.hooks.processAssets.tapAsync(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&quot;HtmlWebpackPlugin&quot;</span>,</span><br><span class="line"></span><br><span class="line">          <span class="comment">// processAssets 处理资源的时机，此阶段为资源已优化后，更多阶段见文档</span></span><br><span class="line">          <span class="comment">// https://webpack.js.org/api/compilation-hooks/#list-of-asset-processing-stages</span></span><br><span class="line">          <span class="attr">stage</span>: webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">compilationAssets, callback</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// compilationAssets 将得到所有生成的资源，如各个 chunk.js、各个 image、css</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 获取 webpac.output.publicPath 选项，(PS: publicPath 选项有可能是通过函数设置)</span></span><br><span class="line">          <span class="keyword">const</span> publicPath = getPublicPath(compilation);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 本示例仅仅考虑单个 entryPoint 的情况</span></span><br><span class="line">          <span class="comment">// compilation.entrypoints 可获取入口文件信息</span></span><br><span class="line">          <span class="keyword">const</span> entryNames = <span class="built_in">Array</span>.from(compilation.entrypoints.keys());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// entryPoint.getFiles() 将获取到该入口的所有资源，并能够保证加载顺序！！！如 runtime-chunk -&gt; main-chunk</span></span><br><span class="line">          <span class="keyword">const</span> assets = entryNames</span><br><span class="line">            .map(<span class="function">(<span class="params">entryName</span>) =&gt;</span></span><br><span class="line">              compilation.entrypoints.get(entryName).getFiles()</span><br><span class="line">            )</span><br><span class="line">            .flat();</span><br><span class="line">          <span class="keyword">const</span> scripts = assets.map(<span class="function">(<span class="params">src</span>) =&gt;</span> publicPath + src);</span><br><span class="line">          <span class="keyword">const</span> content = html(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="built_in">this</span>.options.title || <span class="string">&quot;Demo&quot;</span>,</span><br><span class="line">            scripts,</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// emitAsset 用以生成资源文件，也是最重要的一步</span></span><br><span class="line">          compilation.emitAsset(</span><br><span class="line">            <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> webpack.sources.RawSource(content)</span><br><span class="line">          );</span><br><span class="line">          callback();</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h1><p>全称Hot Module Replacement，热模块替换，无需刷新在内存环境中即可替换掉旧模块。与live Reload相对应</p><p>在webpack的运行时中，<code>__webpack_modules__</code>用于维护所有模块。</p><p>而热模块替换的原理，即是通过chunk的方式加载最新的modules，找到<code>_webpack_modules_</code>里面对应的模块逐一替换。并删除其上下缓存</p><p>其精简数据结构如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack 运行时代码</span></span><br><span class="line"><span class="keyword">const</span> __webpack_modules = [</span><br><span class="line">  <span class="function">(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>) =&gt;</span> &#123;</span><br><span class="line">    __webpack_require__(<span class="number">0</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是一号模块&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// HMR Chunk 代码</span></span><br><span class="line"><span class="comment">// JSONP 异步加载的所需要更新的 modules，并在 __webpack_modules__ 中进行替换</span></span><br><span class="line">self[<span class="string">&quot;webpackHotUpdate&quot;</span>](<span class="number">0</span>, &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是最新的一号模块&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>以下为更具体更完整的流程，每一步都涉及很多，有兴趣的可以阅读webpack-dev-server以及开发环境webpack运行时的源码</p><ol><li>webpack-dev-server将打包输出bundle使用内存型文件系统控制，而非真实的文件系统。此时使用的是memfs模拟node的fs API</li><li>每当文件发生变更的时候，webpack会重新编译，webpack-dev-server将会监控到此时文件变更事件。并找到对应的module。此时使用的是chokidar的文件监控模块</li><li>webpack-dev-server将会把变更模块通知到浏览器端，此时使用websocket与浏览器进行交流。此时使用的是ws</li><li>浏览器根据websocket接收到hash，并通过hash以jsonp的方式请求更新模块的chunk</li><li>浏览器加载chunk，并使用新的模块对就模块进行热替换。并删除其上下缓存</li></ol><h1 id="构建性能优化"><a href="#构建性能优化" class="headerlink" title="构建性能优化"></a>构建性能优化</h1><p>首先我们要知道怎么评估性能：使用<a href="https://github.com/stephencookdev/speed-measure-webpack-plugin">speed-measure-webpack-plugin</a>可以评估每个loader/plugin的执行耗时。</p><h2 id="更快的loader：swc"><a href="#更快的loader：swc" class="headerlink" title="更快的loader：swc"></a>更快的loader：swc</h2><p>在webpack中耗时最久的是负责ast转换的loader。</p><p>当loader进行编译的时候，ast操作均为cpu密集型任务，使用js性能低下，此时可以采用高性能语言rust编写的swc</p><p>比如js转化由babel转化为更快的swc</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&quot;swc-loader&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="持久化缓存cache"><a href="#持久化缓存cache" class="headerlink" title="持久化缓存cache"></a>持久化缓存cache</h2><p>webpack内置了关于缓存的插件，可以通过cache字段开启。</p><p>他将module，chunk等信息序列化到磁盘中，二次构建避免重复编译计算，编译速度得到很大的提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">cache</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;filesystem&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如对一个js文件配置了eslint，ts，babel等loader。可能执行五次编译。被五次解析为ast。</p><ol><li>acorn：用于依赖分析，解析为acorn的ast</li><li>eslint-parser： 用以lint，解析为espree的ast</li><li>ts：用以ts…</li><li>babel: 转化es6+</li><li>terser：压缩混淆。解析为acorn的ast</li></ol><p>当开启了持久化缓存，最耗时的ast解析将能够从磁盘的缓存中获取，再次编译时无需进行解析ast</p><p>得益于持久化缓存。二次编译甚至可得到与unbundle的vite相近的开发体验。</p><h2 id="多线程-thread-loader"><a href="#多线程-thread-loader" class="headerlink" title="多线程 thread-loader"></a>多线程 thread-loader</h2><p><code>thread-loader</code>为官方推荐的开启多线程的loader，可以对babel解析ast时开启多线程处理，提升编译的性能。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;thread-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">workers</span>: <span class="number">8</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在webpack4中使用的是happypack plugin。but他已经很久不维护了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/打包器的资源处理.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Webpack系列" scheme="https://zlinni.github.io/categories/Webpack%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="https://zlinni.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Webpack" scheme="https://zlinni.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript_Challenges</title>
    <link href="https://zlinni.github.io/posts/4172318439/"/>
    <id>https://zlinni.github.io/posts/4172318439/</id>
    <published>2022-07-24T14:19:08.000Z</published>
    <updated>2025-02-26T08:55:40.412Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><div class="note primary flat"><p>开始提前批直通车啦~~ 本篇带来 ts 超集的各种挑战加个人解说。源码地址：<a href="https://github.com/type-challenges/type-challenges/">传送门</a></p></div><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220724223740.png" alt=""></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloWorld = <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure><h1 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220724223909.png" alt=""></p><p>code</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyPick&lt;T, K&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyPick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解释：pick 就是获取第一个参数的类型的其中几个，写法是<code>Pick&lt;target,&#39;属性1&#39;|&#39;属性2&#39;&gt;</code>，所以要实现他，就是说第二个属性要在 T 中，extends keyof 保证 K 的所有的类型在 T 中，in 保证 P 所有的类型在 K 中。</p><p>那么这里会有一个疑问。in 和 keyof 的区别</p><p>首先 keyof 是取 interface 的联合类型，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInfo &#123;</span><br><span class="line">  <span class="attr">userName</span>: <span class="string">&quot;jojo&quot;</span>;</span><br><span class="line">  psw: <span class="string">&quot;123&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> value = keyof UserInfo;</span><br><span class="line"><span class="comment">// value= &#x27;userName&#x27;|&#x27;psw&#x27;</span></span><br></pre></td></tr></table></figure><p>in 是取联合类型，主要用于数组和对象的构建。<br>切记不要用于 interface 否则会报错，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> name = <span class="string">&quot;firstName&quot;</span> | <span class="string">&quot;lastName&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> JOJOName = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> name]: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//JOJOName = &#123;firstName:string,lastName:string&#125;</span></span><br></pre></td></tr></table></figure><p>用于实际开发，举例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">obj: <span class="built_in">Object</span>, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&quot;jojo&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> value = getValue(obj1, <span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样写就丧失了 ts 的优势</p><ol><li>无法确定返回值的类型，</li><li>无法对 key 进行约束</li></ol><p>所以我们要这样写</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Object</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&quot;jojo&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> value = getValue(obj1, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 如果第二个参数不是obj1中的参数就会报错</span></span><br></pre></td></tr></table></figure><h1 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725095917.png" alt=""></p><p>解释：需要将 T 中的参数变为只读</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReadonly&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Tuple-to-Object-元组转换为对象"><a href="#Tuple-to-Object-元组转换为对象" class="headerlink" title="Tuple to Object 元组转换为对象"></a>Tuple to Object 元组转换为对象</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725100347.png" alt=""></p><p>解释：需要取出元组的值，并且构造成对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToObject&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> T[<span class="built_in">number</span>]]: P;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意<code>T[number]</code>是可以取出元组中的值,所以不用 keyof 了</p><h1 id="第一个元素"><a href="#第一个元素" class="headerlink" title="第一个元素"></a>第一个元素</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725103040.png" alt=""></p><p>解释：取出 T 的第一个元素 非空判断</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> First&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> <span class="built_in">never</span>[] ? <span class="built_in">never</span> : T[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h1 id="获取元组长度"><a href="#获取元组长度" class="headerlink" title="获取元组长度"></a>获取元组长度</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725103445.png" alt=""></p><p>解释：如果元组存在 length 属性则返回 length 值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Length&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: infer L &#125;</span><br><span class="line">  ? L</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>注意输入的类型是数组才行</p><h1 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725104229.png" alt=""></p><p>解释：排除 T 中带有 U 的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyExclude&lt;T,U&gt; = T <span class="keyword">extends</span> U:<span class="built_in">never</span>:T</span><br></pre></td></tr></table></figure><p>简述 T 的类型在 U 里面就排除</p><h1 id="Awaited"><a href="#Awaited" class="headerlink" title="Awaited"></a>Awaited</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725123703.png" alt=""></p><p>解释：实现该方法返回 promise 对象类型，要点是判断其中类型是否为 promise 在判断 promise 内的类型是否还是 promise 类型(递归)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyAwaited&lt;T <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;unknown&gt;&gt; = T <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;infer U&gt;</span><br><span class="line">  ? U <span class="keyword">extends</span> <span class="built_in">Promise</span>&lt;unknown&gt;</span><br><span class="line">    ? MyAwaited&lt;U&gt;</span><br><span class="line">    : U</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h1 id="If"><a href="#If" class="headerlink" title="If"></a>If</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725124910.png" alt=""></p><p>解释：C 是 true 就返回 T 的类型，是 false 就返回 F 的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> If&lt;C <span class="keyword">extends</span> <span class="built_in">Boolean</span>, T, F&gt; = C <span class="keyword">extends</span> <span class="literal">true</span> ? T : F;</span><br></pre></td></tr></table></figure><h1 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220725125530.png" alt=""></p><p>解释：实现 js 的 concat 效果，合并两个类型数组。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Concat&lt;T <span class="keyword">extends</span> unknown[], U <span class="keyword">extends</span> unknown[]&gt; = [...T, ...U];</span><br></pre></td></tr></table></figure><p>使用解构即可。</p><h1 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726145707.png" alt=""></p><p>解释：后一个类型如果包含在前面的类型中就返回 true 否则返回 false</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Includes&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[], U&gt; = T <span class="keyword">extends</span> [infer F, ...infer R]</span><br><span class="line">  ? Equal&lt;F, U&gt; <span class="keyword">extends</span> <span class="literal">true</span></span><br><span class="line">    ? <span class="literal">true</span></span><br><span class="line">    : Includes&lt;R, U&gt;</span><br><span class="line">  : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h1 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726151820.png" alt=""></p><p>解释：实现 js 的 push</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Push&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; = [...T, U];</span><br></pre></td></tr></table></figure><h1 id="Unshift"><a href="#Unshift" class="headerlink" title="Unshift"></a>Unshift</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726152550.png" alt=""></p><p>解释：实现 js 的 unshift</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Unshift&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; = [U, ...T];</span><br></pre></td></tr></table></figure><h1 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726152713.png" alt=""></p><p>解释：获取函数参数类型以数组输出</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyParameters&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: infer K</span><br><span class="line">) =&gt; <span class="built_in">any</span></span><br><span class="line">  ? K</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>注意的点在于其实<code>...args</code>的类型是<code>any[]</code>也就是以为着结果以数组输出的使用也可以利用上，直接使用 infer 去推断他的具体类型。</p><h1 id="获取函数返回类型"><a href="#获取函数返回类型" class="headerlink" title="获取函数返回类型"></a>获取函数返回类型</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726153737.png" alt=""></p><p>解释：获取函数的返回类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; infer K ? K : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>和上一题类似</p><h1 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a>Omit</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726154358.png" alt=""></p><p>解释：Pick 和 Exclude 的结合</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyOmit&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> P <span class="keyword">extends</span> K ? <span class="built_in">never</span> : P]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">type</span> MyOmit&lt;T, K <span class="keyword">extends</span> keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure><h1 id="Readonly2"><a href="#Readonly2" class="headerlink" title="Readonly2"></a>Readonly2</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726213353.png" alt=""></p><p>解释：如果不传 K 则默认为 readonly 否则就按 K 的内容对 T 进行只读的限制。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyReadonly2&lt;T, K <span class="keyword">extends</span> keyof T = keyof T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125; &amp; &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> P <span class="keyword">extends</span> K ? <span class="built_in">never</span> : P]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意的点首先是默认赋值，因为他不存在其实就是相当于用了全部的 T 的键，然后还有一点就是，他是 readonly 和 omit 的结合。在 K 中的所有值都是 readonly，不在 k 中的所有值都是 omit</p><h1 id="Deep-Readonly"><a href="#Deep-Readonly" class="headerlink" title="Deep Readonly"></a>Deep Readonly</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220726215552.png" alt=""></p><p>解释：使用深度只读将对象的每个属性包括对象本身变成只读</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepReadonly&lt;T&gt; = keyof T <span class="keyword">extends</span> <span class="built_in">never</span></span><br><span class="line">  ? T</span><br><span class="line">  : &#123; <span class="keyword">readonly</span> [k <span class="keyword">in</span> keyof T]: DeepReadonly&lt;T[k]&gt; &#125;;</span><br></pre></td></tr></table></figure><p>注意其实递归设置 readonly 是比较简单的，但是细节在于递归的设置，此处如果不是对象就返回初始类型</p><h1 id="元组转集合"><a href="#元组转集合" class="headerlink" title="元组转集合"></a>元组转集合</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220728110948.png" alt=""></p><p>解释：把元组转为集合</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TupleToUnion&lt;T&gt; = T <span class="keyword">extends</span> (infer U)[] ? U : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>关键在于通过 infer 推断集合的类型，以及取出元组的类型</p><h1 id="可串联构造器"><a href="#可串联构造器" class="headerlink" title="可串联构造器"></a>可串联构造器</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220728112156.png" alt=""></p><h1 id="最后一个元素"><a href="#最后一个元素" class="headerlink" title="最后一个元素"></a>最后一个元素</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220728155341.png" alt=""></p><p>解释:取出数组最后一个元素</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Last&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [...any, infer U] ? U : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h1 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220728155753.png" alt=""></p><p>解释:实现 pop</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pop&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [...infer Head, infer R]</span><br><span class="line">  ? [...Head]</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220728160431.png" alt=""></p><p>解释:实现 PromiseAll 获取数组值的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AwaitedAll&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> []</span><br><span class="line">  ? []</span><br><span class="line">  : T <span class="keyword">extends</span> [infer F, ...infer R]</span><br><span class="line">  ? [Awaited&lt;F&gt;, ...AwaitedAll&lt;R&gt;]</span><br><span class="line">  : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">PromiseAll</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">any</span>[]&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  value: <span class="keyword">readonly</span> [...T]</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Promise</span>&lt;<span class="title">AwaitedAll</span>&lt;<span class="title">T</span>&gt;&gt;</span>;</span><br></pre></td></tr></table></figure><ul><li>结合 awaited 的学习知识获取 Promise 的类型</li><li>结合类型解构和递归处理 Promise 的情况</li><li>注意空数组的情况</li><li>因为 promise 的结果是不能改变的，所以要加 readonly</li><li>解构 T 类型传入自定义的 AwaitedAll</li></ul><h1 id="Type-Lookup"><a href="#Type-Lookup" class="headerlink" title="Type Lookup"></a>Type Lookup</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220729163101.png" alt=""></p><p>解释：从 U 中获取 type 为 T 的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LookUp&lt;U, T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = U <span class="keyword">extends</span> &#123; <span class="attr">type</span>: T &#125; ? U : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h1 id="Trim-Left"><a href="#Trim-Left" class="headerlink" title="Trim Left"></a>Trim Left</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220729172654.png" alt=""></p><p>解释:删除字符串左边的空格</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Space = <span class="string">&quot; &quot;</span> | <span class="string">&quot;\n&quot;</span> | <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> TrimLeft&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? TrimLeft&lt;R&gt;</span><br><span class="line">  : S;</span><br></pre></td></tr></table></figure><p>技巧:结合模板字符串操作递归删除</p><h1 id="Trim"><a href="#Trim" class="headerlink" title="Trim"></a>Trim</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802164041.png" alt=""></p><p>解释:实现 trim 删除字符串两端的所有空格</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Space = <span class="string">&quot; &quot;</span> | <span class="string">&quot;\n&quot;</span> | <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> Trim&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? Trim&lt;R&gt;</span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer K&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span></span><br><span class="line">  ? Trim&lt;K&gt;</span><br><span class="line">  : S;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">type</span> Trim&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span></span><br><span class="line">  | <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  | <span class="string">`<span class="subst">$&#123;infer R&#125;</span><span class="subst">$&#123;Space&#125;</span>`</span></span><br><span class="line">  ? Trim&lt;R&gt;</span><br><span class="line">  : S;</span><br></pre></td></tr></table></figure><p>先删左边再删右边</p><h1 id="Capitalize"><a href="#Capitalize" class="headerlink" title="Capitalize"></a>Capitalize</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802165712.png" alt=""></p><p>解释:大写第一个字母</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyCapitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;Uppercase&lt;F&gt;&#125;</span><span class="subst">$&#123;R&#125;</span>`</span></span><br><span class="line">  : S;</span><br></pre></td></tr></table></figure><p>不能使用<code>[infer F,...infer R]</code>是因为我们解析的是单个字符串</p><h1 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h1><p><img src="https://cdn.jsdelivr.net/gh/Zlinni/Pic/img/20220802171025.png" alt=""></p><p>实现 Replace 替换</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Replace&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  From <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  To <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = From <span class="keyword">extends</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  ? S</span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer F&#125;</span><span class="subst">$&#123;From&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;F&#125;</span><span class="subst">$&#123;To&#125;</span><span class="subst">$&#123;R&#125;</span>`</span></span><br><span class="line">  : S;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JS系列" scheme="https://zlinni.github.io/categories/JS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="ts" scheme="https://zlinni.github.io/tags/ts/"/>
    
  </entry>
  
</feed>
